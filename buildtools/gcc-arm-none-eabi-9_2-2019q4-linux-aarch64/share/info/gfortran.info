This is gfortran.info, produced by makeinfo version 5.2 from
gfortran.texi.

Copyright (C) 1999-2019 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover Texts
being (a) (see below), and with the Back-Cover Texts being (b) (see
below).  A copy of the license is included in the section entitled "GNU
Free Documentation License".

   (a) The FSF's Front-Cover Text is:

   A GNU Manual

   (b) The FSF's Back-Cover Text is:

   You have freedom to copy and modify this GNU Manual, like GNU
software.  Copies published by the Free Software Foundation raise funds
for GNU development.
INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* gfortran: (gfortran).                  The GNU Fortran Compiler.
END-INFO-DIR-ENTRY

   This file documents the use and the internals of the GNU Fortran
compiler, ('gfortran').

   Published by the Free Software Foundation 51 Franklin Street, Fifth
Floor Boston, MA 02110-1301 USA

   Copyright (C) 1999-2019 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover Texts
being (a) (see below), and with the Back-Cover Texts being (b) (see
below).  A copy of the license is included in the section entitled "GNU
Free Documentation License".

   (a) The FSF's Front-Cover Text is:

   A GNU Manual

   (b) The FSF's Back-Cover Text is:

   You have freedom to copy and modify this GNU Manual, like GNU
software.  Copies published by the Free Software Foundation raise funds
for GNU development.


File: gfortran.info,  Node: Top,  Next: Introduction,  Up: (dir)

Introduction
************

This manual documents the use of 'gfortran', the GNU Fortran compiler.
You can find in this manual how to invoke 'gfortran', as well as its
features and incompatibilities.

* Menu:

* Introduction::

Part I: Invoking GNU Fortran
* Invoking GNU Fortran:: Command options supported by 'gfortran'.
* Runtime::              Influencing runtime behavior with environment variables.

Part II: Language Reference
* Fortran standards status::      Fortran 2003, 2008 and 2018 features supported by GNU Fortran.
* Compiler Characteristics::      User-visible implementation details.
* Extensions::                    Language extensions implemented by GNU Fortran.
* Mixed-Language Programming::    Interoperability with C
* Coarray Programming::
* Intrinsic Procedures:: Intrinsic procedures supported by GNU Fortran.
* Intrinsic Modules::    Intrinsic modules supported by GNU Fortran.

* Contributing::         How you can help.
* Copying::              GNU General Public License says
                         how you can copy and share GNU Fortran.
* GNU Free Documentation License::
                         How you can copy and share this manual.
* Funding::              How to help assure continued work for free software.
* Option Index::         Index of command line options
* Keyword Index::        Index of concepts


File: gfortran.info,  Node: Introduction,  Next: Invoking GNU Fortran,  Prev: Top,  Up: Top

1 Introduction
**************

The GNU Fortran compiler front end was designed initially as a free
replacement for, or alternative to, the Unix 'f95' command; 'gfortran'
is the command you will use to invoke the compiler.

* Menu:

* About GNU Fortran::    What you should know about the GNU Fortran compiler.
* GNU Fortran and GCC::  You can compile Fortran, C, or other programs.
* Preprocessing and conditional compilation:: The Fortran preprocessor
* GNU Fortran and G77::  Why we chose to start from scratch.
* Project Status::       Status of GNU Fortran, roadmap, proposed extensions.
* Standards::            Standards supported by GNU Fortran.


File: gfortran.info,  Node: About GNU Fortran,  Next: GNU Fortran and GCC,  Up: Introduction

1.1 About GNU Fortran
=====================

The GNU Fortran compiler supports the Fortran 77, 90 and 95 standards
completely, parts of the Fortran 2003, 2008 and 2018 standards, and
several vendor extensions.  The development goal is to provide the
following features:

   * Read a user's program, stored in a file and containing instructions
     written in Fortran 77, Fortran 90, Fortran 95, Fortran 2003,
     Fortran 2008 or Fortran 2018.  This file contains "source code".

   * Translate the user's program into instructions a computer can carry
     out more quickly than it takes to translate the instructions in the
     first place.  The result after compilation of a program is "machine
     code", code designed to be efficiently translated and processed by
     a machine such as your computer.  Humans usually are not as good
     writing machine code as they are at writing Fortran (or C++, Ada,
     or Java), because it is easy to make tiny mistakes writing machine
     code.

   * Provide the user with information about the reasons why the
     compiler is unable to create a binary from the source code.
     Usually this will be the case if the source code is flawed.  The
     Fortran 90 standard requires that the compiler can point out
     mistakes to the user.  An incorrect usage of the language causes an
     "error message".

     The compiler will also attempt to diagnose cases where the user's
     program contains a correct usage of the language, but instructs the
     computer to do something questionable.  This kind of diagnostics
     message is called a "warning message".

   * Provide optional information about the translation passes from the
     source code to machine code.  This can help a user of the compiler
     to find the cause of certain bugs which may not be obvious in the
     source code, but may be more easily found at a lower level compiler
     output.  It also helps developers to find bugs in the compiler
     itself.

   * Provide information in the generated machine code that can make it
     easier to find bugs in the program (using a debugging tool, called
     a "debugger", such as the GNU Debugger 'gdb').

   * Locate and gather machine code already generated to perform actions
     requested by statements in the user's program.  This machine code
     is organized into "modules" and is located and "linked" to the user
     program.

   The GNU Fortran compiler consists of several components:

   * A version of the 'gcc' command (which also might be installed as
     the system's 'cc' command) that also understands and accepts
     Fortran source code.  The 'gcc' command is the "driver" program for
     all the languages in the GNU Compiler Collection (GCC); With 'gcc',
     you can compile the source code of any language for which a front
     end is available in GCC.

   * The 'gfortran' command itself, which also might be installed as the
     system's 'f95' command.  'gfortran' is just another driver program,
     but specifically for the Fortran compiler only.  The difference
     with 'gcc' is that 'gfortran' will automatically link the correct
     libraries to your program.

   * A collection of run-time libraries.  These libraries contain the
     machine code needed to support capabilities of the Fortran language
     that are not directly provided by the machine code generated by the
     'gfortran' compilation phase, such as intrinsic functions and
     subroutines, and routines for interaction with files and the
     operating system.

   * The Fortran compiler itself, ('f951').  This is the GNU Fortran
     parser and code generator, linked to and interfaced with the GCC
     backend library.  'f951' "translates" the source code to assembler
     code.  You would typically not use this program directly; instead,
     the 'gcc' or 'gfortran' driver programs will call it for you.


File: gfortran.info,  Node: GNU Fortran and GCC,  Next: Preprocessing and conditional compilation,  Prev: About GNU Fortran,  Up: Introduction

1.2 GNU Fortran and GCC
=======================

GNU Fortran is a part of GCC, the "GNU Compiler Collection".  GCC
consists of a collection of front ends for various languages, which
translate the source code into a language-independent form called
"GENERIC". This is then processed by a common middle end which provides
optimization, and then passed to one of a collection of back ends which
generate code for different computer architectures and operating
systems.

   Functionally, this is implemented with a driver program ('gcc') which
provides the command-line interface for the compiler.  It calls the
relevant compiler front-end program (e.g., 'f951' for Fortran) for each
file in the source code, and then calls the assembler and linker as
appropriate to produce the compiled output.  In a copy of GCC which has
been compiled with Fortran language support enabled, 'gcc' will
recognize files with '.f', '.for', '.ftn', '.f90', '.f95', '.f03' and
'.f08' extensions as Fortran source code, and compile it accordingly.  A
'gfortran' driver program is also provided, which is identical to 'gcc'
except that it automatically links the Fortran runtime libraries into
the compiled program.

   Source files with '.f', '.for', '.fpp', '.ftn', '.F', '.FOR', '.FPP',
and '.FTN' extensions are treated as fixed form.  Source files with
'.f90', '.f95', '.f03', '.f08', '.F90', '.F95', '.F03' and '.F08'
extensions are treated as free form.  The capitalized versions of either
form are run through preprocessing.  Source files with the lower case
'.fpp' extension are also run through preprocessing.

   This manual specifically documents the Fortran front end, which
handles the programming language's syntax and semantics.  The aspects of
GCC which relate to the optimization passes and the back-end code
generation are documented in the GCC manual; see *note Introduction:
(gcc)Top.  The two manuals together provide a complete reference for the
GNU Fortran compiler.


File: gfortran.info,  Node: Preprocessing and conditional compilation,  Next: GNU Fortran and G77,  Prev: GNU Fortran and GCC,  Up: Introduction

1.3 Preprocessing and conditional compilation
=============================================

Many Fortran compilers including GNU Fortran allow passing the source
code through a C preprocessor (CPP; sometimes also called the Fortran
preprocessor, FPP) to allow for conditional compilation.  In the case of
GNU Fortran, this is the GNU C Preprocessor in the traditional mode.  On
systems with case-preserving file names, the preprocessor is
automatically invoked if the filename extension is '.F', '.FOR', '.FTN',
'.fpp', '.FPP', '.F90', '.F95', '.F03' or '.F08'.  To manually invoke
the preprocessor on any file, use '-cpp', to disable preprocessing on
files where the preprocessor is run automatically, use '-nocpp'.

   If a preprocessed file includes another file with the Fortran
'INCLUDE' statement, the included file is not preprocessed.  To
preprocess included files, use the equivalent preprocessor statement
'#include'.

   If GNU Fortran invokes the preprocessor, '__GFORTRAN__' is defined.
The macros '__GNUC__', '__GNUC_MINOR__' and '__GNUC_PATCHLEVEL__' can be
used to determine the version of the compiler.  See *note Overview:
(cpp)Top. for details.

   GNU Fortran supports a number of 'INTEGER' and 'REAL' kind types in
additional to the kind types required by the Fortran standard.  The
availability of any given kind type is architecture dependent.  The
following pre-defined preprocessor macros can be used to conditionally
include code for these additional kind types: '__GFC_INT_1__',
'__GFC_INT_2__', '__GFC_INT_8__', '__GFC_INT_16__', '__GFC_REAL_10__',
and '__GFC_REAL_16__'.

   While CPP is the de-facto standard for preprocessing Fortran code,
Part 3 of the Fortran 95 standard (ISO/IEC 1539-3:1998) defines
Conditional Compilation, which is not widely used and not directly
supported by the GNU Fortran compiler.  You can use the program coco to
preprocess such files (<http://www.daniellnagle.com/coco.html>).


File: gfortran.info,  Node: GNU Fortran and G77,  Next: Project Status,  Prev: Preprocessing and conditional compilation,  Up: Introduction

1.4 GNU Fortran and G77
=======================

The GNU Fortran compiler is the successor to 'g77', the Fortran 77 front
end included in GCC prior to version 4.  It is an entirely new program
that has been designed to provide Fortran 95 support and extensibility
for future Fortran language standards, as well as providing backwards
compatibility for Fortran 77 and nearly all of the GNU language
extensions supported by 'g77'.


File: gfortran.info,  Node: Project Status,  Next: Standards,  Prev: GNU Fortran and G77,  Up: Introduction

1.5 Project Status
==================

     As soon as 'gfortran' can parse all of the statements correctly, it
     will be in the "larva" state.  When we generate code, the "puppa"
     state.  When 'gfortran' is done, we'll see if it will be a
     beautiful butterfly, or just a big bug....

     -Andy Vaught, April 2000

   The start of the GNU Fortran 95 project was announced on the GCC
homepage in March 18, 2000 (even though Andy had already been working on
it for a while, of course).

   The GNU Fortran compiler is able to compile nearly all
standard-compliant Fortran 95, Fortran 90, and Fortran 77 programs,
including a number of standard and non-standard extensions, and can be
used on real-world programs.  In particular, the supported extensions
include OpenMP, Cray-style pointers, some old vendor extensions, and
several Fortran 2003 and Fortran 2008 features, including TR 15581.
However, it is still under development and has a few remaining rough
edges.  There also is initial support for OpenACC. Note that this is an
experimental feature, incomplete, and subject to change in future
versions of GCC. See <https://gcc.gnu.org/wiki/OpenACC> for more
information.

   At present, the GNU Fortran compiler passes the NIST Fortran 77 Test
Suite (http://www.fortran-2000.com/ArnaudRecipes/fcvs21_f95.html), and
produces acceptable results on the LAPACK Test Suite
(http://www.netlib.org/lapack/faq.html#1.21).  It also provides
respectable performance on the Polyhedron Fortran compiler benchmarks
(http://www.polyhedron.com/fortran-compiler-comparisons/polyhedron-benchmark-suite)
and the Livermore Fortran Kernels test
(http://www.netlib.org/benchmark/livermore).  It has been used to
compile a number of large real-world programs, including the HARMONIE
and HIRLAM weather forecasting code (http://hirlam.org/) and the Tonto
quantum chemistry package
(http://physical-chemistry.scb.uwa.edu.au/tonto/wiki/index.php/Main_Page);
see <https://gcc.gnu.org/wiki/GfortranApps> for an extended list.

   Among other things, the GNU Fortran compiler is intended as a
replacement for G77.  At this point, nearly all programs that could be
compiled with G77 can be compiled with GNU Fortran, although there are a
few minor known regressions.

   The primary work remaining to be done on GNU Fortran falls into three
categories: bug fixing (primarily regarding the treatment of invalid
code and providing useful error messages), improving the compiler
optimizations and the performance of compiled code, and extending the
compiler to support future standards--in particular, Fortran 2003,
Fortran 2008 and Fortran 2018.


File: gfortran.info,  Node: Standards,  Prev: Project Status,  Up: Introduction

1.6 Standards
=============

* Menu:

* Varying Length Character Strings::

The GNU Fortran compiler implements ISO/IEC 1539:1997 (Fortran 95).  As
such, it can also compile essentially all standard-compliant Fortran 90
and Fortran 77 programs.  It also supports the ISO/IEC TR-15581
enhancements to allocatable arrays.

   GNU Fortran also have a partial support for ISO/IEC 1539-1:2004
(Fortran 2003), ISO/IEC 1539-1:2010 (Fortran 2008), the Technical
Specification 'Further Interoperability of Fortran with C' (ISO/IEC TS
29113:2012).  Full support of those standards and future Fortran
standards is planned.  The current status of the support is can be found
in the *note Fortran 2003 status::, *note Fortran 2008 status:: and
*note Fortran 2018 status:: sections of the documentation.

   Additionally, the GNU Fortran compilers supports the OpenMP
specification (version 4.0 and most of the features of the 4.5 version,
<http://openmp.org/wp/openmp-specifications/>).  There also is initial
support for the OpenACC specification (targeting version 2.0,
<http://www.openacc.org/>).  Note that this is an experimental feature,
incomplete, and subject to change in future versions of GCC. See
<https://gcc.gnu.org/wiki/OpenACC> for more information.


File: gfortran.info,  Node: Varying Length Character Strings,  Up: Standards

1.6.1 Varying Length Character Strings
--------------------------------------

The Fortran 95 standard specifies in Part 2 (ISO/IEC 1539-2:2000)
varying length character strings.  While GNU Fortran currently does not
support such strings directly, there exist two Fortran implementations
for them, which work with GNU Fortran.  They can be found at
<http://www.fortran.com/iso_varying_string.f95> and at
<ftp://ftp.nag.co.uk/sc22wg5/ISO_VARYING_STRING/>.

   Deferred-length character strings of Fortran 2003 supports part of
the features of 'ISO_VARYING_STRING' and should be considered as
replacement.  (Namely, allocatable or pointers of the type
'character(len=:)'.)


File: gfortran.info,  Node: Invoking GNU Fortran,  Next: Runtime,  Prev: Introduction,  Up: Top

2 GNU Fortran Command Options
*****************************

The 'gfortran' command supports all the options supported by the 'gcc'
command.  Only options specific to GNU Fortran are documented here.

   *Note GCC Command Options: (gcc)Invoking GCC, for information on the
non-Fortran-specific aspects of the 'gcc' command (and, therefore, the
'gfortran' command).

   All GCC and GNU Fortran options are accepted both by 'gfortran' and
by 'gcc' (as well as any other drivers built at the same time, such as
'g++'), since adding GNU Fortran to the GCC distribution enables
acceptance of GNU Fortran options by all of the relevant drivers.

   In some cases, options have positive and negative forms; the negative
form of '-ffoo' would be '-fno-foo'.  This manual documents only one of
these two forms, whichever one is not the default.

* Menu:

* Option Summary::      Brief list of all 'gfortran' options,
                        without explanations.
* Fortran Dialect Options::  Controlling the variant of Fortran language
                             compiled.
* Preprocessing Options::  Enable and customize preprocessing.
* Error and Warning Options::     How picky should the compiler be?
* Debugging Options::   Symbol tables, measurements, and debugging dumps.
* Directory Options::   Where to find module files
* Link Options ::       Influencing the linking step
* Runtime Options::     Influencing runtime behavior
* Code Gen Options::    Specifying conventions for function calls, data layout
                        and register usage.
* Interoperability Options::  Options for interoperability with other
                              languages.
* Environment Variables:: Environment variables that affect 'gfortran'.


File: gfortran.info,  Node: Option Summary,  Next: Fortran Dialect Options,  Up: Invoking GNU Fortran

2.1 Option summary
==================

Here is a summary of all the options specific to GNU Fortran, grouped by
type.  Explanations are in the following sections.

_Fortran Language Options_
     *Note Options controlling Fortran dialect: Fortran Dialect Options.
          -fall-intrinsics -fbackslash -fcray-pointer -fd-lines-as-code
          -fd-lines-as-comments
          -fdec -fdec-structure -fdec-intrinsic-ints -fdec-static -fdec-math
          -fdec-include -fdefault-double-8 -fdefault-integer-8 -fdefault-real-8
          -fdefault-real-10 -fdefault-real-16 -fdollar-ok -ffixed-line-length-N
          -ffixed-line-length-none -fpad-source -ffree-form -ffree-line-length-N
          -ffree-line-length-none -fimplicit-none -finteger-4-integer-8
          -fmax-identifier-length -fmodule-private -ffixed-form -fno-range-check
          -fopenacc -fopenmp -freal-4-real-10 -freal-4-real-16 -freal-4-real-8
          -freal-8-real-10 -freal-8-real-16 -freal-8-real-4 -std=STD
          -ftest-forall-temp


_Preprocessing Options_
     *Note Enable and customize preprocessing: Preprocessing Options.
          -A-QUESTION[=ANSWER]
          -AQUESTION=ANSWER -C -CC -DMACRO[=DEFN]
          -H -P
          -UMACRO -cpp -dD -dI -dM -dN -dU -fworking-directory
          -imultilib DIR
          -iprefix FILE -iquote -isysroot DIR -isystem DIR -nocpp
          -nostdinc
          -undef


_Error and Warning Options_
     *Note Options to request or suppress errors and warnings: Error and
     Warning Options.
          -Waliasing -Wall -Wampersand -Wargument-mismatch -Warray-bounds
          -Wc-binding-type -Wcharacter-truncation -Wconversion
          -Wdo-subscript -Wfunction-elimination -Wimplicit-interface
          -Wimplicit-procedure -Wintrinsic-shadow -Wuse-without-only -Wintrinsics-std
          -Wline-truncation -Wno-align-commons -Wno-tabs -Wreal-q-constant
          -Wsurprising -Wunderflow -Wunused-parameter -Wrealloc-lhs
          -Wrealloc-lhs-all -Wfrontend-loop-interchange -Wtarget-lifetime
          -fmax-errors=N -fsyntax-only -pedantic -pedantic-errors


_Debugging Options_
     *Note Options for debugging your program or GNU Fortran: Debugging
     Options.
          -fbacktrace -fdump-fortran-optimized -fdump-fortran-original
          -fdump-fortran-global -fdump-parse-tree -ffpe-trap=LIST
          -ffpe-summary=LIST


_Directory Options_
     *Note Options for directory search: Directory Options.
          -IDIR  -JDIR -fintrinsic-modules-path DIR

_Link Options_
     *Note Options for influencing the linking step: Link Options.
          -static-libgfortran

_Runtime Options_
     *Note Options for influencing runtime behavior: Runtime Options.
          -fconvert=CONVERSION -fmax-subrecord-length=LENGTH
          -frecord-marker=LENGTH -fsign-zero


_Interoperability Options_
     *Note Options for interoperability: Interoperability Options.
          -fc-prototypes -fc-prototypes-external

_Code Generation Options_
     *Note Options for code generation conventions: Code Gen Options.
          -faggressive-function-elimination -fblas-matmul-limit=N
          -fbounds-check -ftail-call-workaround -ftail-call-workaround=N
          -fcheck-array-temporaries
          -fcheck=<ALL|ARRAY-TEMPS|BOUNDS|DO|MEM|POINTER|RECURSION>
          -fcoarray=<NONE|SINGLE|LIB> -fexternal-blas -ff2c
          -ffrontend-loop-interchange
          -ffrontend-optimize
          -finit-character=N -finit-integer=N -finit-local-zero
          -finit-derived
          -finit-logical=<TRUE|FALSE>
          -finit-real=<ZERO|INF|-INF|NAN|SNAN>
          -finline-matmul-limit=N
          -fmax-array-constructor=N -fmax-stack-var-size=N
          -fno-align-commons
          -fno-automatic -fno-protect-parens -fno-underscoring
          -fsecond-underscore -fpack-derived -frealloc-lhs -frecursive
          -frepack-arrays -fshort-enums -fstack-arrays



File: gfortran.info,  Node: Fortran Dialect Options,  Next: Preprocessing Options,  Prev: Option Summary,  Up: Invoking GNU Fortran

2.2 Options controlling Fortran dialect
=======================================

The following options control the details of the Fortran dialect
accepted by the compiler:

'-ffree-form'
'-ffixed-form'
     Specify the layout used by the source file.  The free form layout
     was introduced in Fortran 90.  Fixed form was traditionally used in
     older Fortran programs.  When neither option is specified, the
     source form is determined by the file extension.

'-fall-intrinsics'
     This option causes all intrinsic procedures (including the
     GNU-specific extensions) to be accepted.  This can be useful with
     '-std=f95' to force standard-compliance but get access to the full
     range of intrinsics available with 'gfortran'.  As a consequence,
     '-Wintrinsics-std' will be ignored and no user-defined procedure
     with the same name as any intrinsic will be called except when it
     is explicitly declared 'EXTERNAL'.

'-fd-lines-as-code'
'-fd-lines-as-comments'
     Enable special treatment for lines beginning with 'd' or 'D' in
     fixed form sources.  If the '-fd-lines-as-code' option is given
     they are treated as if the first column contained a blank.  If the
     '-fd-lines-as-comments' option is given, they are treated as
     comment lines.

'-fdec'
     DEC compatibility mode.  Enables extensions and other features that
     mimic the default behavior of older compilers (such as DEC). These
     features are non-standard and should be avoided at all costs.  For
     details on GNU Fortran's implementation of these extensions see the
     full documentation.

     Other flags enabled by this switch are: '-fdollar-ok'
     '-fcray-pointer' '-fdec-structure' '-fdec-intrinsic-ints'
     '-fdec-static' '-fdec-math'

     If '-fd-lines-as-code'/'-fd-lines-as-comments' are unset, then
     '-fdec' also sets '-fd-lines-as-comments'.

'-fdec-structure'
     Enable DEC 'STRUCTURE' and 'RECORD' as well as 'UNION', 'MAP', and
     dot ('.')  as a member separator (in addition to '%').  This is
     provided for compatibility only; Fortran 90 derived types should be
     used instead where possible.

'-fdec-intrinsic-ints'
     Enable B/I/J/K kind variants of existing integer functions (e.g.
     BIAND, IIAND, JIAND, etc...).  For a complete list of intrinsics
     see the full documentation.

'-fdec-math'
     Enable legacy math intrinsics such as COTAN and degree-valued
     trigonometric functions (e.g.  TAND, ATAND, etc...)  for
     compatability with older code.

'-fdec-static'
     Enable DEC-style STATIC and AUTOMATIC attributes to explicitly
     specify the storage of variables and other objects.

'-fdec-include'
     Enable parsing of INCLUDE as a statement in addition to parsing it
     as INCLUDE line.  When parsed as INCLUDE statement, INCLUDE does
     not have to be on a single line and can use line continuations.

'-fdollar-ok'
     Allow '$' as a valid non-first character in a symbol name.  Symbols
     that start with '$' are rejected since it is unclear which rules to
     apply to implicit typing as different vendors implement different
     rules.  Using '$' in 'IMPLICIT' statements is also rejected.

'-fbackslash'
     Change the interpretation of backslashes in string literals from a
     single backslash character to "C-style" escape characters.  The
     following combinations are expanded '\a', '\b', '\f', '\n', '\r',
     '\t', '\v', '\\', and '\0' to the ASCII characters alert,
     backspace, form feed, newline, carriage return, horizontal tab,
     vertical tab, backslash, and NUL, respectively.  Additionally,
     '\x'NN, '\u'NNNN and '\U'NNNNNNNN (where each N is a hexadecimal
     digit) are translated into the Unicode characters corresponding to
     the specified code points.  All other combinations of a character
     preceded by \ are unexpanded.

'-fmodule-private'
     Set the default accessibility of module entities to 'PRIVATE'.
     Use-associated entities will not be accessible unless they are
     explicitly declared as 'PUBLIC'.

'-ffixed-line-length-N'
     Set column after which characters are ignored in typical fixed-form
     lines in the source file, and, unless '-fno-pad-source', through
     which spaces are assumed (as if padded to that length) after the
     ends of short fixed-form lines.

     Popular values for N include 72 (the standard and the default), 80
     (card image), and 132 (corresponding to "extended-source" options
     in some popular compilers).  N may also be 'none', meaning that the
     entire line is meaningful and that continued character constants
     never have implicit spaces appended to them to fill out the line.
     '-ffixed-line-length-0' means the same thing as
     '-ffixed-line-length-none'.

'-fno-pad-source'
     By default fixed-form lines have spaces assumed (as if padded to
     that length) after the ends of short fixed-form lines.  This is not
     done either if '-ffixed-line-length-0', '-ffixed-line-length-none'
     or if '-fno-pad-source' option is used.  With any of those options
     continued character constants never have implicit spaces appended
     to them to fill out the line.

'-ffree-line-length-N'
     Set column after which characters are ignored in typical free-form
     lines in the source file.  The default value is 132.  N may be
     'none', meaning that the entire line is meaningful.
     '-ffree-line-length-0' means the same thing as
     '-ffree-line-length-none'.

'-fmax-identifier-length=N'
     Specify the maximum allowed identifier length.  Typical values are
     31 (Fortran 95) and 63 (Fortran 2003 and Fortran 2008).

'-fimplicit-none'
     Specify that no implicit typing is allowed, unless overridden by
     explicit 'IMPLICIT' statements.  This is the equivalent of adding
     'implicit none' to the start of every procedure.

'-fcray-pointer'
     Enable the Cray pointer extension, which provides C-like pointer
     functionality.

'-fopenacc'
     Enable the OpenACC extensions.  This includes OpenACC '!$acc'
     directives in free form and 'c$acc', '*$acc' and '!$acc' directives
     in fixed form, '!$' conditional compilation sentinels in free form
     and 'c$', '*$' and '!$' sentinels in fixed form, and when linking
     arranges for the OpenACC runtime library to be linked in.

     Note that this is an experimental feature, incomplete, and subject
     to change in future versions of GCC. See <https://gcc.gnu.org/wiki/OpenACC>
     for more information.

'-fopenmp'
     Enable the OpenMP extensions.  This includes OpenMP '!$omp'
     directives in free form and 'c$omp', '*$omp' and '!$omp' directives
     in fixed form, '!$' conditional compilation sentinels in free form
     and 'c$', '*$' and '!$' sentinels in fixed form, and when linking
     arranges for the OpenMP runtime library to be linked in.  The
     option '-fopenmp' implies '-frecursive'.

'-fno-range-check'
     Disable range checking on results of simplification of constant
     expressions during compilation.  For example, GNU Fortran will give
     an error at compile time when simplifying 'a = 1. / 0'.  With this
     option, no error will be given and 'a' will be assigned the value
     '+Infinity'.  If an expression evaluates to a value outside of the
     relevant range of ['-HUGE()':'HUGE()'], then the expression will be
     replaced by '-Inf' or '+Inf' as appropriate.  Similarly, 'DATA
     i/Z'FFFFFFFF'/' will result in an integer overflow on most systems,
     but with '-fno-range-check' the value will "wrap around" and 'i'
     will be initialized to -1 instead.

'-fdefault-integer-8'
     Set the default integer and logical types to an 8 byte wide type.
     This option also affects the kind of integer constants like '42'.
     Unlike '-finteger-4-integer-8', it does not promote variables with
     explicit kind declaration.

'-fdefault-real-8'
     Set the default real type to an 8 byte wide type.  This option also
     affects the kind of non-double real constants like '1.0'.  This
     option promotes the default width of 'DOUBLE PRECISION' and double
     real constants like '1.d0' to 16 bytes if possible.  If
     '-fdefault-double-8' is given along with 'fdefault-real-8', 'DOUBLE
     PRECISION' and double real constants are not promoted.  Unlike
     '-freal-4-real-8', 'fdefault-real-8' does not promote variables
     with explicit kind declarations.

'-fdefault-real-10'
     Set the default real type to an 10 byte wide type.  This option
     also affects the kind of non-double real constants like '1.0'.
     This option promotes the default width of 'DOUBLE PRECISION' and
     double real constants like '1.d0' to 16 bytes if possible.  If
     '-fdefault-double-8' is given along with 'fdefault-real-10',
     'DOUBLE PRECISION' and double real constants are not promoted.
     Unlike '-freal-4-real-10', 'fdefault-real-10' does not promote
     variables with explicit kind declarations.

'-fdefault-real-16'
     Set the default real type to an 16 byte wide type.  This option
     also affects the kind of non-double real constants like '1.0'.
     This option promotes the default width of 'DOUBLE PRECISION' and
     double real constants like '1.d0' to 16 bytes if possible.  If
     '-fdefault-double-8' is given along with 'fdefault-real-16',
     'DOUBLE PRECISION' and double real constants are not promoted.
     Unlike '-freal-4-real-16', 'fdefault-real-16' does not promote
     variables with explicit kind declarations.

'-fdefault-double-8'
     Set the 'DOUBLE PRECISION' type and double real constants like
     '1.d0' to an 8 byte wide type.  Do nothing if this is already the
     default.  This option prevents '-fdefault-real-8',
     '-fdefault-real-10', and '-fdefault-real-16', from promoting
     'DOUBLE PRECISION' and double real constants like '1.d0' to 16
     bytes.

'-finteger-4-integer-8'
     Promote all 'INTEGER(KIND=4)' entities to an 'INTEGER(KIND=8)'
     entities.  If 'KIND=8' is unavailable, then an error will be
     issued.  This option should be used with care and may not be
     suitable for your codes.  Areas of possible concern include calls
     to external procedures, alignment in 'EQUIVALENCE' and/or 'COMMON',
     generic interfaces, BOZ literal constant conversion, and I/O.
     Inspection of the intermediate representation of the translated
     Fortran code, produced by '-fdump-tree-original', is suggested.

'-freal-4-real-8'
'-freal-4-real-10'
'-freal-4-real-16'
'-freal-8-real-4'
'-freal-8-real-10'
'-freal-8-real-16'
     Promote all 'REAL(KIND=M)' entities to 'REAL(KIND=N)' entities.  If
     'REAL(KIND=N)' is unavailable, then an error will be issued.  All
     other real kind types are unaffected by this option.  These options
     should be used with care and may not be suitable for your codes.
     Areas of possible concern include calls to external procedures,
     alignment in 'EQUIVALENCE' and/or 'COMMON', generic interfaces, BOZ
     literal constant conversion, and I/O. Inspection of the
     intermediate representation of the translated Fortran code,
     produced by '-fdump-tree-original', is suggested.

'-std=STD'
     Specify the standard to which the program is expected to conform,
     which may be one of 'f95', 'f2003', 'f2008', 'f2018', 'gnu', or
     'legacy'.  The default value for STD is 'gnu', which specifies a
     superset of the latest Fortran standard that includes all of the
     extensions supported by GNU Fortran, although warnings will be
     given for obsolete extensions not recommended for use in new code.
     The 'legacy' value is equivalent but without the warnings for
     obsolete extensions, and may be useful for old non-standard
     programs.  The 'f95', 'f2003', 'f2008', and 'f2018' values specify
     strict conformance to the Fortran 95, Fortran 2003, Fortran 2008
     and Fortran 2018 standards, respectively; errors are given for all
     extensions beyond the relevant language standard, and warnings are
     given for the Fortran 77 features that are permitted but
     obsolescent in later standards.  The deprecated option
     '-std=f2008ts' acts as an alias for '-std=f2018'.  It is only
     present for backwards compatibility with earlier gfortran versions
     and should not be used any more.

'-ftest-forall-temp'
     Enhance test coverage by forcing most forall assignments to use
     temporary.


File: gfortran.info,  Node: Preprocessing Options,  Next: Error and Warning Options,  Prev: Fortran Dialect Options,  Up: Invoking GNU Fortran

2.3 Enable and customize preprocessing
======================================

Preprocessor related options.  See section *note Preprocessing and
conditional compilation:: for more detailed information on preprocessing
in 'gfortran'.

'-cpp'
'-nocpp'
     Enable preprocessing.  The preprocessor is automatically invoked if
     the file extension is '.fpp', '.FPP', '.F', '.FOR', '.FTN', '.F90',
     '.F95', '.F03' or '.F08'.  Use this option to manually enable
     preprocessing of any kind of Fortran file.

     To disable preprocessing of files with any of the above listed
     extensions, use the negative form: '-nocpp'.

     The preprocessor is run in traditional mode.  Any restrictions of
     the file-format, especially the limits on line length, apply for
     preprocessed output as well, so it might be advisable to use the
     '-ffree-line-length-none' or '-ffixed-line-length-none' options.

'-dM'
     Instead of the normal output, generate a list of ''#define''
     directives for all the macros defined during the execution of the
     preprocessor, including predefined macros.  This gives you a way of
     finding out what is predefined in your version of the preprocessor.
     Assuming you have no file 'foo.f90', the command
            touch foo.f90; gfortran -cpp -E -dM foo.f90
     will show all the predefined macros.

'-dD'
     Like '-dM' except in two respects: it does not include the
     predefined macros, and it outputs both the '#define' directives and
     the result of preprocessing.  Both kinds of output go to the
     standard output file.

'-dN'
     Like '-dD', but emit only the macro names, not their expansions.

'-dU'
     Like 'dD' except that only macros that are expanded, or whose
     definedness is tested in preprocessor directives, are output; the
     output is delayed until the use or test of the macro; and
     ''#undef'' directives are also output for macros tested but
     undefined at the time.

'-dI'
     Output ''#include'' directives in addition to the result of
     preprocessing.

'-fworking-directory'
     Enable generation of linemarkers in the preprocessor output that
     will let the compiler know the current working directory at the
     time of preprocessing.  When this option is enabled, the
     preprocessor will emit, after the initial linemarker, a second
     linemarker with the current working directory followed by two
     slashes.  GCC will use this directory, when it is present in the
     preprocessed input, as the directory emitted as the current working
     directory in some debugging information formats.  This option is
     implicitly enabled if debugging information is enabled, but this
     can be inhibited with the negated form '-fno-working-directory'.
     If the '-P' flag is present in the command line, this option has no
     effect, since no '#line' directives are emitted whatsoever.

'-idirafter DIR'
     Search DIR for include files, but do it after all directories
     specified with '-I' and the standard system directories have been
     exhausted.  DIR is treated as a system include directory.  If dir
     begins with '=', then the '=' will be replaced by the sysroot
     prefix; see '--sysroot' and '-isysroot'.

'-imultilib DIR'
     Use DIR as a subdirectory of the directory containing
     target-specific C++ headers.

'-iprefix PREFIX'
     Specify PREFIX as the prefix for subsequent '-iwithprefix' options.
     If the PREFIX represents a directory, you should include the final
     ''/''.

'-isysroot DIR'
     This option is like the '--sysroot' option, but applies only to
     header files.  See the '--sysroot' option for more information.

'-iquote DIR'
     Search DIR only for header files requested with '#include "file"';
     they are not searched for '#include <file>', before all directories
     specified by '-I' and before the standard system directories.  If
     DIR begins with '=', then the '=' will be replaced by the sysroot
     prefix; see '--sysroot' and '-isysroot'.

'-isystem DIR'
     Search DIR for header files, after all directories specified by
     '-I' but before the standard system directories.  Mark it as a
     system directory, so that it gets the same special treatment as is
     applied to the standard system directories.  If DIR begins with
     '=', then the '=' will be replaced by the sysroot prefix; see
     '--sysroot' and '-isysroot'.

'-nostdinc'
     Do not search the standard system directories for header files.
     Only the directories you have specified with '-I' options (and the
     directory of the current file, if appropriate) are searched.

'-undef'
     Do not predefine any system-specific or GCC-specific macros.  The
     standard predefined macros remain defined.

'-APREDICATE=ANSWER'
     Make an assertion with the predicate PREDICATE and answer ANSWER.
     This form is preferred to the older form -A predicate(answer),
     which is still supported, because it does not use shell special
     characters.

'-A-PREDICATE=ANSWER'
     Cancel an assertion with the predicate PREDICATE and answer ANSWER.

'-C'
     Do not discard comments.  All comments are passed through to the
     output file, except for comments in processed directives, which are
     deleted along with the directive.

     You should be prepared for side effects when using '-C'; it causes
     the preprocessor to treat comments as tokens in their own right.
     For example, comments appearing at the start of what would be a
     directive line have the effect of turning that line into an
     ordinary source line, since the first token on the line is no
     longer a ''#''.

     Warning: this currently handles C-Style comments only.  The
     preprocessor does not yet recognize Fortran-style comments.

'-CC'
     Do not discard comments, including during macro expansion.  This is
     like '-C', except that comments contained within macros are also
     passed through to the output file where the macro is expanded.

     In addition to the side-effects of the '-C' option, the '-CC'
     option causes all C++-style comments inside a macro to be converted
     to C-style comments.  This is to prevent later use of that macro
     from inadvertently commenting out the remainder of the source line.
     The '-CC' option is generally used to support lint comments.

     Warning: this currently handles C- and C++-Style comments only.
     The preprocessor does not yet recognize Fortran-style comments.

'-DNAME'
     Predefine name as a macro, with definition '1'.

'-DNAME=DEFINITION'
     The contents of DEFINITION are tokenized and processed as if they
     appeared during translation phase three in a ''#define'' directive.
     In particular, the definition will be truncated by embedded newline
     characters.

     If you are invoking the preprocessor from a shell or shell-like
     program you may need to use the shell's quoting syntax to protect
     characters such as spaces that have a meaning in the shell syntax.

     If you wish to define a function-like macro on the command line,
     write its argument list with surrounding parentheses before the
     equals sign (if any).  Parentheses are meaningful to most shells,
     so you will need to quote the option.  With sh and csh,
     '-D'name(args...)=definition'' works.

     '-D' and '-U' options are processed in the order they are given on
     the command line.  All -imacros file and -include file options are
     processed after all -D and -U options.

'-H'
     Print the name of each header file used, in addition to other
     normal activities.  Each name is indented to show how deep in the
     ''#include'' stack it is.

'-P'
     Inhibit generation of linemarkers in the output from the
     preprocessor.  This might be useful when running the preprocessor
     on something that is not C code, and will be sent to a program
     which might be confused by the linemarkers.

'-UNAME'
     Cancel any previous definition of NAME, either built in or provided
     with a '-D' option.


File: gfortran.info,  Node: Error and Warning Options,  Next: Debugging Options,  Prev: Preprocessing Options,  Up: Invoking GNU Fortran

2.4 Options to request or suppress errors and warnings
======================================================

Errors are diagnostic messages that report that the GNU Fortran compiler
cannot compile the relevant piece of source code.  The compiler will
continue to process the program in an attempt to report further errors
to aid in debugging, but will not produce any compiled output.

   Warnings are diagnostic messages that report constructions which are
not inherently erroneous but which are risky or suggest there is likely
to be a bug in the program.  Unless '-Werror' is specified, they do not
prevent compilation of the program.

   You can request many specific warnings with options beginning '-W',
for example '-Wimplicit' to request warnings on implicit declarations.
Each of these specific warning options also has a negative form
beginning '-Wno-' to turn off warnings; for example, '-Wno-implicit'.
This manual lists only one of the two forms, whichever is not the
default.

   These options control the amount and kinds of errors and warnings
produced by GNU Fortran:

'-fmax-errors=N'
     Limits the maximum number of error messages to N, at which point
     GNU Fortran bails out rather than attempting to continue processing
     the source code.  If N is 0, there is no limit on the number of
     error messages produced.

'-fsyntax-only'
     Check the code for syntax errors, but do not actually compile it.
     This will generate module files for each module present in the
     code, but no other output file.

'-Wpedantic'
'-pedantic'
     Issue warnings for uses of extensions to Fortran.  '-pedantic' also
     applies to C-language constructs where they occur in GNU Fortran
     source files, such as use of '\e' in a character constant within a
     directive like '#include'.

     Valid Fortran programs should compile properly with or without this
     option.  However, without this option, certain GNU extensions and
     traditional Fortran features are supported as well.  With this
     option, many of them are rejected.

     Some users try to use '-pedantic' to check programs for
     conformance.  They soon find that it does not do quite what they
     want--it finds some nonstandard practices, but not all.  However,
     improvements to GNU Fortran in this area are welcome.

     This should be used in conjunction with '-std=f95', '-std=f2003',
     '-std=f2008' or '-std=f2018'.

'-pedantic-errors'
     Like '-pedantic', except that errors are produced rather than
     warnings.

'-Wall'
     Enables commonly used warning options pertaining to usage that we
     recommend avoiding and that we believe are easy to avoid.  This
     currently includes '-Waliasing', '-Wampersand', '-Wconversion',
     '-Wsurprising', '-Wc-binding-type', '-Wintrinsics-std', '-Wtabs',
     '-Wintrinsic-shadow', '-Wline-truncation', '-Wtarget-lifetime',
     '-Winteger-division', '-Wreal-q-constant', '-Wunused' and
     '-Wundefined-do-loop'.

'-Waliasing'
     Warn about possible aliasing of dummy arguments.  Specifically, it
     warns if the same actual argument is associated with a dummy
     argument with 'INTENT(IN)' and a dummy argument with 'INTENT(OUT)'
     in a call with an explicit interface.

     The following example will trigger the warning.
            interface
              subroutine bar(a,b)
                integer, intent(in) :: a
                integer, intent(out) :: b
              end subroutine
            end interface
            integer :: a

            call bar(a,a)

'-Wampersand'
     Warn about missing ampersand in continued character constants.  The
     warning is given with '-Wampersand', '-pedantic', '-std=f95',
     '-std=f2003', '-std=f2008' and '-std=f2018'.  Note: With no
     ampersand given in a continued character constant, GNU Fortran
     assumes continuation at the first non-comment, non-whitespace
     character after the ampersand that initiated the continuation.

'-Wargument-mismatch'
     Warn about type, rank, and other mismatches between formal
     parameters and actual arguments to functions and subroutines.
     These warnings are recommended and thus enabled by default.

'-Warray-temporaries'
     Warn about array temporaries generated by the compiler.  The
     information generated by this warning is sometimes useful in
     optimization, in order to avoid such temporaries.

'-Wc-binding-type'
     Warn if the a variable might not be C interoperable.  In
     particular, warn if the variable has been declared using an
     intrinsic type with default kind instead of using a kind parameter
     defined for C interoperability in the intrinsic 'ISO_C_Binding'
     module.  This option is implied by '-Wall'.

'-Wcharacter-truncation'
     Warn when a character assignment will truncate the assigned string.

'-Wline-truncation'
     Warn when a source code line will be truncated.  This option is
     implied by '-Wall'.  For free-form source code, the default is
     '-Werror=line-truncation' such that truncations are reported as
     error.

'-Wconversion'
     Warn about implicit conversions that are likely to change the value
     of the expression after conversion.  Implied by '-Wall'.

'-Wconversion-extra'
     Warn about implicit conversions between different types and kinds.
     This option does _not_ imply '-Wconversion'.

'-Wextra'
     Enables some warning options for usages of language features which
     may be problematic.  This currently includes '-Wcompare-reals',
     '-Wunused-parameter' and '-Wdo-subscript'.

'-Wfrontend-loop-interchange'
     Enable warning for loop interchanges performed by the
     '-ffrontend-loop-interchange' option.

'-Wimplicit-interface'
     Warn if a procedure is called without an explicit interface.  Note
     this only checks that an explicit interface is present.  It does
     not check that the declared interfaces are consistent across
     program units.

'-Wimplicit-procedure'
     Warn if a procedure is called that has neither an explicit
     interface nor has been declared as 'EXTERNAL'.

'-Winteger-division'
     Warn if a constant integer division truncates it result.  As an
     example, 3/5 evaluates to 0.

'-Wintrinsics-std'
     Warn if 'gfortran' finds a procedure named like an intrinsic not
     available in the currently selected standard (with '-std') and
     treats it as 'EXTERNAL' procedure because of this.
     '-fall-intrinsics' can be used to never trigger this behavior and
     always link to the intrinsic regardless of the selected standard.

'-Wreal-q-constant'
     Produce a warning if a real-literal-constant contains a 'q'
     exponent-letter.

'-Wsurprising'
     Produce a warning when "suspicious" code constructs are
     encountered.  While technically legal these usually indicate that
     an error has been made.

     This currently produces a warning under the following
     circumstances:

        * An INTEGER SELECT construct has a CASE that can never be
          matched as its lower value is greater than its upper value.

        * A LOGICAL SELECT construct has three CASE statements.

        * A TRANSFER specifies a source that is shorter than the
          destination.

        * The type of a function result is declared more than once with
          the same type.  If '-pedantic' or standard-conforming mode is
          enabled, this is an error.

        * A 'CHARACTER' variable is declared with negative length.

'-Wtabs'
     By default, tabs are accepted as whitespace, but tabs are not
     members of the Fortran Character Set.  For continuation lines, a
     tab followed by a digit between 1 and 9 is supported.  '-Wtabs'
     will cause a warning to be issued if a tab is encountered.  Note,
     '-Wtabs' is active for '-pedantic', '-std=f95', '-std=f2003',
     '-std=f2008', '-std=f2018' and '-Wall'.

'-Wundefined-do-loop'
     Warn if a DO loop with step either 1 or -1 yields an underflow or
     an overflow during iteration of an induction variable of the loop.
     This option is implied by '-Wall'.

'-Wunderflow'
     Produce a warning when numerical constant expressions are
     encountered, which yield an UNDERFLOW during compilation.  Enabled
     by default.

'-Wintrinsic-shadow'
     Warn if a user-defined procedure or module procedure has the same
     name as an intrinsic; in this case, an explicit interface or
     'EXTERNAL' or 'INTRINSIC' declaration might be needed to get calls
     later resolved to the desired intrinsic/procedure.  This option is
     implied by '-Wall'.

'-Wuse-without-only'
     Warn if a 'USE' statement has no 'ONLY' qualifier and thus
     implicitly imports all public entities of the used module.

'-Wunused-dummy-argument'
     Warn about unused dummy arguments.  This option is implied by
     '-Wall'.

'-Wunused-parameter'
     Contrary to 'gcc''s meaning of '-Wunused-parameter', 'gfortran''s
     implementation of this option does not warn about unused dummy
     arguments (see '-Wunused-dummy-argument'), but about unused
     'PARAMETER' values.  '-Wunused-parameter' is implied by '-Wextra'
     if also '-Wunused' or '-Wall' is used.

'-Walign-commons'
     By default, 'gfortran' warns about any occasion of variables being
     padded for proper alignment inside a 'COMMON' block.  This warning
     can be turned off via '-Wno-align-commons'.  See also
     '-falign-commons'.

'-Wfunction-elimination'
     Warn if any calls to impure functions are eliminated by the
     optimizations enabled by the '-ffrontend-optimize' option.  This
     option is implied by '-Wextra'.

'-Wrealloc-lhs'
     Warn when the compiler might insert code to for allocation or
     reallocation of an allocatable array variable of intrinsic type in
     intrinsic assignments.  In hot loops, the Fortran 2003 reallocation
     feature may reduce the performance.  If the array is already
     allocated with the correct shape, consider using a whole-array
     array-spec (e.g.  '(:,:,:)') for the variable on the left-hand side
     to prevent the reallocation check.  Note that in some cases the
     warning is shown, even if the compiler will optimize reallocation
     checks away.  For instance, when the right-hand side contains the
     same variable multiplied by a scalar.  See also '-frealloc-lhs'.

'-Wrealloc-lhs-all'
     Warn when the compiler inserts code to for allocation or
     reallocation of an allocatable variable; this includes scalars and
     derived types.

'-Wcompare-reals'
     Warn when comparing real or complex types for equality or
     inequality.  This option is implied by '-Wextra'.

'-Wtarget-lifetime'
     Warn if the pointer in a pointer assignment might be longer than
     the its target.  This option is implied by '-Wall'.

'-Wzerotrip'
     Warn if a 'DO' loop is known to execute zero times at compile time.
     This option is implied by '-Wall'.

'-Wdo-subscript'
     Warn if an array subscript inside a DO loop could lead to an
     out-of-bounds access even if the compiler cannot prove that the
     statement is actually executed, in cases like
            real a(3)
            do i=1,4
              if (condition(i)) then
                a(i) = 1.2
              end if
            end do
     This option is implied by '-Wextra'.

'-Werror'
     Turns all warnings into errors.

   *Note Options to Request or Suppress Errors and Warnings:
(gcc)Warning Options, for information on more options offered by the GBE
shared by 'gfortran', 'gcc' and other GNU compilers.

   Some of these have no effect when compiling programs written in
Fortran.


File: gfortran.info,  Node: Debugging Options,  Next: Directory Options,  Prev: Error and Warning Options,  Up: Invoking GNU Fortran

2.5 Options for debugging your program or GNU Fortran
=====================================================

GNU Fortran has various special options that are used for debugging
either your program or the GNU Fortran compiler.

'-fdump-fortran-original'
     Output the internal parse tree after translating the source program
     into internal representation.  This option is mostly useful for
     debugging the GNU Fortran compiler itself.  The output generated by
     this option might change between releases.  This option may also
     generate internal compiler errors for features which have only
     recently been added.

'-fdump-fortran-optimized'
     Output the parse tree after front-end optimization.  Mostly useful
     for debugging the GNU Fortran compiler itself.  The output
     generated by this option might change between releases.  This
     option may also generate internal compiler errors for features
     which have only recently been added.

'-fdump-parse-tree'
     Output the internal parse tree after translating the source program
     into internal representation.  Mostly useful for debugging the GNU
     Fortran compiler itself.  The output generated by this option might
     change between releases.  This option may also generate internal
     compiler errors for features which have only recently been added.
     This option is deprecated; use '-fdump-fortran-original' instead.

'-fdump-fortran-global'
     Output a list of the global identifiers after translating into
     middle-end representation.  Mostly useful for debugging the GNU
     Fortran compiler itself.  The output generated by this option might
     change between releases.  This option may also generate internal
     compiler errors for features which have only recently been added.

'-ffpe-trap=LIST'
     Specify a list of floating point exception traps to enable.  On
     most systems, if a floating point exception occurs and the trap for
     that exception is enabled, a SIGFPE signal will be sent and the
     program being aborted, producing a core file useful for debugging.
     LIST is a (possibly empty) comma-separated list of the following
     exceptions: 'invalid' (invalid floating point operation, such as
     'SQRT(-1.0)'), 'zero' (division by zero), 'overflow' (overflow in a
     floating point operation), 'underflow' (underflow in a floating
     point operation), 'inexact' (loss of precision during operation),
     and 'denormal' (operation performed on a denormal value).  The
     first five exceptions correspond to the five IEEE 754 exceptions,
     whereas the last one ('denormal') is not part of the IEEE 754
     standard but is available on some common architectures such as x86.

     The first three exceptions ('invalid', 'zero', and 'overflow')
     often indicate serious errors, and unless the program has
     provisions for dealing with these exceptions, enabling traps for
     these three exceptions is probably a good idea.

     If the option is used more than once in the command line, the lists
     will be joined: ''ffpe-trap='LIST1 'ffpe-trap='LIST2' is equivalent
     to 'ffpe-trap='LIST1,LIST2.

     Note that once enabled an exception cannot be disabled (no negative
     form).

     Many, if not most, floating point operations incur loss of
     precision due to rounding, and hence the 'ffpe-trap=inexact' is
     likely to be uninteresting in practice.

     By default no exception traps are enabled.

'-ffpe-summary=LIST'
     Specify a list of floating-point exceptions, whose flag status is
     printed to 'ERROR_UNIT' when invoking 'STOP' and 'ERROR STOP'.
     LIST can be either 'none', 'all' or a comma-separated list of the
     following exceptions: 'invalid', 'zero', 'overflow', 'underflow',
     'inexact' and 'denormal'.  (See '-ffpe-trap' for a description of
     the exceptions.)

     If the option is used more than once in the command line, only the
     last one will be used.

     By default, a summary for all exceptions but 'inexact' is shown.

'-fno-backtrace'
     When a serious runtime error is encountered or a deadly signal is
     emitted (segmentation fault, illegal instruction, bus error,
     floating-point exception, and the other POSIX signals that have the
     action 'core'), the Fortran runtime library tries to output a
     backtrace of the error.  '-fno-backtrace' disables the backtrace
     generation.  This option only has influence for compilation of the
     Fortran main program.

   *Note Options for Debugging Your Program or GCC: (gcc)Debugging
Options, for more information on debugging options.


File: gfortran.info,  Node: Directory Options,  Next: Link Options,  Prev: Debugging Options,  Up: Invoking GNU Fortran

2.6 Options for directory search
================================

These options affect how GNU Fortran searches for files specified by the
'INCLUDE' directive and where it searches for previously compiled
modules.

   It also affects the search paths used by 'cpp' when used to
preprocess Fortran source.

'-IDIR'
     These affect interpretation of the 'INCLUDE' directive (as well as
     of the '#include' directive of the 'cpp' preprocessor).

     Also note that the general behavior of '-I' and 'INCLUDE' is pretty
     much the same as of '-I' with '#include' in the 'cpp' preprocessor,
     with regard to looking for 'header.gcc' files and other such
     things.

     This path is also used to search for '.mod' files when previously
     compiled modules are required by a 'USE' statement.

     *Note Options for Directory Search: (gcc)Directory Options, for
     information on the '-I' option.

'-JDIR'
     This option specifies where to put '.mod' files for compiled
     modules.  It is also added to the list of directories to searched
     by an 'USE' statement.

     The default is the current directory.

'-fintrinsic-modules-path DIR'
     This option specifies the location of pre-compiled intrinsic
     modules, if they are not in the default location expected by the
     compiler.


File: gfortran.info,  Node: Link Options,  Next: Runtime Options,  Prev: Directory Options,  Up: Invoking GNU Fortran

2.7 Influencing the linking step
================================

These options come into play when the compiler links object files into
an executable output file.  They are meaningless if the compiler is not
doing a link step.

'-static-libgfortran'
     On systems that provide 'libgfortran' as a shared and a static
     library, this option forces the use of the static version.  If no
     shared version of 'libgfortran' was built when the compiler was
     configured, this option has no effect.


File: gfortran.info,  Node: Runtime Options,  Next: Code Gen Options,  Prev: Link Options,  Up: Invoking GNU Fortran

2.8 Influencing runtime behavior
================================

These options affect the runtime behavior of programs compiled with GNU
Fortran.

'-fconvert=CONVERSION'
     Specify the representation of data for unformatted files.  Valid
     values for conversion are: 'native', the default; 'swap', swap
     between big- and little-endian; 'big-endian', use big-endian
     representation for unformatted files; 'little-endian', use
     little-endian representation for unformatted files.

     _This option has an effect only when used in the main program.  The
     'CONVERT' specifier and the GFORTRAN_CONVERT_UNIT environment
     variable override the default specified by '-fconvert'._

'-frecord-marker=LENGTH'
     Specify the length of record markers for unformatted files.  Valid
     values for LENGTH are 4 and 8.  Default is 4.  _This is different
     from previous versions of 'gfortran'_, which specified a default
     record marker length of 8 on most systems.  If you want to read or
     write files compatible with earlier versions of 'gfortran', use
     '-frecord-marker=8'.

'-fmax-subrecord-length=LENGTH'
     Specify the maximum length for a subrecord.  The maximum permitted
     value for length is 2147483639, which is also the default.  Only
     really useful for use by the gfortran testsuite.

'-fsign-zero'
     When enabled, floating point numbers of value zero with the sign
     bit set are written as negative number in formatted output and
     treated as negative in the 'SIGN' intrinsic.  '-fno-sign-zero' does
     not print the negative sign of zero values (or values rounded to
     zero for I/O) and regards zero as positive number in the 'SIGN'
     intrinsic for compatibility with Fortran 77.  The default is
     '-fsign-zero'.


File: gfortran.info,  Node: Code Gen Options,  Next: Interoperability Options,  Prev: Runtime Options,  Up: Invoking GNU Fortran

2.9 Options for code generation conventions
===========================================

These machine-independent options control the interface conventions used
in code generation.

   Most of them have both positive and negative forms; the negative form
of '-ffoo' would be '-fno-foo'.  In the table below, only one of the
forms is listed--the one which is not the default.  You can figure out
the other form by either removing 'no-' or adding it.

'-fno-automatic'
     Treat each program unit (except those marked as RECURSIVE) as if
     the 'SAVE' statement were specified for every local variable and
     array referenced in it.  Does not affect common blocks.  (Some
     Fortran compilers provide this option under the name '-static' or
     '-save'.)  The default, which is '-fautomatic', uses the stack for
     local variables smaller than the value given by
     '-fmax-stack-var-size'.  Use the option '-frecursive' to use no
     static memory.

     Local variables or arrays having an explicit 'SAVE' attribute are
     silently ignored unless the '-pedantic' option is added.

'-ff2c'
     Generate code designed to be compatible with code generated by
     'g77' and 'f2c'.

     The calling conventions used by 'g77' (originally implemented in
     'f2c') require functions that return type default 'REAL' to
     actually return the C type 'double', and functions that return type
     'COMPLEX' to return the values via an extra argument in the calling
     sequence that points to where to store the return value.  Under the
     default GNU calling conventions, such functions simply return their
     results as they would in GNU C--default 'REAL' functions return the
     C type 'float', and 'COMPLEX' functions return the GNU C type
     'complex'.  Additionally, this option implies the
     '-fsecond-underscore' option, unless '-fno-second-underscore' is
     explicitly requested.

     This does not affect the generation of code that interfaces with
     the 'libgfortran' library.

     _Caution:_ It is not a good idea to mix Fortran code compiled with
     '-ff2c' with code compiled with the default '-fno-f2c' calling
     conventions as, calling 'COMPLEX' or default 'REAL' functions
     between program parts which were compiled with different calling
     conventions will break at execution time.

     _Caution:_ This will break code which passes intrinsic functions of
     type default 'REAL' or 'COMPLEX' as actual arguments, as the
     library implementations use the '-fno-f2c' calling conventions.

'-fno-underscoring'
     Do not transform names of entities specified in the Fortran source
     file by appending underscores to them.

     With '-funderscoring' in effect, GNU Fortran appends one underscore
     to external names with no underscores.  This is done to ensure
     compatibility with code produced by many UNIX Fortran compilers.

     _Caution_: The default behavior of GNU Fortran is incompatible with
     'f2c' and 'g77', please use the '-ff2c' option if you want object
     files compiled with GNU Fortran to be compatible with object code
     created with these tools.

     Use of '-fno-underscoring' is not recommended unless you are
     experimenting with issues such as integration of GNU Fortran into
     existing system environments (vis-a`-vis existing libraries, tools,
     and so on).

     For example, with '-funderscoring', and assuming that 'j()' and
     'max_count()' are external functions while 'my_var' and 'lvar' are
     local variables, a statement like
          I = J() + MAX_COUNT (MY_VAR, LVAR)
     is implemented as something akin to:
          i = j_() + max_count__(&my_var__, &lvar);

     With '-fno-underscoring', the same statement is implemented as:

          i = j() + max_count(&my_var, &lvar);

     Use of '-fno-underscoring' allows direct specification of
     user-defined names while debugging and when interfacing GNU Fortran
     code with other languages.

     Note that just because the names match does _not_ mean that the
     interface implemented by GNU Fortran for an external name matches
     the interface implemented by some other language for that same
     name.  That is, getting code produced by GNU Fortran to link to
     code produced by some other compiler using this or any other method
     can be only a small part of the overall solution--getting the code
     generated by both compilers to agree on issues other than naming
     can require significant effort, and, unlike naming disagreements,
     linkers normally cannot detect disagreements in these other areas.

     Also, note that with '-fno-underscoring', the lack of appended
     underscores introduces the very real possibility that a
     user-defined external name will conflict with a name in a system
     library, which could make finding unresolved-reference bugs quite
     difficult in some cases--they might occur at program run time, and
     show up only as buggy behavior at run time.

     In future versions of GNU Fortran we hope to improve naming and
     linking issues so that debugging always involves using the names as
     they appear in the source, even if the names as seen by the linker
     are mangled to prevent accidental linking between procedures with
     incompatible interfaces.

'-fsecond-underscore'
     By default, GNU Fortran appends an underscore to external names.
     If this option is used GNU Fortran appends two underscores to names
     with underscores and one underscore to external names with no
     underscores.  GNU Fortran also appends two underscores to internal
     names with underscores to avoid naming collisions with external
     names.

     This option has no effect if '-fno-underscoring' is in effect.  It
     is implied by the '-ff2c' option.

     Otherwise, with this option, an external name such as 'MAX_COUNT'
     is implemented as a reference to the link-time external symbol
     'max_count__', instead of 'max_count_'.  This is required for
     compatibility with 'g77' and 'f2c', and is implied by use of the
     '-ff2c' option.

'-fcoarray=<KEYWORD>'

     'none'
          Disable coarray support; using coarray declarations and
          image-control statements will produce a compile-time error.
          (Default)

     'single'
          Single-image mode, i.e.  'num_images()' is always one.

     'lib'
          Library-based coarray parallelization; a suitable GNU Fortran
          coarray library needs to be linked.

'-fcheck=<KEYWORD>'

     Enable the generation of run-time checks; the argument shall be a
     comma-delimited list of the following keywords.  Prefixing a check
     with 'no-' disables it if it was activated by a previous
     specification.

     'all'
          Enable all run-time test of '-fcheck'.

     'array-temps'
          Warns at run time when for passing an actual argument a
          temporary array had to be generated.  The information
          generated by this warning is sometimes useful in optimization,
          in order to avoid such temporaries.

          Note: The warning is only printed once per location.

     'bounds'
          Enable generation of run-time checks for array subscripts and
          against the declared minimum and maximum values.  It also
          checks array indices for assumed and deferred shape arrays
          against the actual allocated bounds and ensures that all
          string lengths are equal for character array constructors
          without an explicit typespec.

          Some checks require that '-fcheck=bounds' is set for the
          compilation of the main program.

          Note: In the future this may also include other forms of
          checking, e.g., checking substring references.

     'do'
          Enable generation of run-time checks for invalid modification
          of loop iteration variables.

     'mem'
          Enable generation of run-time checks for memory allocation.
          Note: This option does not affect explicit allocations using
          the 'ALLOCATE' statement, which will be always checked.

     'pointer'
          Enable generation of run-time checks for pointers and
          allocatables.

     'recursion'
          Enable generation of run-time checks for recursively called
          subroutines and functions which are not marked as recursive.
          See also '-frecursive'.  Note: This check does not work for
          OpenMP programs and is disabled if used together with
          '-frecursive' and '-fopenmp'.

     Example: Assuming you have a file 'foo.f90', the command
            gfortran -fcheck=all,no-array-temps foo.f90
     will compile the file with all checks enabled as specified above
     except warnings for generated array temporaries.

'-fbounds-check'
     Deprecated alias for '-fcheck=bounds'.

'-ftail-call-workaround'
'-ftail-call-workaround=N'
     Some C interfaces to Fortran codes violate the gfortran ABI by
     omitting the hidden character length arguments as described in
     *Note Argument passing conventions::.  This can lead to crashes
     because pushing arguments for tail calls can overflow the stack.

     To provide a workaround for existing binary packages, this option
     disables tail call optimization for gfortran procedures with
     character arguments.  With '-ftail-call-workaround=2' tail call
     optimization is disabled in all gfortran procedures with character
     arguments, with '-ftail-call-workaround=1' or equivalent
     '-ftail-call-workaround' only in gfortran procedures with character
     arguments that call implicitly prototyped procedures.

     Using this option can lead to problems including crashes due to
     insufficient stack space.

     It is _very strongly_ recommended to fix the code in question.  The
     '-fc-prototypes-external' option can be used to generate prototypes
     which conform to gfortran's ABI, for inclusion in the source code.

     Support for this option will likely be withdrawn in a future
     release of gfortran.

     The negative form, '-fno-tail-call-workaround' or equivalent
     '-ftail-call-workaround=0', can be used to disable this option.

     Default is currently '-ftail-call-workaround', this will change in
     future releases.

'-fcheck-array-temporaries'
     Deprecated alias for '-fcheck=array-temps'.

'-fmax-array-constructor=N'
     This option can be used to increase the upper limit permitted in
     array constructors.  The code below requires this option to expand
     the array at compile time.

          program test
          implicit none
          integer j
          integer, parameter :: n = 100000
          integer, parameter :: i(n) = (/ (2*j, j = 1, n) /)
          print '(10(I0,1X))', i
          end program test

     _Caution: This option can lead to long compile times and
     excessively large object files._

     The default value for N is 65535.

'-fmax-stack-var-size=N'
     This option specifies the size in bytes of the largest array that
     will be put on the stack; if the size is exceeded static memory is
     used (except in procedures marked as RECURSIVE). Use the option
     '-frecursive' to allow for recursive procedures which do not have a
     RECURSIVE attribute or for parallel programs.  Use '-fno-automatic'
     to never use the stack.

     This option currently only affects local arrays declared with
     constant bounds, and may not apply to all character variables.
     Future versions of GNU Fortran may improve this behavior.

     The default value for N is 32768.

'-fstack-arrays'
     Adding this option will make the Fortran compiler put all arrays of
     unknown size and array temporaries onto stack memory.  If your
     program uses very large local arrays it is possible that you will
     have to extend your runtime limits for stack memory on some
     operating systems.  This flag is enabled by default at optimization
     level '-Ofast' unless '-fmax-stack-var-size' is specified.

'-fpack-derived'
     This option tells GNU Fortran to pack derived type members as
     closely as possible.  Code compiled with this option is likely to
     be incompatible with code compiled without this option, and may
     execute slower.

'-frepack-arrays'
     In some circumstances GNU Fortran may pass assumed shape array
     sections via a descriptor describing a noncontiguous area of
     memory.  This option adds code to the function prologue to repack
     the data into a contiguous block at runtime.

     This should result in faster accesses to the array.  However it can
     introduce significant overhead to the function call, especially
     when the passed data is noncontiguous.

'-fshort-enums'
     This option is provided for interoperability with C code that was
     compiled with the '-fshort-enums' option.  It will make GNU Fortran
     choose the smallest 'INTEGER' kind a given enumerator set will fit
     in, and give all its enumerators this kind.

'-fexternal-blas'
     This option will make 'gfortran' generate calls to BLAS functions
     for some matrix operations like 'MATMUL', instead of using our own
     algorithms, if the size of the matrices involved is larger than a
     given limit (see '-fblas-matmul-limit').  This may be profitable if
     an optimized vendor BLAS library is available.  The BLAS library
     will have to be specified at link time.

'-fblas-matmul-limit=N'
     Only significant when '-fexternal-blas' is in effect.  Matrix
     multiplication of matrices with size larger than (or equal to) N
     will be performed by calls to BLAS functions, while others will be
     handled by 'gfortran' internal algorithms.  If the matrices
     involved are not square, the size comparison is performed using the
     geometric mean of the dimensions of the argument and result
     matrices.

     The default value for N is 30.

'-finline-matmul-limit=N'
     When front-end optimiztion is active, some calls to the 'MATMUL'
     intrinsic function will be inlined.  This may result in code size
     increase if the size of the matrix cannot be determined at compile
     time, as code for both cases is generated.  Setting
     '-finline-matmul-limit=0' will disable inlining in all cases.
     Setting this option with a value of N will produce inline code for
     matrices with size up to N.  If the matrices involved are not
     square, the size comparison is performed using the geometric mean
     of the dimensions of the argument and result matrices.

     The default value for N is 30.  The '-fblas-matmul-limit' can be
     used to change this value.

'-frecursive'
     Allow indirect recursion by forcing all local arrays to be
     allocated on the stack.  This flag cannot be used together with
     '-fmax-stack-var-size=' or '-fno-automatic'.

'-finit-local-zero'
'-finit-derived'
'-finit-integer=N'
'-finit-real=<ZERO|INF|-INF|NAN|SNAN>'
'-finit-logical=<TRUE|FALSE>'
'-finit-character=N'
     The '-finit-local-zero' option instructs the compiler to initialize
     local 'INTEGER', 'REAL', and 'COMPLEX' variables to zero, 'LOGICAL'
     variables to false, and 'CHARACTER' variables to a string of null
     bytes.  Finer-grained initialization options are provided by the
     '-finit-integer=N', '-finit-real=<ZERO|INF|-INF|NAN|SNAN>' (which
     also initializes the real and imaginary parts of local 'COMPLEX'
     variables), '-finit-logical=<TRUE|FALSE>', and '-finit-character=N'
     (where N is an ASCII character value) options.

     With '-finit-derived', components of derived type variables will be
     initialized according to these flags.  Components whose type is not
     covered by an explicit '-finit-*' flag will be treated as described
     above with '-finit-local-zero'.

     These options do not initialize
        * objects with the POINTER attribute
        * allocatable arrays
        * variables that appear in an 'EQUIVALENCE' statement.
     (These limitations may be removed in future releases).

     Note that the '-finit-real=nan' option initializes 'REAL' and
     'COMPLEX' variables with a quiet NaN. For a signalling NaN use
     '-finit-real=snan'; note, however, that compile-time optimizations
     may convert them into quiet NaN and that trapping needs to be
     enabled (e.g.  via '-ffpe-trap').

     The '-finit-integer' option will parse the value into an integer of
     type 'INTEGER(kind=C_LONG)' on the host.  Said value is then
     assigned to the integer variables in the Fortran code, which might
     result in wraparound if the value is too large for the kind.

     Finally, note that enabling any of the '-finit-*' options will
     silence warnings that would have been emitted by '-Wuninitialized'
     for the affected local variables.

'-falign-commons'
     By default, 'gfortran' enforces proper alignment of all variables
     in a 'COMMON' block by padding them as needed.  On certain
     platforms this is mandatory, on others it increases performance.
     If a 'COMMON' block is not declared with consistent data types
     everywhere, this padding can cause trouble, and
     '-fno-align-commons' can be used to disable automatic alignment.
     The same form of this option should be used for all files that
     share a 'COMMON' block.  To avoid potential alignment issues in
     'COMMON' blocks, it is recommended to order objects from largest to
     smallest.

'-fno-protect-parens'
     By default the parentheses in expression are honored for all
     optimization levels such that the compiler does not do any
     re-association.  Using '-fno-protect-parens' allows the compiler to
     reorder 'REAL' and 'COMPLEX' expressions to produce faster code.
     Note that for the re-association optimization '-fno-signed-zeros'
     and '-fno-trapping-math' need to be in effect.  The parentheses
     protection is enabled by default, unless '-Ofast' is given.

'-frealloc-lhs'
     An allocatable left-hand side of an intrinsic assignment is
     automatically (re)allocated if it is either unallocated or has a
     different shape.  The option is enabled by default except when
     '-std=f95' is given.  See also '-Wrealloc-lhs'.

'-faggressive-function-elimination'
     Functions with identical argument lists are eliminated within
     statements, regardless of whether these functions are marked 'PURE'
     or not.  For example, in
            a = f(b,c) + f(b,c)
     there will only be a single call to 'f'.  This option only works if
     '-ffrontend-optimize' is in effect.

'-ffrontend-optimize'
     This option performs front-end optimization, based on manipulating
     parts the Fortran parse tree.  Enabled by default by any '-O'
     option except '-O0' and '-Og'.  Optimizations enabled by this
     option include:
        * inlining calls to 'MATMUL',
        * elimination of identical function calls within expressions,
        * removing unnecessary calls to 'TRIM' in comparisons and
          assignments,
        * replacing 'TRIM(a)' with 'a(1:LEN_TRIM(a))' and
        * short-circuiting of logical operators ('.AND.' and '.OR.').
     It can be deselected by specifying '-fno-frontend-optimize'.

'-ffrontend-loop-interchange'
     Attempt to interchange loops in the Fortran front end where
     profitable.  Enabled by default by any '-O' option.  At the moment,
     this option only affects 'FORALL' and 'DO CONCURRENT' statements
     with several forall triplets.

   *Note Options for Code Generation Conventions: (gcc)Code Gen Options,
for information on more options offered by the GBE shared by 'gfortran',
'gcc', and other GNU compilers.


File: gfortran.info,  Node: Interoperability Options,  Next: Environment Variables,  Prev: Code Gen Options,  Up: Invoking GNU Fortran

2.10 Options for interoperability with other languages
======================================================

-fc-prototypes
     This option will generate C prototypes from 'BIND(C)' variable
     declarations, types and procedure interfaces and writes them to
     standard output.  'ENUM' is not yet supported.

     The generated prototypes may need inclusion of an appropriate
     header, such as '<stdint.h>' or '<stdlib.h>'.  For types which are
     not specified using the appropriate kind from the 'iso_c_binding'
     module, a warning is added as a comment to the code.

     For function pointers, a pointer to a function returning 'int'
     without an explicit argument list is generated.

     Example of use:
          $ gfortran -fc-prototypes -fsyntax-only foo.f90 > foo.h
     where the C code intended for interoperating with the Fortran code
     then uses '#include "foo.h"'.

-fc-prototypes-external
     This option will generate C prototypes from external functions and
     subroutines and write them to standard output.  This may be useful
     for making sure that C bindings to Fortran code are correct.  This
     option does not generate prototypes for 'BIND(C)' procedures, use
     '-fc-prototypes' for that.

     The generated prototypes may need inclusion of an appropriate
     header, such as as '<stdint.h>' or '<stdlib.h>'.

     This is primarily meant for legacy code to ensure that existing C
     bindings match what 'gfortran' emits.  The generated C prototypes
     should be correct for the current version of the compiler, but may
     not match what other compilers or earlier versions of 'gfortran'
     need.  For new developments, use of the 'BIND(C)' features is
     recommended.

     Example of use:
          $ gfortran -fc-prototypes-external -fsyntax-only foo.f > foo.h
     where the C code intended for interoperating with the Fortran code
     then uses '#include "foo.h"'.


File: gfortran.info,  Node: Environment Variables,  Prev: Interoperability Options,  Up: Invoking GNU Fortran

2.11 Environment variables affecting 'gfortran'
===============================================

The 'gfortran' compiler currently does not make use of any environment
variables to control its operation above and beyond those that affect
the operation of 'gcc'.

   *Note Environment Variables Affecting GCC: (gcc)Environment
Variables, for information on environment variables.

   *Note Runtime::, for environment variables that affect the run-time
behavior of programs compiled with GNU Fortran.


File: gfortran.info,  Node: Runtime,  Next: Fortran standards status,  Prev: Invoking GNU Fortran,  Up: Top

3 Runtime: Influencing runtime behavior with environment variables
******************************************************************

The behavior of the 'gfortran' can be influenced by environment
variables.

   Malformed environment variables are silently ignored.

* Menu:

* TMPDIR:: Directory for scratch files
* GFORTRAN_STDIN_UNIT:: Unit number for standard input
* GFORTRAN_STDOUT_UNIT:: Unit number for standard output
* GFORTRAN_STDERR_UNIT:: Unit number for standard error
* GFORTRAN_UNBUFFERED_ALL:: Do not buffer I/O for all units.
* GFORTRAN_UNBUFFERED_PRECONNECTED:: Do not buffer I/O for preconnected units.
* GFORTRAN_SHOW_LOCUS::  Show location for runtime errors
* GFORTRAN_OPTIONAL_PLUS:: Print leading + where permitted
* GFORTRAN_LIST_SEPARATOR::  Separator for list output
* GFORTRAN_CONVERT_UNIT::  Set endianness for unformatted I/O
* GFORTRAN_ERROR_BACKTRACE:: Show backtrace on run-time errors
* GFORTRAN_FORMATTED_BUFFER_SIZE:: Buffer size for formatted files.
* GFORTRAN_UNFORMATTED_BUFFER_SIZE:: Buffer size for unformatted files.


File: gfortran.info,  Node: TMPDIR,  Next: GFORTRAN_STDIN_UNIT,  Up: Runtime

3.1 'TMPDIR'--Directory for scratch files
=========================================

When opening a file with 'STATUS='SCRATCH'', GNU Fortran tries to create
the file in one of the potential directories by testing each directory
in the order below.

  1. The environment variable 'TMPDIR', if it exists.

  2. On the MinGW target, the directory returned by the 'GetTempPath'
     function.  Alternatively, on the Cygwin target, the 'TMP' and
     'TEMP' environment variables, if they exist, in that order.

  3. The 'P_tmpdir' macro if it is defined, otherwise the directory
     '/tmp'.


File: gfortran.info,  Node: GFORTRAN_STDIN_UNIT,  Next: GFORTRAN_STDOUT_UNIT,  Prev: TMPDIR,  Up: Runtime

3.2 'GFORTRAN_STDIN_UNIT'--Unit number for standard input
=========================================================

This environment variable can be used to select the unit number
preconnected to standard input.  This must be a positive integer.  The
default value is 5.


File: gfortran.info,  Node: GFORTRAN_STDOUT_UNIT,  Next: GFORTRAN_STDERR_UNIT,  Prev: GFORTRAN_STDIN_UNIT,  Up: Runtime

3.3 'GFORTRAN_STDOUT_UNIT'--Unit number for standard output
===========================================================

This environment variable can be used to select the unit number
preconnected to standard output.  This must be a positive integer.  The
default value is 6.


File: gfortran.info,  Node: GFORTRAN_STDERR_UNIT,  Next: GFORTRAN_UNBUFFERED_ALL,  Prev: GFORTRAN_STDOUT_UNIT,  Up: Runtime

3.4 'GFORTRAN_STDERR_UNIT'--Unit number for standard error
==========================================================

This environment variable can be used to select the unit number
preconnected to standard error.  This must be a positive integer.  The
default value is 0.


File: gfortran.info,  Node: GFORTRAN_UNBUFFERED_ALL,  Next: GFORTRAN_UNBUFFERED_PRECONNECTED,  Prev: GFORTRAN_STDERR_UNIT,  Up: Runtime

3.5 'GFORTRAN_UNBUFFERED_ALL'--Do not buffer I/O on all units
=============================================================

This environment variable controls whether all I/O is unbuffered.  If
the first letter is 'y', 'Y' or '1', all I/O is unbuffered.  This will
slow down small sequential reads and writes.  If the first letter is
'n', 'N' or '0', I/O is buffered.  This is the default.


File: gfortran.info,  Node: GFORTRAN_UNBUFFERED_PRECONNECTED,  Next: GFORTRAN_SHOW_LOCUS,  Prev: GFORTRAN_UNBUFFERED_ALL,  Up: Runtime

3.6 'GFORTRAN_UNBUFFERED_PRECONNECTED'--Do not buffer I/O on preconnected units
===============================================================================

The environment variable named 'GFORTRAN_UNBUFFERED_PRECONNECTED'
controls whether I/O on a preconnected unit (i.e. STDOUT or STDERR) is
unbuffered.  If the first letter is 'y', 'Y' or '1', I/O is unbuffered.
This will slow down small sequential reads and writes.  If the first
letter is 'n', 'N' or '0', I/O is buffered.  This is the default.


File: gfortran.info,  Node: GFORTRAN_SHOW_LOCUS,  Next: GFORTRAN_OPTIONAL_PLUS,  Prev: GFORTRAN_UNBUFFERED_PRECONNECTED,  Up: Runtime

3.7 'GFORTRAN_SHOW_LOCUS'--Show location for runtime errors
===========================================================

If the first letter is 'y', 'Y' or '1', filename and line numbers for
runtime errors are printed.  If the first letter is 'n', 'N' or '0', do
not print filename and line numbers for runtime errors.  The default is
to print the location.


File: gfortran.info,  Node: GFORTRAN_OPTIONAL_PLUS,  Next: GFORTRAN_LIST_SEPARATOR,  Prev: GFORTRAN_SHOW_LOCUS,  Up: Runtime

3.8 'GFORTRAN_OPTIONAL_PLUS'--Print leading + where permitted
=============================================================

If the first letter is 'y', 'Y' or '1', a plus sign is printed where
permitted by the Fortran standard.  If the first letter is 'n', 'N' or
'0', a plus sign is not printed in most cases.  Default is not to print
plus signs.


File: gfortran.info,  Node: GFORTRAN_LIST_SEPARATOR,  Next: GFORTRAN_CONVERT_UNIT,  Prev: GFORTRAN_OPTIONAL_PLUS,  Up: Runtime

3.9 'GFORTRAN_LIST_SEPARATOR'--Separator for list output
========================================================

This environment variable specifies the separator when writing
list-directed output.  It may contain any number of spaces and at most
one comma.  If you specify this on the command line, be sure to quote
spaces, as in
     $ GFORTRAN_LIST_SEPARATOR='  ,  ' ./a.out
   when 'a.out' is the compiled Fortran program that you want to run.
Default is a single space.


File: gfortran.info,  Node: GFORTRAN_CONVERT_UNIT,  Next: GFORTRAN_ERROR_BACKTRACE,  Prev: GFORTRAN_LIST_SEPARATOR,  Up: Runtime

3.10 'GFORTRAN_CONVERT_UNIT'--Set endianness for unformatted I/O
================================================================

By setting the 'GFORTRAN_CONVERT_UNIT' variable, it is possible to
change the representation of data for unformatted files.  The syntax for
the 'GFORTRAN_CONVERT_UNIT' variable is:
     GFORTRAN_CONVERT_UNIT: mode | mode ';' exception | exception ;
     mode: 'native' | 'swap' | 'big_endian' | 'little_endian' ;
     exception: mode ':' unit_list | unit_list ;
     unit_list: unit_spec | unit_list unit_spec ;
     unit_spec: INTEGER | INTEGER '-' INTEGER ;
   The variable consists of an optional default mode, followed by a list
of optional exceptions, which are separated by semicolons from the
preceding default and each other.  Each exception consists of a format
and a comma-separated list of units.  Valid values for the modes are the
same as for the 'CONVERT' specifier:

     'NATIVE' Use the native format.  This is the default.
     'SWAP' Swap between little- and big-endian.
     'LITTLE_ENDIAN' Use the little-endian format for unformatted files.
     'BIG_ENDIAN' Use the big-endian format for unformatted files.
   A missing mode for an exception is taken to mean 'BIG_ENDIAN'.
Examples of values for 'GFORTRAN_CONVERT_UNIT' are:
     ''big_endian'' Do all unformatted I/O in big_endian mode.
     ''little_endian;native:10-20,25'' Do all unformatted I/O in
     little_endian mode, except for units 10 to 20 and 25, which are in
     native format.
     ''10-20'' Units 10 to 20 are big-endian, the rest is native.

   Setting the environment variables should be done on the command line
or via the 'export' command for 'sh'-compatible shells and via 'setenv'
for 'csh'-compatible shells.

   Example for 'sh':
     $ gfortran foo.f90
     $ GFORTRAN_CONVERT_UNIT='big_endian;native:10-20' ./a.out

   Example code for 'csh':
     % gfortran foo.f90
     % setenv GFORTRAN_CONVERT_UNIT 'big_endian;native:10-20'
     % ./a.out

   Using anything but the native representation for unformatted data
carries a significant speed overhead.  If speed in this area matters to
you, it is best if you use this only for data that needs to be portable.

   *Note CONVERT specifier::, for an alternative way to specify the data
representation for unformatted files.  *Note Runtime Options::, for
setting a default data representation for the whole program.  The
'CONVERT' specifier overrides the '-fconvert' compile options.

   _Note that the values specified via the GFORTRAN_CONVERT_UNIT
environment variable will override the CONVERT specifier in the open
statement_.  This is to give control over data formats to users who do
not have the source code of their program available.


File: gfortran.info,  Node: GFORTRAN_ERROR_BACKTRACE,  Next: GFORTRAN_FORMATTED_BUFFER_SIZE,  Prev: GFORTRAN_CONVERT_UNIT,  Up: Runtime

3.11 'GFORTRAN_ERROR_BACKTRACE'--Show backtrace on run-time errors
==================================================================

If the 'GFORTRAN_ERROR_BACKTRACE' variable is set to 'y', 'Y' or '1'
(only the first letter is relevant) then a backtrace is printed when a
serious run-time error occurs.  To disable the backtracing, set the
variable to 'n', 'N', '0'.  Default is to print a backtrace unless the
'-fno-backtrace' compile option was used.


File: gfortran.info,  Node: GFORTRAN_FORMATTED_BUFFER_SIZE,  Next: GFORTRAN_UNFORMATTED_BUFFER_SIZE,  Prev: GFORTRAN_ERROR_BACKTRACE,  Up: Runtime

3.12 'GFORTRAN_FORMATTED_BUFFER_SIZE'--Set buffer size for formatted I/O
========================================================================

The 'GFORTRAN_FORMATTED_BUFFER_SIZE' environment variable specifies
buffer size in bytes to be used for formatted output.  The default value
is 8192.


File: gfortran.info,  Node: GFORTRAN_UNFORMATTED_BUFFER_SIZE,  Prev: GFORTRAN_FORMATTED_BUFFER_SIZE,  Up: Runtime

3.13 'GFORTRAN_UNFORMATTED_BUFFER_SIZE'--Set buffer size for unformatted I/O
============================================================================

The 'GFORTRAN_UNFORMATTED_BUFFER_SIZE' environment variable specifies
buffer size in bytes to be used for unformatted output.  The default
value is 131072.


File: gfortran.info,  Node: Fortran standards status,  Next: Compiler Characteristics,  Prev: Runtime,  Up: Top

4 Fortran standards status
**************************

* Menu:

* Fortran 2003 status::
* Fortran 2008 status::
* Fortran 2018 status::


File: gfortran.info,  Node: Fortran 2003 status,  Next: Fortran 2008 status,  Up: Fortran standards status

4.1 Fortran 2003 status
=======================

GNU Fortran supports several Fortran 2003 features; an incomplete list
can be found below.  See also the wiki page
(https://gcc.gnu.org/wiki/Fortran2003) about Fortran 2003.

   * Procedure pointers including procedure-pointer components with
     'PASS' attribute.

   * Procedures which are bound to a derived type (type-bound
     procedures) including 'PASS', 'PROCEDURE' and 'GENERIC', and
     operators bound to a type.

   * Abstract interfaces and type extension with the possibility to
     override type-bound procedures or to have deferred binding.

   * Polymorphic entities ("'CLASS'") for derived types and unlimited
     polymorphism ("'CLASS(*)'") - including 'SAME_TYPE_AS',
     'EXTENDS_TYPE_OF' and 'SELECT TYPE' for scalars and arrays and
     finalization.

   * Generic interface names, which have the same name as derived types,
     are now supported.  This allows one to write constructor functions.
     Note that Fortran does not support static constructor functions.
     For static variables, only default initialization or
     structure-constructor initialization are available.

   * The 'ASSOCIATE' construct.

   * Interoperability with C including enumerations,

   * In structure constructors the components with default values may be
     omitted.

   * Extensions to the 'ALLOCATE' statement, allowing for a
     type-specification with type parameter and for allocation and
     initialization from a 'SOURCE=' expression; 'ALLOCATE' and
     'DEALLOCATE' optionally return an error message string via
     'ERRMSG='.

   * Reallocation on assignment: If an intrinsic assignment is used, an
     allocatable variable on the left-hand side is automatically
     allocated (if unallocated) or reallocated (if the shape is
     different).  Currently, scalar deferred character length left-hand
     sides are correctly handled but arrays are not yet fully
     implemented.

   * Deferred-length character variables and scalar deferred-length
     character components of derived types are supported.  (Note that
     array-valued compoents are not yet implemented.)

   * Transferring of allocations via 'MOVE_ALLOC'.

   * The 'PRIVATE' and 'PUBLIC' attributes may be given individually to
     derived-type components.

   * In pointer assignments, the lower bound may be specified and the
     remapping of elements is supported.

   * For pointers an 'INTENT' may be specified which affect the
     association status not the value of the pointer target.

   * Intrinsics 'command_argument_count', 'get_command',
     'get_command_argument', and 'get_environment_variable'.

   * Support for Unicode characters (ISO 10646) and UTF-8, including the
     'SELECTED_CHAR_KIND' and 'NEW_LINE' intrinsic functions.

   * Support for binary, octal and hexadecimal (BOZ) constants in the
     intrinsic functions 'INT', 'REAL', 'CMPLX' and 'DBLE'.

   * Support for namelist variables with allocatable and pointer
     attribute and nonconstant length type parameter.

   * Array constructors using square brackets.  That is, '[...]' rather
     than '(/.../)'.  Type-specification for array constructors like '(/
     some-type :: ... /)'.

   * Extensions to the specification and initialization expressions,
     including the support for intrinsics with real and complex
     arguments.

   * Support for the asynchronous input/output.

   * 'FLUSH' statement.

   * 'IOMSG=' specifier for I/O statements.

   * Support for the declaration of enumeration constants via the 'ENUM'
     and 'ENUMERATOR' statements.  Interoperability with 'gcc' is
     guaranteed also for the case where the '-fshort-enums' command line
     option is given.

   * TR 15581:
        * 'ALLOCATABLE' dummy arguments.
        * 'ALLOCATABLE' function results
        * 'ALLOCATABLE' components of derived types

   * The 'OPEN' statement supports the 'ACCESS='STREAM'' specifier,
     allowing I/O without any record structure.

   * Namelist input/output for internal files.

   * Minor I/O features: Rounding during formatted output, using of a
     decimal comma instead of a decimal point, setting whether a plus
     sign should appear for positive numbers.  On systems where 'strtod'
     honours the rounding mode, the rounding mode is also supported for
     input.

   * The 'PROTECTED' statement and attribute.

   * The 'VALUE' statement and attribute.

   * The 'VOLATILE' statement and attribute.

   * The 'IMPORT' statement, allowing to import host-associated derived
     types.

   * The intrinsic modules 'ISO_FORTRAN_ENVIRONMENT' is supported, which
     contains parameters of the I/O units, storage sizes.  Additionally,
     procedures for C interoperability are available in the
     'ISO_C_BINDING' module.

   * 'USE' statement with 'INTRINSIC' and 'NON_INTRINSIC' attribute;
     supported intrinsic modules: 'ISO_FORTRAN_ENV', 'ISO_C_BINDING',
     'OMP_LIB' and 'OMP_LIB_KINDS', and 'OPENACC'.

   * Renaming of operators in the 'USE' statement.


File: gfortran.info,  Node: Fortran 2008 status,  Next: Fortran 2018 status,  Prev: Fortran 2003 status,  Up: Fortran standards status

4.2 Fortran 2008 status
=======================

The latest version of the Fortran standard is ISO/IEC 1539-1:2010,
informally known as Fortran 2008.  The official version is available
from International Organization for Standardization (ISO) or its
national member organizations.  The the final draft (FDIS) can be
downloaded free of charge from
<http://www.nag.co.uk/sc22wg5/links.html>.  Fortran is developed by the
Working Group 5 of Sub-Committee 22 of the Joint Technical Committee 1
of the International Organization for Standardization and the
International Electrotechnical Commission (IEC). This group is known as
WG5 (http://www.nag.co.uk/sc22wg5/).

   The GNU Fortran compiler supports several of the new features of
Fortran 2008; the wiki (https://gcc.gnu.org/wiki/Fortran2008Status) has
some information about the current Fortran 2008 implementation status.
In particular, the following is implemented.

   * The '-std=f2008' option and support for the file extensions '.f08'
     and '.F08'.

   * The 'OPEN' statement now supports the 'NEWUNIT=' option, which
     returns a unique file unit, thus preventing inadvertent use of the
     same unit in different parts of the program.

   * The 'g0' format descriptor and unlimited format items.

   * The mathematical intrinsics 'ASINH', 'ACOSH', 'ATANH', 'ERF',
     'ERFC', 'GAMMA', 'LOG_GAMMA', 'BESSEL_J0', 'BESSEL_J1',
     'BESSEL_JN', 'BESSEL_Y0', 'BESSEL_Y1', 'BESSEL_YN', 'HYPOT',
     'NORM2', and 'ERFC_SCALED'.

   * Using complex arguments with 'TAN', 'SINH', 'COSH', 'TANH', 'ASIN',
     'ACOS', and 'ATAN' is now possible; 'ATAN'(Y,X) is now an alias for
     'ATAN2'(Y,X).

   * Support of the 'PARITY' intrinsic functions.

   * The following bit intrinsics: 'LEADZ' and 'TRAILZ' for counting the
     number of leading and trailing zero bits, 'POPCNT' and 'POPPAR' for
     counting the number of one bits and returning the parity; 'BGE',
     'BGT', 'BLE', and 'BLT' for bitwise comparisons; 'DSHIFTL' and
     'DSHIFTR' for combined left and right shifts, 'MASKL' and 'MASKR'
     for simple left and right justified masks, 'MERGE_BITS' for a
     bitwise merge using a mask, 'SHIFTA', 'SHIFTL' and 'SHIFTR' for
     shift operations, and the transformational bit intrinsics 'IALL',
     'IANY' and 'IPARITY'.

   * Support of the 'EXECUTE_COMMAND_LINE' intrinsic subroutine.

   * Support for the 'STORAGE_SIZE' intrinsic inquiry function.

   * The 'INT{8,16,32}' and 'REAL{32,64,128}' kind type parameters and
     the array-valued named constants 'INTEGER_KINDS', 'LOGICAL_KINDS',
     'REAL_KINDS' and 'CHARACTER_KINDS' of the intrinsic module
     'ISO_FORTRAN_ENV'.

   * The module procedures 'C_SIZEOF' of the intrinsic module
     'ISO_C_BINDINGS' and 'COMPILER_VERSION' and 'COMPILER_OPTIONS' of
     'ISO_FORTRAN_ENV'.

   * Coarray support for serial programs with '-fcoarray=single' flag
     and experimental support for multiple images with the
     '-fcoarray=lib' flag.

   * Submodules are supported.  It should noted that 'MODULEs' do not
     produce the smod file needed by the descendent 'SUBMODULEs' unless
     they contain at least one 'MODULE PROCEDURE' interface.  The reason
     for this is that 'SUBMODULEs' are useless without 'MODULE
     PROCEDUREs'.  See http://j3-fortran.org/doc/meeting/207/15-209.txt
     for a discussion and a draft interpretation.  Adopting this
     interpretation has the advantage that code that does not use
     submodules does not generate smod files.

   * The 'DO CONCURRENT' construct is supported.

   * The 'BLOCK' construct is supported.

   * The 'STOP' and the new 'ERROR STOP' statements now support all
     constant expressions.  Both show the signals which were signaling
     at termination.

   * Support for the 'CONTIGUOUS' attribute.

   * Support for 'ALLOCATE' with 'MOLD'.

   * Support for the 'IMPURE' attribute for procedures, which allows for
     'ELEMENTAL' procedures without the restrictions of 'PURE'.

   * Null pointers (including 'NULL()') and not-allocated variables can
     be used as actual argument to optional non-pointer, non-allocatable
     dummy arguments, denoting an absent argument.

   * Non-pointer variables with 'TARGET' attribute can be used as actual
     argument to 'POINTER' dummies with 'INTENT(IN)'.

   * Pointers including procedure pointers and those in a derived type
     (pointer components) can now be initialized by a target instead of
     only by 'NULL'.

   * The 'EXIT' statement (with construct-name) can be now be used to
     leave not only the 'DO' but also the 'ASSOCIATE', 'BLOCK', 'IF',
     'SELECT CASE' and 'SELECT TYPE' constructs.

   * Internal procedures can now be used as actual argument.

   * Minor features: obsolesce diagnostics for 'ENTRY' with
     '-std=f2008'; a line may start with a semicolon; for internal and
     module procedures 'END' can be used instead of 'END SUBROUTINE' and
     'END FUNCTION'; 'SELECTED_REAL_KIND' now also takes a 'RADIX'
     argument; intrinsic types are supported for
     'TYPE'(INTRINSIC-TYPE-SPEC); multiple type-bound procedures can be
     declared in a single 'PROCEDURE' statement; implied-shape arrays
     are supported for named constants ('PARAMETER').


File: gfortran.info,  Node: Fortran 2018 status,  Prev: Fortran 2008 status,  Up: Fortran standards status

4.3 Status of Fortran 2018 support
==================================

   * ERROR STOP in a PURE procedure An 'ERROR STOP' statement is
     permitted in a 'PURE' procedure.

   * IMPLICIT NONE with a spec-list Support the 'IMPLICIT NONE'
     statement with an 'implicit-none-spec-list'.

   * Behavior of INQUIRE with the RECL= specifier

     The behavior of the 'INQUIRE' statement with the 'RECL=' specifier
     now conforms to Fortran 2018.

4.3.1 TS 29113 Status (Further Interoperability with C)
-------------------------------------------------------

GNU Fortran supports some of the new features of the Technical
Specification (TS) 29113 on Further Interoperability of Fortran with C.
The wiki (https://gcc.gnu.org/wiki/TS29113Status) has some information
about the current TS 29113 implementation status.  In particular, the
following is implemented.

   See also *note Further Interoperability of Fortran with C::.

   * The 'OPTIONAL' attribute is allowed for dummy arguments of 'BIND(C)
     procedures.'

   * The 'RANK' intrinsic is supported.

   * GNU Fortran's implementation for variables with 'ASYNCHRONOUS'
     attribute is compatible with TS 29113.

   * Assumed types ('TYPE(*)').

   * Assumed-rank ('DIMENSION(..)').

   * ISO_Fortran_binding (now in Fortran 2018 18.4) is implemented such
     that conversion of the array descriptor for assumed type or assumed
     rank arrays is done in the library.  The include file
     ISO_Fortran_binding.h is can be found in
     '~prefix/lib/gcc/$target/$version'.

4.3.2 TS 18508 Status (Additional Parallel Features)
----------------------------------------------------

GNU Fortran supports the following new features of the Technical
Specification 18508 on Additional Parallel Features in Fortran:

   * The new atomic ADD, CAS, FETCH and ADD/OR/XOR, OR and XOR
     intrinsics.

   * The 'CO_MIN' and 'CO_MAX' and 'SUM' reduction intrinsics.  And the
     'CO_BROADCAST' and 'CO_REDUCE' intrinsic, except that those do not
     support polymorphic types or types with allocatable, pointer or
     polymorphic components.

   * Events ('EVENT POST', 'EVENT WAIT', 'EVENT_QUERY')

   * Failed images ('FAIL IMAGE', 'IMAGE_STATUS', 'FAILED_IMAGES',
     'STOPPED_IMAGES')


File: gfortran.info,  Node: Compiler Characteristics,  Next: Extensions,  Prev: Fortran standards status,  Up: Top

5 Compiler Characteristics
**************************

This chapter describes certain characteristics of the GNU Fortran
compiler, that are not specified by the Fortran standard, but which
might in some way or another become visible to the programmer.

* Menu:

* KIND Type Parameters::
* Internal representation of LOGICAL variables::
* Evaluation of logical expressions::
* MAX and MIN intrinsics with REAL NaN arguments::
* Thread-safety of the runtime library::
* Data consistency and durability::
* Files opened without an explicit ACTION= specifier::
* File operations on symbolic links::
* File format of unformatted sequential files::
* Asynchronous I/O::


File: gfortran.info,  Node: KIND Type Parameters,  Next: Internal representation of LOGICAL variables,  Up: Compiler Characteristics

5.1 KIND Type Parameters
========================

The 'KIND' type parameters supported by GNU Fortran for the primitive
data types are:

'INTEGER'
     1, 2, 4, 8*, 16*, default: 4**

'LOGICAL'
     1, 2, 4, 8*, 16*, default: 4**

'REAL'
     4, 8, 10*, 16*, default: 4***

'COMPLEX'
     4, 8, 10*, 16*, default: 4***

'DOUBLE PRECISION'
     4, 8, 10*, 16*, default: 8***

'CHARACTER'
     1, 4, default: 1

* not available on all systems
** unless '-fdefault-integer-8' is used
*** unless '-fdefault-real-8' is used (see *note Fortran Dialect
Options::)

The 'KIND' value matches the storage size in bytes, except for 'COMPLEX'
where the storage size is twice as much (or both real and imaginary part
are a real value of the given size).  It is recommended to use the *note
SELECTED_CHAR_KIND::, *note SELECTED_INT_KIND:: and *note
SELECTED_REAL_KIND:: intrinsics or the 'INT8', 'INT16', 'INT32',
'INT64', 'REAL32', 'REAL64', and 'REAL128' parameters of the
'ISO_FORTRAN_ENV' module instead of the concrete values.  The available
kind parameters can be found in the constant arrays 'CHARACTER_KINDS',
'INTEGER_KINDS', 'LOGICAL_KINDS' and 'REAL_KINDS' in the *note
ISO_FORTRAN_ENV:: module.  For C interoperability, the kind parameters
of the *note ISO_C_BINDING:: module should be used.


File: gfortran.info,  Node: Internal representation of LOGICAL variables,  Next: Evaluation of logical expressions,  Prev: KIND Type Parameters,  Up: Compiler Characteristics

5.2 Internal representation of LOGICAL variables
================================================

The Fortran standard does not specify how variables of 'LOGICAL' type
are represented, beyond requiring that 'LOGICAL' variables of default
kind have the same storage size as default 'INTEGER' and 'REAL'
variables.  The GNU Fortran internal representation is as follows.

   A 'LOGICAL(KIND=N)' variable is represented as an 'INTEGER(KIND=N)'
variable, however, with only two permissible values: '1' for '.TRUE.'
and '0' for '.FALSE.'.  Any other integer value results in undefined
behavior.

   See also *note Argument passing conventions:: and *note
Interoperability with C::.


File: gfortran.info,  Node: Evaluation of logical expressions,  Next: MAX and MIN intrinsics with REAL NaN arguments,  Prev: Internal representation of LOGICAL variables,  Up: Compiler Characteristics

5.3 Evaluation of logical expressions
=====================================

The Fortran standard does not require the compiler to evaluate all parts
of an expression, if they do not contribute to the final result.  For
logical expressions with '.AND.' or '.OR.' operators, in particular, GNU
Fortran will optimize out function calls (even to impure functions) if
the result of the expression can be established without them.  However,
since not all compilers do that, and such an optimization can
potentially modify the program flow and subsequent results, GNU Fortran
throws warnings for such situations with the '-Wfunction-elimination'
flag.


File: gfortran.info,  Node: MAX and MIN intrinsics with REAL NaN arguments,  Next: Thread-safety of the runtime library,  Prev: Evaluation of logical expressions,  Up: Compiler Characteristics

5.4 MAX and MIN intrinsics with REAL NaN arguments
==================================================

The Fortran standard does not specify what the result of the 'MAX' and
'MIN' intrinsics are if one of the arguments is a 'NaN'.  Accordingly,
the GNU Fortran compiler does not specify that either, as this allows
for faster and more compact code to be generated.  If the programmer
wishes to take some specific action in case one of the arguments is a
'NaN', it is necessary to explicitly test the arguments before calling
'MAX' or 'MIN', e.g.  with the 'IEEE_IS_NAN' function from the intrinsic
module 'IEEE_ARITHMETIC'.


File: gfortran.info,  Node: Thread-safety of the runtime library,  Next: Data consistency and durability,  Prev: MAX and MIN intrinsics with REAL NaN arguments,  Up: Compiler Characteristics

5.5 Thread-safety of the runtime library
========================================

GNU Fortran can be used in programs with multiple threads, e.g. by using
OpenMP, by calling OS thread handling functions via the 'ISO_C_BINDING'
facility, or by GNU Fortran compiled library code being called from a
multi-threaded program.

   The GNU Fortran runtime library, ('libgfortran'), supports being
called concurrently from multiple threads with the following exceptions.

   During library initialization, the C 'getenv' function is used, which
need not be thread-safe.  Similarly, the 'getenv' function is used to
implement the 'GET_ENVIRONMENT_VARIABLE' and 'GETENV' intrinsics.  It is
the responsibility of the user to ensure that the environment is not
being updated concurrently when any of these actions are taking place.

   The 'EXECUTE_COMMAND_LINE' and 'SYSTEM' intrinsics are implemented
with the 'system' function, which need not be thread-safe.  It is the
responsibility of the user to ensure that 'system' is not called
concurrently.

   For platforms not supporting thread-safe POSIX functions, further
functionality might not be thread-safe.  For details, please consult the
documentation for your operating system.

   The GNU Fortran runtime library uses various C library functions that
depend on the locale, such as 'strtod' and 'snprintf'.  In order to work
correctly in locale-aware programs that set the locale using
'setlocale', the locale is reset to the default "C" locale while
executing a formatted 'READ' or 'WRITE' statement.  On targets
supporting the POSIX 2008 per-thread locale functions (e.g.
'newlocale', 'uselocale', 'freelocale'), these are used and thus the
global locale set using 'setlocale' or the per-thread locales in other
threads are not affected.  However, on targets lacking this
functionality, the global LC_NUMERIC locale is set to "C" during the
formatted I/O. Thus, on such targets it's not safe to call 'setlocale'
concurrently from another thread while a Fortran formatted I/O operation
is in progress.  Also, other threads doing something dependent on the
LC_NUMERIC locale might not work correctly if a formatted I/O operation
is in progress in another thread.


File: gfortran.info,  Node: Data consistency and durability,  Next: Files opened without an explicit ACTION= specifier,  Prev: Thread-safety of the runtime library,  Up: Compiler Characteristics

5.6 Data consistency and durability
===================================

This section contains a brief overview of data and metadata consistency
and durability issues when doing I/O.

   With respect to durability, GNU Fortran makes no effort to ensure
that data is committed to stable storage.  If this is required, the GNU
Fortran programmer can use the intrinsic 'FNUM' to retrieve the low
level file descriptor corresponding to an open Fortran unit.  Then,
using e.g.  the 'ISO_C_BINDING' feature, one can call the underlying
system call to flush dirty data to stable storage, such as 'fsync' on
POSIX, '_commit' on MingW, or 'fcntl(fd, F_FULLSYNC, 0)' on Mac OS X.
The following example shows how to call fsync:

       ! Declare the interface for POSIX fsync function
       interface
         function fsync (fd) bind(c,name="fsync")
         use iso_c_binding, only: c_int
           integer(c_int), value :: fd
           integer(c_int) :: fsync
         end function fsync
       end interface

       ! Variable declaration
       integer :: ret

       ! Opening unit 10
       open (10,file="foo")

       ! ...
       ! Perform I/O on unit 10
       ! ...

       ! Flush and sync
       flush(10)
       ret = fsync(fnum(10))

       ! Handle possible error
       if (ret /= 0) stop "Error calling FSYNC"

   With respect to consistency, for regular files GNU Fortran uses
buffered I/O in order to improve performance.  This buffer is flushed
automatically when full and in some other situations, e.g.  when closing
a unit.  It can also be explicitly flushed with the 'FLUSH' statement.
Also, the buffering can be turned off with the 'GFORTRAN_UNBUFFERED_ALL'
and 'GFORTRAN_UNBUFFERED_PRECONNECTED' environment variables.  Special
files, such as terminals and pipes, are always unbuffered.  Sometimes,
however, further things may need to be done in order to allow other
processes to see data that GNU Fortran has written, as follows.

   The Windows platform supports a relaxed metadata consistency model,
where file metadata is written to the directory lazily.  This means
that, for instance, the 'dir' command can show a stale size for a file.
One can force a directory metadata update by closing the unit, or by
calling '_commit' on the file descriptor.  Note, though, that '_commit'
will force all dirty data to stable storage, which is often a very slow
operation.

   The Network File System (NFS) implements a relaxed consistency model
called open-to-close consistency.  Closing a file forces dirty data and
metadata to be flushed to the server, and opening a file forces the
client to contact the server in order to revalidate cached data.
'fsync' will also force a flush of dirty data and metadata to the
server.  Similar to 'open' and 'close', acquiring and releasing 'fcntl'
file locks, if the server supports them, will also force cache
validation and flushing dirty data and metadata.


File: gfortran.info,  Node: Files opened without an explicit ACTION= specifier,  Next: File operations on symbolic links,  Prev: Data consistency and durability,  Up: Compiler Characteristics

5.7 Files opened without an explicit ACTION= specifier
======================================================

The Fortran standard says that if an 'OPEN' statement is executed
without an explicit 'ACTION=' specifier, the default value is processor
dependent.  GNU Fortran behaves as follows:

  1. Attempt to open the file with 'ACTION='READWRITE''
  2. If that fails, try to open with 'ACTION='READ''
  3. If that fails, try to open with 'ACTION='WRITE''
  4. If that fails, generate an error


File: gfortran.info,  Node: File operations on symbolic links,  Next: File format of unformatted sequential files,  Prev: Files opened without an explicit ACTION= specifier,  Up: Compiler Characteristics

5.8 File operations on symbolic links
=====================================

This section documents the behavior of GNU Fortran for file operations
on symbolic links, on systems that support them.

   * Results of INQUIRE statements of the "inquire by file" form will
     relate to the target of the symbolic link.  For example,
     'INQUIRE(FILE="foo",EXIST=ex)' will set EX to .TRUE. if FOO is a
     symbolic link pointing to an existing file, and .FALSE. if FOO
     points to an non-existing file ("dangling" symbolic link).

   * Using the 'OPEN' statement with a 'STATUS="NEW"' specifier on a
     symbolic link will result in an error condition, whether the
     symbolic link points to an existing target or is dangling.

   * If a symbolic link was connected, using the 'CLOSE' statement with
     a 'STATUS="DELETE"' specifier will cause the symbolic link itself
     to be deleted, not its target.


File: gfortran.info,  Node: File format of unformatted sequential files,  Next: Asynchronous I/O,  Prev: File operations on symbolic links,  Up: Compiler Characteristics

5.9 File format of unformatted sequential files
===============================================

Unformatted sequential files are stored as logical records using record
markers.  Each logical record consists of one of more subrecords.

   Each subrecord consists of a leading record marker, the data written
by the user program, and a trailing record marker.  The record markers
are four-byte integers by default, and eight-byte integers if the
'-fmax-subrecord-length=8' option (which exists for backwards
compability only) is in effect.

   The representation of the record markers is that of unformatted files
given with the '-fconvert' option, the *note CONVERT specifier:: in an
open statement or the *note GFORTRAN_CONVERT_UNIT:: environment
variable.

   The maximum number of bytes of user data in a subrecord is 2147483639
(2 GiB - 9) for a four-byte record marker.  This limit can be lowered
with the '-fmax-subrecord-length' option, altough this is rarely useful.
If the length of a logical record exceeds this limit, the data is
distributed among several subrecords.

   The absolute of the number stored in the record markers is the number
of bytes of user data in the corresponding subrecord.  If the leading
record marker of a subrecord contains a negative number, another
subrecord follows the current one.  If the trailing record marker
contains a negative number, then there is a preceding subrecord.

   In the most simple case, with only one subrecord per logical record,
both record markers contain the number of bytes of user data in the
record.

   The format for unformatted sequential data can be duplicated using
unformatted stream, as shown in the example program for an unformatted
record containing a single subrecord:

     program main
       use iso_fortran_env, only: int32
       implicit none
       integer(int32) :: i
       real, dimension(10) :: a, b
       call random_number(a)
       open (10,file='test.dat',form='unformatted',access='stream')
       inquire (iolength=i) a
       write (10) i, a, i
       close (10)
       open (10,file='test.dat',form='unformatted')
       read (10) b
       if (all (a == b)) print *,'success!'
     end program main


File: gfortran.info,  Node: Asynchronous I/O,  Prev: File format of unformatted sequential files,  Up: Compiler Characteristics

5.10 Asynchronous I/O
=====================

Asynchronous I/O is supported if the program is linked against the POSIX
thread library.  If that is not the case, all I/O is performed as
synchronous.  On systems which do not support pthread condition
variables, such as AIX, I/O is also performed as synchronous.

   On some systems, such as Darwin or Solaris, the POSIX thread library
is always linked in, so asynchronous I/O is always performed.  On other
sytems, such as Linux, it is necessary to specify '-pthread',
'-lpthread' or '-fopenmp' during the linking step.


File: gfortran.info,  Node: Extensions,  Next: Mixed-Language Programming,  Prev: Compiler Characteristics,  Up: Top

6 Extensions
************

The two sections below detail the extensions to standard Fortran that
are implemented in GNU Fortran, as well as some of the popular or
historically important extensions that are not (or not yet) implemented.
For the latter case, we explain the alternatives available to GNU
Fortran users, including replacement by standard-conforming code or GNU
extensions.

* Menu:

* Extensions implemented in GNU Fortran::
* Extensions not implemented in GNU Fortran::


File: gfortran.info,  Node: Extensions implemented in GNU Fortran,  Next: Extensions not implemented in GNU Fortran,  Up: Extensions

6.1 Extensions implemented in GNU Fortran
=========================================

GNU Fortran implements a number of extensions over standard Fortran.
This chapter contains information on their syntax and meaning.  There
are currently two categories of GNU Fortran extensions, those that
provide functionality beyond that provided by any standard, and those
that are supported by GNU Fortran purely for backward compatibility with
legacy compilers.  By default, '-std=gnu' allows the compiler to accept
both types of extensions, but to warn about the use of the latter.
Specifying either '-std=f95', '-std=f2003', '-std=f2008', or
'-std=f2018' disables both types of extensions, and '-std=legacy' allows
both without warning.  The special compile flag '-fdec' enables
additional compatibility extensions along with those enabled by
'-std=legacy'.

* Menu:

* Old-style kind specifications::
* Old-style variable initialization::
* Extensions to namelist::
* X format descriptor without count field::
* Commas in FORMAT specifications::
* Missing period in FORMAT specifications::
* I/O item lists::
* 'Q' exponent-letter::
* BOZ literal constants::
* Real array indices::
* Unary operators::
* Implicitly convert LOGICAL and INTEGER values::
* Hollerith constants support::
* Cray pointers::
* CONVERT specifier::
* OpenMP::
* OpenACC::
* Argument list functions::
* Read/Write after EOF marker::
* STRUCTURE and RECORD::
* UNION and MAP::
* Type variants for integer intrinsics::
* AUTOMATIC and STATIC attributes::
* Extended math intrinsics::
* Form feed as whitespace::
* TYPE as an alias for PRINT::
* %LOC as an rvalue::
* .XOR. operator::
* Bitwise logical operators::
* Extended I/O specifiers::
* Legacy PARAMETER statements::
* Default exponents::


File: gfortran.info,  Node: Old-style kind specifications,  Next: Old-style variable initialization,  Up: Extensions implemented in GNU Fortran

6.1.1 Old-style kind specifications
-----------------------------------

GNU Fortran allows old-style kind specifications in declarations.  These
look like:
           TYPESPEC*size x,y,z
where 'TYPESPEC' is a basic type ('INTEGER', 'REAL', etc.), and where
'size' is a byte count corresponding to the storage size of a valid kind
for that type.  (For 'COMPLEX' variables, 'size' is the total size of
the real and imaginary parts.)  The statement then declares 'x', 'y' and
'z' to be of type 'TYPESPEC' with the appropriate kind.  This is
equivalent to the standard-conforming declaration
           TYPESPEC(k) x,y,z
where 'k' is the kind parameter suitable for the intended precision.  As
kind parameters are implementation-dependent, use the 'KIND',
'SELECTED_INT_KIND' and 'SELECTED_REAL_KIND' intrinsics to retrieve the
correct value, for instance 'REAL*8 x' can be replaced by:
     INTEGER, PARAMETER :: dbl = KIND(1.0d0)
     REAL(KIND=dbl) :: x


File: gfortran.info,  Node: Old-style variable initialization,  Next: Extensions to namelist,  Prev: Old-style kind specifications,  Up: Extensions implemented in GNU Fortran

6.1.2 Old-style variable initialization
---------------------------------------

GNU Fortran allows old-style initialization of variables of the form:
           INTEGER i/1/,j/2/
           REAL x(2,2) /3*0.,1./
   The syntax for the initializers is as for the 'DATA' statement, but
unlike in a 'DATA' statement, an initializer only applies to the
variable immediately preceding the initialization.  In other words,
something like 'INTEGER I,J/2,3/' is not valid.  This style of
initialization is only allowed in declarations without double colons
('::'); the double colons were introduced in Fortran 90, which also
introduced a standard syntax for initializing variables in type
declarations.

   Examples of standard-conforming code equivalent to the above example
are:
     ! Fortran 90
           INTEGER :: i = 1, j = 2
           REAL :: x(2,2) = RESHAPE((/0.,0.,0.,1./),SHAPE(x))
     ! Fortran 77
           INTEGER i, j
           REAL x(2,2)
           DATA i/1/, j/2/, x/3*0.,1./

   Note that variables which are explicitly initialized in declarations
or in 'DATA' statements automatically acquire the 'SAVE' attribute.


File: gfortran.info,  Node: Extensions to namelist,  Next: X format descriptor without count field,  Prev: Old-style variable initialization,  Up: Extensions implemented in GNU Fortran

6.1.3 Extensions to namelist
----------------------------

GNU Fortran fully supports the Fortran 95 standard for namelist I/O
including array qualifiers, substrings and fully qualified derived
types.  The output from a namelist write is compatible with namelist
read.  The output has all names in upper case and indentation to column
1 after the namelist name.  Two extensions are permitted:

   Old-style use of '$' instead of '&'
     $MYNML
      X(:)%Y(2) = 1.0 2.0 3.0
      CH(1:4) = "abcd"
     $END

   It should be noted that the default terminator is '/' rather than
'&END'.

   Querying of the namelist when inputting from stdin.  After at least
one space, entering '?' sends to stdout the namelist name and the names
of the variables in the namelist:
      ?

     &mynml
      x
      x%y
      ch
     &end

   Entering '=?' outputs the namelist to stdout, as if 'WRITE(*,NML =
mynml)' had been called:
     =?

     &MYNML
      X(1)%Y=  0.000000    ,  1.000000    ,  0.000000    ,
      X(2)%Y=  0.000000    ,  2.000000    ,  0.000000    ,
      X(3)%Y=  0.000000    ,  3.000000    ,  0.000000    ,
      CH=abcd,  /

   To aid this dialog, when input is from stdin, errors send their
messages to stderr and execution continues, even if 'IOSTAT' is set.

   'PRINT' namelist is permitted.  This causes an error if '-std=f95' is
used.
     PROGRAM test_print
       REAL, dimension (4)  ::  x = (/1.0, 2.0, 3.0, 4.0/)
       NAMELIST /mynml/ x
       PRINT mynml
     END PROGRAM test_print

   Expanded namelist reads are permitted.  This causes an error if
'-std=f95' is used.  In the following example, the first element of the
array will be given the value 0.00 and the two succeeding elements will
be given the values 1.00 and 2.00.
     &MYNML
       X(1,1) = 0.00 , 1.00 , 2.00
     /

   When writing a namelist, if no 'DELIM=' is specified, by default a
double quote is used to delimit character strings.  If -std=F95, F2003,
or F2008, etc, the delim status is set to 'none'.  Defaulting to quotes
ensures that namelists with character strings can be subsequently read
back in accurately.


File: gfortran.info,  Node: X format descriptor without count field,  Next: Commas in FORMAT specifications,  Prev: Extensions to namelist,  Up: Extensions implemented in GNU Fortran

6.1.4 'X' format descriptor without count field
-----------------------------------------------

To support legacy codes, GNU Fortran permits the count field of the 'X'
edit descriptor in 'FORMAT' statements to be omitted.  When omitted, the
count is implicitly assumed to be one.

            PRINT 10, 2, 3
     10     FORMAT (I1, X, I1)


File: gfortran.info,  Node: Commas in FORMAT specifications,  Next: Missing period in FORMAT specifications,  Prev: X format descriptor without count field,  Up: Extensions implemented in GNU Fortran

6.1.5 Commas in 'FORMAT' specifications
---------------------------------------

To support legacy codes, GNU Fortran allows the comma separator to be
omitted immediately before and after character string edit descriptors
in 'FORMAT' statements.

            PRINT 10, 2, 3
     10     FORMAT ('FOO='I1' BAR='I2)


File: gfortran.info,  Node: Missing period in FORMAT specifications,  Next: I/O item lists,  Prev: Commas in FORMAT specifications,  Up: Extensions implemented in GNU Fortran

6.1.6 Missing period in 'FORMAT' specifications
-----------------------------------------------

To support legacy codes, GNU Fortran allows missing periods in format
specifications if and only if '-std=legacy' is given on the command
line.  This is considered non-conforming code and is discouraged.

            REAL :: value
            READ(*,10) value
     10     FORMAT ('F4')


File: gfortran.info,  Node: I/O item lists,  Next: 'Q' exponent-letter,  Prev: Missing period in FORMAT specifications,  Up: Extensions implemented in GNU Fortran

6.1.7 I/O item lists
--------------------

To support legacy codes, GNU Fortran allows the input item list of the
'READ' statement, and the output item lists of the 'WRITE' and 'PRINT'
statements, to start with a comma.


File: gfortran.info,  Node: 'Q' exponent-letter,  Next: BOZ literal constants,  Prev: I/O item lists,  Up: Extensions implemented in GNU Fortran

6.1.8 'Q' exponent-letter
-------------------------

GNU Fortran accepts real literal constants with an exponent-letter of
'Q', for example, '1.23Q45'.  The constant is interpreted as a
'REAL(16)' entity on targets that support this type.  If the target does
not support 'REAL(16)' but has a 'REAL(10)' type, then the
real-literal-constant will be interpreted as a 'REAL(10)' entity.  In
the absence of 'REAL(16)' and 'REAL(10)', an error will occur.


File: gfortran.info,  Node: BOZ literal constants,  Next: Real array indices,  Prev: 'Q' exponent-letter,  Up: Extensions implemented in GNU Fortran

6.1.9 BOZ literal constants
---------------------------

Besides decimal constants, Fortran also supports binary ('b'), octal
('o') and hexadecimal ('z') integer constants.  The syntax is: 'prefix
quote digits quote', were the prefix is either 'b', 'o' or 'z', quote is
either ''' or '"' and the digits are for binary '0' or '1', for octal
between '0' and '7', and for hexadecimal between '0' and 'F'.  (Example:
'b'01011101''.)

   Up to Fortran 95, BOZ literals were only allowed to initialize
integer variables in DATA statements.  Since Fortran 2003 BOZ literals
are also allowed as argument of 'REAL', 'DBLE', 'INT' and 'CMPLX'; the
result is the same as if the integer BOZ literal had been converted by
'TRANSFER' to, respectively, 'real', 'double precision', 'integer' or
'complex'.  As GNU Fortran extension the intrinsic procedures 'FLOAT',
'DFLOAT', 'COMPLEX' and 'DCMPLX' are treated alike.

   As an extension, GNU Fortran allows hexadecimal BOZ literal constants
to be specified using the 'X' prefix, in addition to the standard 'Z'
prefix.  The BOZ literal can also be specified by adding a suffix to the
string, for example, 'Z'ABC'' and ''ABC'Z' are equivalent.

   Furthermore, GNU Fortran allows using BOZ literal constants outside
DATA statements and the four intrinsic functions allowed by Fortran
2003.  In DATA statements, in direct assignments, where the right-hand
side only contains a BOZ literal constant, and for old-style
initializers of the form 'integer i /o'0173'/', the constant is
transferred as if 'TRANSFER' had been used; for 'COMPLEX' numbers, only
the real part is initialized unless 'CMPLX' is used.  In all other
cases, the BOZ literal constant is converted to an 'INTEGER' value with
the largest decimal representation.  This value is then converted
numerically to the type and kind of the variable in question.  (For
instance, 'real :: r = b'0000001' + 1' initializes 'r' with '2.0'.)  As
different compilers implement the extension differently, one should be
careful when doing bitwise initialization of non-integer variables.

   Note that initializing an 'INTEGER' variable with a statement such as
'DATA i/Z'FFFFFFFF'/' will give an integer overflow error rather than
the desired result of -1 when 'i' is a 32-bit integer on a system that
supports 64-bit integers.  The '-fno-range-check' option can be used as
a workaround for legacy code that initializes integers in this manner.


File: gfortran.info,  Node: Real array indices,  Next: Unary operators,  Prev: BOZ literal constants,  Up: Extensions implemented in GNU Fortran

6.1.10 Real array indices
-------------------------

As an extension, GNU Fortran allows the use of 'REAL' expressions or
variables as array indices.


File: gfortran.info,  Node: Unary operators,  Next: Implicitly convert LOGICAL and INTEGER values,  Prev: Real array indices,  Up: Extensions implemented in GNU Fortran

6.1.11 Unary operators
----------------------

As an extension, GNU Fortran allows unary plus and unary minus operators
to appear as the second operand of binary arithmetic operators without
the need for parenthesis.

            X = Y * -Z


File: gfortran.info,  Node: Implicitly convert LOGICAL and INTEGER values,  Next: Hollerith constants support,  Prev: Unary operators,  Up: Extensions implemented in GNU Fortran

6.1.12 Implicitly convert 'LOGICAL' and 'INTEGER' values
--------------------------------------------------------

As an extension for backwards compatibility with other compilers, GNU
Fortran allows the implicit conversion of 'LOGICAL' values to 'INTEGER'
values and vice versa.  When converting from a 'LOGICAL' to an
'INTEGER', '.FALSE.' is interpreted as zero, and '.TRUE.' is interpreted
as one.  When converting from 'INTEGER' to 'LOGICAL', the value zero is
interpreted as '.FALSE.' and any nonzero value is interpreted as
'.TRUE.'.

             LOGICAL :: l
             l = 1
             INTEGER :: i
             i = .TRUE.

   However, there is no implicit conversion of 'INTEGER' values in
'if'-statements, nor of 'LOGICAL' or 'INTEGER' values in I/O operations.


File: gfortran.info,  Node: Hollerith constants support,  Next: Cray pointers,  Prev: Implicitly convert LOGICAL and INTEGER values,  Up: Extensions implemented in GNU Fortran

6.1.13 Hollerith constants support
----------------------------------

GNU Fortran supports Hollerith constants in assignments, function
arguments, and 'DATA' and 'ASSIGN' statements.  A Hollerith constant is
written as a string of characters preceded by an integer constant
indicating the character count, and the letter 'H' or 'h', and stored in
bytewise fashion in a numeric ('INTEGER', 'REAL', or 'complex') or
'LOGICAL' variable.  The constant will be padded or truncated to fit the
size of the variable in which it is stored.

   Examples of valid uses of Hollerith constants:
           complex*16 x(2)
           data x /16Habcdefghijklmnop, 16Hqrstuvwxyz012345/
           x(1) = 16HABCDEFGHIJKLMNOP
           call foo (4h abc)

   Invalid Hollerith constants examples:
           integer*4 a
           a = 8H12345678 ! Valid, but the Hollerith constant will be truncated.
           a = 0H         ! At least one character is needed.

   In general, Hollerith constants were used to provide a rudimentary
facility for handling character strings in early Fortran compilers,
prior to the introduction of 'CHARACTER' variables in Fortran 77; in
those cases, the standard-compliant equivalent is to convert the program
to use proper character strings.  On occasion, there may be a case where
the intent is specifically to initialize a numeric variable with a given
byte sequence.  In these cases, the same result can be obtained by using
the 'TRANSFER' statement, as in this example.
           INTEGER(KIND=4) :: a
           a = TRANSFER ("abcd", a)     ! equivalent to: a = 4Habcd


File: gfortran.info,  Node: Cray pointers,  Next: CONVERT specifier,  Prev: Hollerith constants support,  Up: Extensions implemented in GNU Fortran

6.1.14 Cray pointers
--------------------

Cray pointers are part of a non-standard extension that provides a
C-like pointer in Fortran.  This is accomplished through a pair of
variables: an integer "pointer" that holds a memory address, and a
"pointee" that is used to dereference the pointer.

   Pointer/pointee pairs are declared in statements of the form:
             pointer ( <pointer> , <pointee> )
   or,
             pointer ( <pointer1> , <pointee1> ), ( <pointer2> , <pointee2> ), ...
   The pointer is an integer that is intended to hold a memory address.
The pointee may be an array or scalar.  If an assumed-size array is
permitted within the scoping unit, a pointee can be an assumed-size
array.  That is, the last dimension may be left unspecified by using a
'*' in place of a value.  A pointee cannot be an assumed shape array.
No space is allocated for the pointee.

   The pointee may have its type declared before or after the pointer
statement, and its array specification (if any) may be declared before,
during, or after the pointer statement.  The pointer may be declared as
an integer prior to the pointer statement.  However, some machines have
default integer sizes that are different than the size of a pointer, and
so the following code is not portable:
             integer ipt
             pointer (ipt, iarr)
   If a pointer is declared with a kind that is too small, the compiler
will issue a warning; the resulting binary will probably not work
correctly, because the memory addresses stored in the pointers may be
truncated.  It is safer to omit the first line of the above example; if
explicit declaration of ipt's type is omitted, then the compiler will
ensure that ipt is an integer variable large enough to hold a pointer.

   Pointer arithmetic is valid with Cray pointers, but it is not the
same as C pointer arithmetic.  Cray pointers are just ordinary integers,
so the user is responsible for determining how many bytes to add to a
pointer in order to increment it.  Consider the following example:
             real target(10)
             real pointee(10)
             pointer (ipt, pointee)
             ipt = loc (target)
             ipt = ipt + 1
   The last statement does not set 'ipt' to the address of 'target(1)',
as it would in C pointer arithmetic.  Adding '1' to 'ipt' just adds one
byte to the address stored in 'ipt'.

   Any expression involving the pointee will be translated to use the
value stored in the pointer as the base address.

   To get the address of elements, this extension provides an intrinsic
function 'LOC()'.  The 'LOC()' function is equivalent to the '&'
operator in C, except the address is cast to an integer type:
             real ar(10)
             pointer(ipt, arpte(10))
             real arpte
             ipt = loc(ar)  ! Makes arpte is an alias for ar
             arpte(1) = 1.0 ! Sets ar(1) to 1.0
   The pointer can also be set by a call to the 'MALLOC' intrinsic (see
*note MALLOC::).

   Cray pointees often are used to alias an existing variable.  For
example:
             integer target(10)
             integer iarr(10)
             pointer (ipt, iarr)
             ipt = loc(target)
   As long as 'ipt' remains unchanged, 'iarr' is now an alias for
'target'.  The optimizer, however, will not detect this aliasing, so it
is unsafe to use 'iarr' and 'target' simultaneously.  Using a pointee in
any way that violates the Fortran aliasing rules or assumptions is
illegal.  It is the user's responsibility to avoid doing this; the
compiler works under the assumption that no such aliasing occurs.

   Cray pointers will work correctly when there is no aliasing (i.e.,
when they are used to access a dynamically allocated block of memory),
and also in any routine where a pointee is used, but any variable with
which it shares storage is not used.  Code that violates these rules may
not run as the user intends.  This is not a bug in the optimizer; any
code that violates the aliasing rules is illegal.  (Note that this is
not unique to GNU Fortran; any Fortran compiler that supports Cray
pointers will "incorrectly" optimize code with illegal aliasing.)

   There are a number of restrictions on the attributes that can be
applied to Cray pointers and pointees.  Pointees may not have the
'ALLOCATABLE', 'INTENT', 'OPTIONAL', 'DUMMY', 'TARGET', 'INTRINSIC', or
'POINTER' attributes.  Pointers may not have the 'DIMENSION', 'POINTER',
'TARGET', 'ALLOCATABLE', 'EXTERNAL', or 'INTRINSIC' attributes, nor may
they be function results.  Pointees may not occur in more than one
pointer statement.  A pointee cannot be a pointer.  Pointees cannot
occur in equivalence, common, or data statements.

   A Cray pointer may also point to a function or a subroutine.  For
example, the following excerpt is valid:
       implicit none
       external sub
       pointer (subptr,subpte)
       external subpte
       subptr = loc(sub)
       call subpte()
       [...]
       subroutine sub
       [...]
       end subroutine sub

   A pointer may be modified during the course of a program, and this
will change the location to which the pointee refers.  However, when
pointees are passed as arguments, they are treated as ordinary variables
in the invoked function.  Subsequent changes to the pointer will not
change the base address of the array that was passed.


File: gfortran.info,  Node: CONVERT specifier,  Next: OpenMP,  Prev: Cray pointers,  Up: Extensions implemented in GNU Fortran

6.1.15 'CONVERT' specifier
--------------------------

GNU Fortran allows the conversion of unformatted data between little-
and big-endian representation to facilitate moving of data between
different systems.  The conversion can be indicated with the 'CONVERT'
specifier on the 'OPEN' statement.  *Note GFORTRAN_CONVERT_UNIT::, for
an alternative way of specifying the data format via an environment
variable.

   Valid values for 'CONVERT' are:
     'CONVERT='NATIVE'' Use the native format.  This is the default.
     'CONVERT='SWAP'' Swap between little- and big-endian.
     'CONVERT='LITTLE_ENDIAN'' Use the little-endian representation for
     unformatted files.
     'CONVERT='BIG_ENDIAN'' Use the big-endian representation for
     unformatted files.

   Using the option could look like this:
       open(file='big.dat',form='unformatted',access='sequential', &
            convert='big_endian')

   The value of the conversion can be queried by using
'INQUIRE(CONVERT=ch)'.  The values returned are ''BIG_ENDIAN'' and
''LITTLE_ENDIAN''.

   'CONVERT' works between big- and little-endian for 'INTEGER' values
of all supported kinds and for 'REAL' on IEEE systems of kinds 4 and 8.
Conversion between different "extended double" types on different
architectures such as m68k and x86_64, which GNU Fortran supports as
'REAL(KIND=10)' and 'REAL(KIND=16)', will probably not work.

   _Note that the values specified via the GFORTRAN_CONVERT_UNIT
environment variable will override the CONVERT specifier in the open
statement_.  This is to give control over data formats to users who do
not have the source code of their program available.

   Using anything but the native representation for unformatted data
carries a significant speed overhead.  If speed in this area matters to
you, it is best if you use this only for data that needs to be portable.


File: gfortran.info,  Node: OpenMP,  Next: OpenACC,  Prev: CONVERT specifier,  Up: Extensions implemented in GNU Fortran

6.1.16 OpenMP
-------------

OpenMP (Open Multi-Processing) is an application programming interface
(API) that supports multi-platform shared memory multiprocessing
programming in C/C++ and Fortran on many architectures, including Unix
and Microsoft Windows platforms.  It consists of a set of compiler
directives, library routines, and environment variables that influence
run-time behavior.

   GNU Fortran strives to be compatible to the OpenMP Application
Program Interface v4.5 (http://openmp.org/wp/openmp-specifications/).

   To enable the processing of the OpenMP directive '!$omp' in free-form
source code; the 'c$omp', '*$omp' and '!$omp' directives in fixed form;
the '!$' conditional compilation sentinels in free form; and the 'c$',
'*$' and '!$' sentinels in fixed form, 'gfortran' needs to be invoked
with the '-fopenmp'.  This also arranges for automatic linking of the
GNU Offloading and Multi Processing Runtime Library *note libgomp:
(libgomp)Top.

   The OpenMP Fortran runtime library routines are provided both in a
form of a Fortran 90 module named 'omp_lib' and in a form of a Fortran
'include' file named 'omp_lib.h'.

   An example of a parallelized loop taken from Appendix A.1 of the
OpenMP Application Program Interface v2.5:
     SUBROUTINE A1(N, A, B)
       INTEGER I, N
       REAL B(N), A(N)
     !$OMP PARALLEL DO !I is private by default
       DO I=2,N
         B(I) = (A(I) + A(I-1)) / 2.0
       ENDDO
     !$OMP END PARALLEL DO
     END SUBROUTINE A1

   Please note:
   * '-fopenmp' implies '-frecursive', i.e., all local arrays will be
     allocated on the stack.  When porting existing code to OpenMP, this
     may lead to surprising results, especially to segmentation faults
     if the stacksize is limited.

   * On glibc-based systems, OpenMP enabled applications cannot be
     statically linked due to limitations of the underlying
     pthreads-implementation.  It might be possible to get a working
     solution if '-Wl,--whole-archive -lpthread -Wl,--no-whole-archive'
     is added to the command line.  However, this is not supported by
     'gcc' and thus not recommended.


File: gfortran.info,  Node: OpenACC,  Next: Argument list functions,  Prev: OpenMP,  Up: Extensions implemented in GNU Fortran

6.1.17 OpenACC
--------------

OpenACC is an application programming interface (API) that supports
offloading of code to accelerator devices.  It consists of a set of
compiler directives, library routines, and environment variables that
influence run-time behavior.

   GNU Fortran strives to be compatible to the OpenACC Application
Programming Interface v2.0 (http://www.openacc.org/).

   To enable the processing of the OpenACC directive '!$acc' in
free-form source code; the 'c$acc', '*$acc' and '!$acc' directives in
fixed form; the '!$' conditional compilation sentinels in free form; and
the 'c$', '*$' and '!$' sentinels in fixed form, 'gfortran' needs to be
invoked with the '-fopenacc'.  This also arranges for automatic linking
of the GNU Offloading and Multi Processing Runtime Library *note
libgomp: (libgomp)Top.

   The OpenACC Fortran runtime library routines are provided both in a
form of a Fortran 90 module named 'openacc' and in a form of a Fortran
'include' file named 'openacc_lib.h'.

   Note that this is an experimental feature, incomplete, and subject to
change in future versions of GCC. See <https://gcc.gnu.org/wiki/OpenACC>
for more information.


File: gfortran.info,  Node: Argument list functions,  Next: Read/Write after EOF marker,  Prev: OpenACC,  Up: Extensions implemented in GNU Fortran

6.1.18 Argument list functions '%VAL', '%REF' and '%LOC'
--------------------------------------------------------

GNU Fortran supports argument list functions '%VAL', '%REF' and '%LOC'
statements, for backward compatibility with g77.  It is recommended that
these should be used only for code that is accessing facilities outside
of GNU Fortran, such as operating system or windowing facilities.  It is
best to constrain such uses to isolated portions of a program-portions
that deal specifically and exclusively with low-level, system-dependent
facilities.  Such portions might well provide a portable interface for
use by the program as a whole, but are themselves not portable, and
should be thoroughly tested each time they are rebuilt using a new
compiler or version of a compiler.

   '%VAL' passes a scalar argument by value, '%REF' passes it by
reference and '%LOC' passes its memory location.  Since gfortran already
passes scalar arguments by reference, '%REF' is in effect a do-nothing.
'%LOC' has the same effect as a Fortran pointer.

   An example of passing an argument by value to a C subroutine foo.:
     C
     C prototype      void foo_ (float x);
     C
           external foo
           real*4 x
           x = 3.14159
           call foo (%VAL (x))
           end

   For details refer to the g77 manual
<https://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/index.html#Top>.

   Also, 'c_by_val.f' and its partner 'c_by_val.c' of the GNU Fortran
testsuite are worth a look.


File: gfortran.info,  Node: Read/Write after EOF marker,  Next: STRUCTURE and RECORD,  Prev: Argument list functions,  Up: Extensions implemented in GNU Fortran

6.1.19 Read/Write after EOF marker
----------------------------------

Some legacy codes rely on allowing 'READ' or 'WRITE' after the EOF file
marker in order to find the end of a file.  GNU Fortran normally rejects
these codes with a run-time error message and suggests the user consider
'BACKSPACE' or 'REWIND' to properly position the file before the EOF
marker.  As an extension, the run-time error may be disabled using
-std=legacy.


File: gfortran.info,  Node: STRUCTURE and RECORD,  Next: UNION and MAP,  Prev: Read/Write after EOF marker,  Up: Extensions implemented in GNU Fortran

6.1.20 'STRUCTURE' and 'RECORD'
-------------------------------

Record structures are a pre-Fortran-90 vendor extension to create
user-defined aggregate data types.  Support for record structures in GNU
Fortran can be enabled with the '-fdec-structure' compile flag.  If you
have a choice, you should instead use Fortran 90's "derived types",
which have a different syntax.

   In many cases, record structures can easily be converted to derived
types.  To convert, replace 'STRUCTURE /'STRUCTURE-NAME'/' by 'TYPE'
TYPE-NAME.  Additionally, replace 'RECORD /'STRUCTURE-NAME'/' by
'TYPE('TYPE-NAME')'.  Finally, in the component access, replace the
period ('.') by the percent sign ('%').

   Here is an example of code using the non portable record structure
syntax:

     ! Declaring a structure named ``item'' and containing three fields:
     ! an integer ID, an description string and a floating-point price.
     STRUCTURE /item/
       INTEGER id
       CHARACTER(LEN=200) description
       REAL price
     END STRUCTURE

     ! Define two variables, an single record of type ``item''
     ! named ``pear'', and an array of items named ``store_catalog''
     RECORD /item/ pear, store_catalog(100)

     ! We can directly access the fields of both variables
     pear.id = 92316
     pear.description = "juicy D'Anjou pear"
     pear.price = 0.15
     store_catalog(7).id = 7831
     store_catalog(7).description = "milk bottle"
     store_catalog(7).price = 1.2

     ! We can also manipulate the whole structure
     store_catalog(12) = pear
     print *, store_catalog(12)

This code can easily be rewritten in the Fortran 90 syntax as following:

     ! ``STRUCTURE /name/ ... END STRUCTURE'' becomes
     ! ``TYPE name ... END TYPE''
     TYPE item
       INTEGER id
       CHARACTER(LEN=200) description
       REAL price
     END TYPE

     ! ``RECORD /name/ variable'' becomes ``TYPE(name) variable''
     TYPE(item) pear, store_catalog(100)

     ! Instead of using a dot (.) to access fields of a record, the
     ! standard syntax uses a percent sign (%)
     pear%id = 92316
     pear%description = "juicy D'Anjou pear"
     pear%price = 0.15
     store_catalog(7)%id = 7831
     store_catalog(7)%description = "milk bottle"
     store_catalog(7)%price = 1.2

     ! Assignments of a whole variable do not change
     store_catalog(12) = pear
     print *, store_catalog(12)

GNU Fortran implements STRUCTURES like derived types with the following
rules and exceptions:

   * Structures act like derived types with the 'SEQUENCE' attribute.
     Otherwise they may contain no specifiers.

   * Structures may contain a special field with the name '%FILL'.  This
     will create an anonymous component which cannot be accessed but
     occupies space just as if a component of the same type was declared
     in its place, useful for alignment purposes.  As an example, the
     following structure will consist of at least sixteen bytes:

          structure /padded/
            character(4) start
            character(8) %FILL
            character(4) end
          end structure

   * Structures may share names with other symbols.  For example, the
     following is invalid for derived types, but valid for structures:

          structure /header/
            ! ...
          end structure
          record /header/ header

   * Structure types may be declared nested within another parent
     structure.  The syntax is:
          structure /type-name/
              ...
              structure [/<type-name>/] <field-list>
          ...

     The type name may be ommitted, in which case the structure type
     itself is anonymous, and other structures of the same type cannot
     be instantiated.  The following shows some examples:

          structure /appointment/
            ! nested structure definition: app_time is an array of two 'time'
            structure /time/ app_time (2)
              integer(1) hour, minute
            end structure
            character(10) memo
          end structure

          ! The 'time' structure is still usable
          record /time/ now
          now = time(5, 30)

          ...

          structure /appointment/
            ! anonymous nested structure definition
            structure start, end
              integer(1) hour, minute
            end structure
            character(10) memo
          end structure

   * Structures may contain 'UNION' blocks.  For more detail see the
     section on *note UNION and MAP::.

   * Structures support old-style initialization of components, like
     those described in *note Old-style variable initialization::.  For
     array initializers, an initializer may contain a repeat
     specification of the form '<literal-integer> *
     <constant-initializer>'.  The value of the integer indicates the
     number of times to repeat the constant initializer when expanding
     the initializer list.


File: gfortran.info,  Node: UNION and MAP,  Next: Type variants for integer intrinsics,  Prev: STRUCTURE and RECORD,  Up: Extensions implemented in GNU Fortran

6.1.21 'UNION' and 'MAP'
------------------------

Unions are an old vendor extension which were commonly used with the
non-standard *note STRUCTURE and RECORD:: extensions.  Use of 'UNION'
and 'MAP' is automatically enabled with '-fdec-structure'.

   A 'UNION' declaration occurs within a structure; within the
definition of each union is a number of 'MAP' blocks.  Each 'MAP' shares
storage with its sibling maps (in the same union), and the size of the
union is the size of the largest map within it, just as with unions in
C. The major difference is that component references do not indicate
which union or map the component is in (the compiler gets to figure that
out).

   Here is a small example:
     structure /myunion/
     union
       map
         character(2) w0, w1, w2
       end map
       map
         character(6) long
       end map
     end union
     end structure

     record /myunion/ rec
     ! After this assignment...
     rec.long = 'hello!'

     ! The following is true:
     ! rec.w0 === 'he'
     ! rec.w1 === 'll'
     ! rec.w2 === 'o!'

   The two maps share memory, and the size of the union is ultimately
six bytes:

     0    1    2    3    4   5   6     Byte offset
     -------------------------------
     |    |    |    |    |    |    |
     -------------------------------

     ^    W0   ^    W1   ^    W2   ^
      \-------/ \-------/ \-------/

     ^             LONG            ^
      \---------------------------/

   Following is an example mirroring the layout of an Intel x86_64
register:

     structure /reg/
       union ! U0                ! rax
         map
           character(16) rx
         end map
         map
           character(8) rh         ! rah
           union ! U1
             map
               character(8) rl     ! ral
             end map
             map
               character(8) ex     ! eax
             end map
             map
               character(4) eh     ! eah
               union ! U2
                 map
                   character(4) el ! eal
                 end map
                 map
                   character(4) x  ! ax
                 end map
                 map
                   character(2) h  ! ah
                   character(2) l  ! al
                 end map
               end union
             end map
           end union
         end map
       end union
     end structure
     record /reg/ a

     ! After this assignment...
     a.rx     =     'AAAAAAAA.BBB.C.D'

     ! The following is true:
     a.rx === 'AAAAAAAA.BBB.C.D'
     a.rh === 'AAAAAAAA'
     a.rl ===         '.BBB.C.D'
     a.ex ===         '.BBB.C.D'
     a.eh ===         '.BBB'
     a.el ===             '.C.D'
     a.x  ===             '.C.D'
     a.h  ===             '.C'
     a.l  ===               '.D'


File: gfortran.info,  Node: Type variants for integer intrinsics,  Next: AUTOMATIC and STATIC attributes,  Prev: UNION and MAP,  Up: Extensions implemented in GNU Fortran

6.1.22 Type variants for integer intrinsics
-------------------------------------------

Similar to the D/C prefixes to real functions to specify the
input/output types, GNU Fortran offers B/I/J/K prefixes to integer
functions for compatibility with DEC programs.  The types implied by
each are:

     B - INTEGER(kind=1)
     I - INTEGER(kind=2)
     J - INTEGER(kind=4)
     K - INTEGER(kind=8)

   GNU Fortran supports these with the flag '-fdec-intrinsic-ints'.
Intrinsics for which prefixed versions are available and in what form
are noted in *note Intrinsic Procedures::.  The complete list of
supported intrinsics is here:

Intrinsic      B              I              J              K
                                                            
---------------------------------------------------------------------------
'*note         'BABS'         'IIABS'        'JIABS'        'KIABS'
ABS::'
'*note         'BBTEST'       'BITEST'       'BJTEST'       'BKTEST'
BTEST::'
'*note         'BIAND'        'IIAND'        'JIAND'        'KIAND'
IAND::'
'*note         'BBCLR'        'IIBCLR'       'JIBCLR'       'KIBCLR'
IBCLR::'
'*note         'BBITS'        'IIBITS'       'JIBITS'       'KIBITS'
IBITS::'
'*note         'BBSET'        'IIBSET'       'JIBSET'       'KIBSET'
IBSET::'
'*note         'BIEOR'        'IIEOR'        'JIEOR'        'KIEOR'
IEOR::'
'*note         'BIOR'         'IIOR'         'JIOR'         'KIOR'
IOR::'
'*note         'BSHFT'        'IISHFT'       'JISHFT'       'KISHFT'
ISHFT::'
'*note         'BSHFTC'       'IISHFTC'      'JISHFTC'      'KISHFTC'
ISHFTC::'
'*note         'BMOD'         'IMOD'         'JMOD'         'KMOD'
MOD::'
'*note         'BNOT'         'INOT'         'JNOT'         'KNOT'
NOT::'
'*note         '--'           'FLOATI'       'FLOATJ'       'FLOATK'
REAL::'


File: gfortran.info,  Node: AUTOMATIC and STATIC attributes,  Next: Extended math intrinsics,  Prev: Type variants for integer intrinsics,  Up: Extensions implemented in GNU Fortran

6.1.23 'AUTOMATIC' and 'STATIC' attributes
------------------------------------------

With '-fdec-static' GNU Fortran supports the DEC extended attributes
'STATIC' and 'AUTOMATIC' to provide explicit specification of entity
storage.  These follow the syntax of the Fortran standard 'SAVE'
attribute.

   'STATIC' is exactly equivalent to 'SAVE', and specifies that an
entity should be allocated in static memory.  As an example, 'STATIC'
local variables will retain their values across multiple calls to a
function.

   Entities marked 'AUTOMATIC' will be stack automatic whenever
possible.  'AUTOMATIC' is the default for local variables smaller than
'-fmax-stack-var-size', unless '-fno-automatic' is given.  This
attribute overrides '-fno-automatic', '-fmax-stack-var-size', and
blanket 'SAVE' statements.

   Examples:

     subroutine f
       integer, automatic :: i  ! automatic variable
       integer x, y             ! static variables
       save
       ...
     endsubroutine
     subroutine f
       integer a, b, c, x, y, z
       static :: x
       save y
       automatic z, c
       ! a, b, c, and z are automatic
       ! x and y are static
     endsubroutine
     ! Compiled with -fno-automatic
     subroutine f
       integer a, b, c, d
       automatic :: a
       ! a is automatic; b, c, and d are static
     endsubroutine


File: gfortran.info,  Node: Extended math intrinsics,  Next: Form feed as whitespace,  Prev: AUTOMATIC and STATIC attributes,  Up: Extensions implemented in GNU Fortran

6.1.24 Extended math intrinsics
-------------------------------

GNU Fortran supports an extended list of mathematical intrinsics with
the compile flag '-fdec-math' for compatability with legacy code.  These
intrinsics are described fully in *note Intrinsic Procedures:: where it
is noted that they are extensions and should be avoided whenever
possible.

   Specifically, '-fdec-math' enables the *note COTAN:: intrinsic, and
trigonometric intrinsics which accept or produce values in degrees
instead of radians.  Here is a summary of the new intrinsics:

Radians                              Degrees
--------------------------------------------------------------------------
'*note ACOS::'                       '*note ACOSD::'*
'*note ASIN::'                       '*note ASIND::'*
'*note ATAN::'                       '*note ATAND::'*
'*note ATAN2::'                      '*note ATAN2D::'*
'*note COS::'                        '*note COSD::'*
'*note COTAN::'*                     '*note COTAND::'*
'*note SIN::'                        '*note SIND::'*
'*note TAN::'                        '*note TAND::'*

   * Enabled with '-fdec-math'.

   For advanced users, it may be important to know the implementation of
these functions.  They are simply wrappers around the standard radian
functions, which have more accurate builtin versions.  These functions
convert their arguments (or results) to degrees (or radians) by taking
the value modulus 360 (or 2*pi) and then multiplying it by a constant
radian-to-degree (or degree-to-radian) factor, as appropriate.  The
factor is computed at compile-time as 180/pi (or pi/180).


File: gfortran.info,  Node: Form feed as whitespace,  Next: TYPE as an alias for PRINT,  Prev: Extended math intrinsics,  Up: Extensions implemented in GNU Fortran

6.1.25 Form feed as whitespace
------------------------------

Historically, legacy compilers allowed insertion of form feed characters
('\f', ASCII 0xC) at the beginning of lines for formatted output to line
printers, though the Fortran standard does not mention this.  GNU
Fortran supports the interpretation of form feed characters in source as
whitespace for compatibility.


File: gfortran.info,  Node: TYPE as an alias for PRINT,  Next: %LOC as an rvalue,  Prev: Form feed as whitespace,  Up: Extensions implemented in GNU Fortran

6.1.26 TYPE as an alias for PRINT
---------------------------------

For compatibility, GNU Fortran will interpret 'TYPE' statements as
'PRINT' statements with the flag '-fdec'.  With this flag asserted, the
following two examples are equivalent:

     TYPE *, 'hello world'

     PRINT *, 'hello world'


File: gfortran.info,  Node: %LOC as an rvalue,  Next: .XOR. operator,  Prev: TYPE as an alias for PRINT,  Up: Extensions implemented in GNU Fortran

6.1.27 %LOC as an rvalue
------------------------

Normally '%LOC' is allowed only in parameter lists.  However the
intrinsic function 'LOC' does the same thing, and is usable as the
right-hand-side of assignments.  For compatibility, GNU Fortran supports
the use of '%LOC' as an alias for the builtin 'LOC' with '-std=legacy'.
With this feature enabled the following two examples are equivalent:

     integer :: i, l
     l = %loc(i)
     call sub(l)

     integer :: i
     call sub(%loc(i))


File: gfortran.info,  Node: .XOR. operator,  Next: Bitwise logical operators,  Prev: %LOC as an rvalue,  Up: Extensions implemented in GNU Fortran

6.1.28 .XOR. operator
---------------------

GNU Fortran supports '.XOR.' as a logical operator with '-std=legacy'
for compatibility with legacy code.  '.XOR.' is equivalent to '.NEQV.'.
That is, the output is true if and only if the inputs differ.


File: gfortran.info,  Node: Bitwise logical operators,  Next: Extended I/O specifiers,  Prev: .XOR. operator,  Up: Extensions implemented in GNU Fortran

6.1.29 Bitwise logical operators
--------------------------------

With '-fdec', GNU Fortran relaxes the type constraints on logical
operators to allow integer operands, and performs the corresponding
bitwise operation instead.  This flag is for compatibility only, and
should be avoided in new code.  Consider:

       INTEGER :: i, j
       i = z'33'
       j = z'cc'
       print *, i .AND. j

   In this example, compiled with '-fdec', GNU Fortran will replace the
'.AND.' operation with a call to the intrinsic '*note IAND::' function,
yielding the bitwise-and of 'i' and 'j'.

   Note that this conversion will occur if at least one operand is of
integral type.  As a result, a logical operand will be converted to an
integer when the other operand is an integer in a logical operation.  In
this case, '.TRUE.' is converted to '1' and '.FALSE.' to '0'.

   Here is the mapping of logical operator to bitwise intrinsic used
with '-fdec':

Operator           Intrinsic          Bitwise operation
---------------------------------------------------------------------------
'.NOT.'            '*note NOT::'      complement
'.AND.'            '*note IAND::'     intersection
'.OR.'             '*note IOR::'      union
'.NEQV.'           '*note IEOR::'     exclusive or
'.EQV.'            '*note             complement of exclusive or
                   NOT::(*note
                   IEOR::)'


File: gfortran.info,  Node: Extended I/O specifiers,  Next: Legacy PARAMETER statements,  Prev: Bitwise logical operators,  Up: Extensions implemented in GNU Fortran

6.1.30 Extended I/O specifiers
------------------------------

GNU Fortran supports the additional legacy I/O specifiers
'CARRIAGECONTROL', 'READONLY', and 'SHARE' with the compile flag
'-fdec', for compatibility.

'CARRIAGECONTROL'
     The 'CARRIAGECONTROL' specifier allows a user to control line
     termination settings between output records for an I/O unit.  The
     specifier has no meaning for readonly files.  When
     'CARRAIGECONTROL' is specified upon opening a unit for formatted
     writing, the exact 'CARRIAGECONTROL' setting determines what
     characters to write between output records.  The syntax is:

          OPEN(..., CARRIAGECONTROL=cc)

     Where _cc_ is a character expression that evaluates to one of the
     following values:

     ''LIST''       One line feed between records (default)
     ''FORTRAN''    Legacy interpretation of the first character (see below)
     ''NONE''       No separator between records

     With 'CARRIAGECONTROL='FORTRAN'', when a record is written, the
     first character of the input record is not written, and instead
     determines the output record separator as follows:

     Leading character      Meaning                Output separating
                                                   character(s)
     ----------------------------------------------------------------------------
     ''+''                  Overprinting           Carriage return only
     ''-''                  New line               Line feed and carriage
                                                   return
     ''0''                  Skip line              Two line feeds and carriage
                                                   return
     ''1''                  New page               Form feed and carriage
                                                   return
     ''$''                  Prompting              Line feed (no carriage
                                                   return)
     'CHAR(0)'              Overprinting (no       None
                            advance)

'READONLY'
     The 'READONLY' specifier may be given upon opening a unit, and is
     equivalent to specifying 'ACTION='READ'', except that the file may
     not be deleted on close (i.e.  'CLOSE' with 'STATUS="DELETE"').
     The syntax is:

          OPEN(..., READONLY)

'SHARE'
     The 'SHARE' specifier allows system-level locking on a unit upon
     opening it for controlled access from multiple processes/threads.
     The 'SHARE' specifier has several forms:

          OPEN(..., SHARE=sh)
          OPEN(..., SHARED)
          OPEN(..., NOSHARED)

     Where _sh_ in the first form is a character expression that
     evaluates to a value as seen in the table below.  The latter two
     forms are aliases for particular values of _sh_:

     Explicit form          Short form             Meaning
     ----------------------------------------------------------------------------
     'SHARE='DENYRW''       'NOSHARED'             Exclusive (write) lock
     'SHARE='DENYNONE''     'SHARED'               Shared (read) lock

     In general only one process may hold an exclusive (write) lock for
     a given file at a time, whereas many processes may hold shared
     (read) locks for the same file.

     The behavior of locking may vary with your operating system.  On
     POSIX systems, locking is implemented with 'fcntl'.  Consult your
     corresponding operating system's manual pages for further details.
     Locking via 'SHARE=' is not supported on other systems.


File: gfortran.info,  Node: Legacy PARAMETER statements,  Next: Default exponents,  Prev: Extended I/O specifiers,  Up: Extensions implemented in GNU Fortran

6.1.31 Legacy PARAMETER statements
----------------------------------

For compatibility, GNU Fortran supports legacy PARAMETER statements
without parentheses with '-std=legacy'.  A warning is emitted if used
with '-std=gnu', and an error is acknowledged with a real Fortran
standard flag ('-std=f95', etc...).  These statements take the following
form:

     implicit real (E)
     parameter e = 2.718282
     real c
     parameter c = 3.0e8


File: gfortran.info,  Node: Default exponents,  Prev: Legacy PARAMETER statements,  Up: Extensions implemented in GNU Fortran

6.1.32 Default exponents
------------------------

For compatibility, GNU Fortran supports a default exponent of zero in
real constants with '-fdec'.  For example, '9e' would be interpreted as
'9e0', rather than an error.


File: gfortran.info,  Node: Extensions not implemented in GNU Fortran,  Prev: Extensions implemented in GNU Fortran,  Up: Extensions

6.2 Extensions not implemented in GNU Fortran
=============================================

The long history of the Fortran language, its wide use and broad
userbase, the large number of different compiler vendors and the lack of
some features crucial to users in the first standards have lead to the
existence of a number of important extensions to the language.  While
some of the most useful or popular extensions are supported by the GNU
Fortran compiler, not all existing extensions are supported.  This
section aims at listing these extensions and offering advice on how best
make code that uses them running with the GNU Fortran compiler.

* Menu:

* ENCODE and DECODE statements::
* Variable FORMAT expressions::
* Alternate complex function syntax::
* Volatile COMMON blocks::
* OPEN( ... NAME=)::
* Q edit descriptor::


File: gfortran.info,  Node: ENCODE and DECODE statements,  Next: Variable FORMAT expressions,  Up: Extensions not implemented in GNU Fortran

6.2.1 'ENCODE' and 'DECODE' statements
--------------------------------------

GNU Fortran does not support the 'ENCODE' and 'DECODE' statements.
These statements are best replaced by 'READ' and 'WRITE' statements
involving internal files ('CHARACTER' variables and arrays), which have
been part of the Fortran standard since Fortran 77.  For example,
replace a code fragment like

           INTEGER*1 LINE(80)
           REAL A, B, C
     c     ... Code that sets LINE
           DECODE (80, 9000, LINE) A, B, C
      9000 FORMAT (1X, 3(F10.5))

with the following:

           CHARACTER(LEN=80) LINE
           REAL A, B, C
     c     ... Code that sets LINE
           READ (UNIT=LINE, FMT=9000) A, B, C
      9000 FORMAT (1X, 3(F10.5))

   Similarly, replace a code fragment like

           INTEGER*1 LINE(80)
           REAL A, B, C
     c     ... Code that sets A, B and C
           ENCODE (80, 9000, LINE) A, B, C
      9000 FORMAT (1X, 'OUTPUT IS ', 3(F10.5))

with the following:

           CHARACTER(LEN=80) LINE
           REAL A, B, C
     c     ... Code that sets A, B and C
           WRITE (UNIT=LINE, FMT=9000) A, B, C
      9000 FORMAT (1X, 'OUTPUT IS ', 3(F10.5))


File: gfortran.info,  Node: Variable FORMAT expressions,  Next: Alternate complex function syntax,  Prev: ENCODE and DECODE statements,  Up: Extensions not implemented in GNU Fortran

6.2.2 Variable 'FORMAT' expressions
-----------------------------------

A variable 'FORMAT' expression is format statement which includes angle
brackets enclosing a Fortran expression: 'FORMAT(I<N>)'.  GNU Fortran
does not support this legacy extension.  The effect of variable format
expressions can be reproduced by using the more powerful (and standard)
combination of internal output and string formats.  For example, replace
a code fragment like this:

           WRITE(6,20) INT1
      20   FORMAT(I<N+1>)

with the following:

     c     Variable declaration
           CHARACTER(LEN=20) FMT
     c
     c     Other code here...
     c
           WRITE(FMT,'("(I", I0, ")")') N+1
           WRITE(6,FMT) INT1

or with:

     c     Variable declaration
           CHARACTER(LEN=20) FMT
     c
     c     Other code here...
     c
           WRITE(FMT,*) N+1
           WRITE(6,"(I" // ADJUSTL(FMT) // ")") INT1


File: gfortran.info,  Node: Alternate complex function syntax,  Next: Volatile COMMON blocks,  Prev: Variable FORMAT expressions,  Up: Extensions not implemented in GNU Fortran

6.2.3 Alternate complex function syntax
---------------------------------------

Some Fortran compilers, including 'g77', let the user declare complex
functions with the syntax 'COMPLEX FUNCTION name*16()', as well as
'COMPLEX*16 FUNCTION name()'.  Both are non-standard, legacy extensions.
'gfortran' accepts the latter form, which is more common, but not the
former.


File: gfortran.info,  Node: Volatile COMMON blocks,  Next: OPEN( ... NAME=),  Prev: Alternate complex function syntax,  Up: Extensions not implemented in GNU Fortran

6.2.4 Volatile 'COMMON' blocks
------------------------------

Some Fortran compilers, including 'g77', let the user declare 'COMMON'
with the 'VOLATILE' attribute.  This is invalid standard Fortran syntax
and is not supported by 'gfortran'.  Note that 'gfortran' accepts
'VOLATILE' variables in 'COMMON' blocks since revision 4.3.


File: gfortran.info,  Node: OPEN( ... NAME=),  Next: Q edit descriptor,  Prev: Volatile COMMON blocks,  Up: Extensions not implemented in GNU Fortran

6.2.5 'OPEN( ... NAME=)'
------------------------

Some Fortran compilers, including 'g77', let the user declare 'OPEN( ...
NAME=)'.  This is invalid standard Fortran syntax and is not supported
by 'gfortran'.  'OPEN( ... NAME=)' should be replaced with 'OPEN( ...
FILE=)'.


File: gfortran.info,  Node: Q edit descriptor,  Prev: OPEN( ... NAME=),  Up: Extensions not implemented in GNU Fortran

6.2.6 'Q' edit descriptor
-------------------------

Some Fortran compilers provide the 'Q' edit descriptor, which transfers
the number of characters left within an input record into an integer
variable.

   A direct replacement of the 'Q' edit descriptor is not available in
'gfortran'.  How to replicate its functionality using
standard-conforming code depends on what the intent of the original code
is.

   Options to replace 'Q' may be to read the whole line into a character
variable and then counting the number of non-blank characters left using
'LEN_TRIM'.  Another method may be to use formatted stream, read the
data up to the position where the 'Q' descriptor occurred, use 'INQUIRE'
to get the file position, count the characters up to the next 'NEW_LINE'
and then start reading from the position marked previously.


File: gfortran.info,  Node: Mixed-Language Programming,  Next: Coarray Programming,  Prev: Extensions,  Up: Top

7 Mixed-Language Programming
****************************

* Menu:

* Interoperability with C::
* GNU Fortran Compiler Directives::
* Non-Fortran Main Program::
* Naming and argument-passing conventions::

This chapter is about mixed-language interoperability, but also applies
if one links Fortran code compiled by different compilers.  In most
cases, use of the C Binding features of the Fortran 2003 standard is
sufficient, and their use is highly recommended.


File: gfortran.info,  Node: Interoperability with C,  Next: GNU Fortran Compiler Directives,  Up: Mixed-Language Programming

7.1 Interoperability with C
===========================

* Menu:

* Intrinsic Types::
* Derived Types and struct::
* Interoperable Global Variables::
* Interoperable Subroutines and Functions::
* Working with Pointers::
* Further Interoperability of Fortran with C::

Since Fortran 2003 (ISO/IEC 1539-1:2004(E)) there is a standardized way
to generate procedure and derived-type declarations and global variables
which are interoperable with C (ISO/IEC 9899:1999).  The 'bind(C)'
attribute has been added to inform the compiler that a symbol shall be
interoperable with C; also, some constraints are added.  Note, however,
that not all C features have a Fortran equivalent or vice versa.  For
instance, neither C's unsigned integers nor C's functions with variable
number of arguments have an equivalent in Fortran.

   Note that array dimensions are reversely ordered in C and that arrays
in C always start with index 0 while in Fortran they start by default
with 1.  Thus, an array declaration 'A(n,m)' in Fortran matches
'A[m][n]' in C and accessing the element 'A(i,j)' matches 'A[j-1][i-1]'.
The element following 'A(i,j)' (C: 'A[j-1][i-1]'; assuming i < n) in
memory is 'A(i+1,j)' (C: 'A[j-1][i]').


File: gfortran.info,  Node: Intrinsic Types,  Next: Derived Types and struct,  Up: Interoperability with C

7.1.1 Intrinsic Types
---------------------

In order to ensure that exactly the same variable type and kind is used
in C and Fortran, the named constants shall be used which are defined in
the 'ISO_C_BINDING' intrinsic module.  That module contains named
constants for kind parameters and character named constants for the
escape sequences in C. For a list of the constants, see *note
ISO_C_BINDING::.

   For logical types, please note that the Fortran standard only
guarantees interoperability between C99's '_Bool' and Fortran's
'C_Bool'-kind logicals and C99 defines that 'true' has the value 1 and
'false' the value 0.  Using any other integer value with GNU Fortran's
'LOGICAL' (with any kind parameter) gives an undefined result.  (Passing
other integer values than 0 and 1 to GCC's '_Bool' is also undefined,
unless the integer is explicitly or implicitly casted to '_Bool'.)


File: gfortran.info,  Node: Derived Types and struct,  Next: Interoperable Global Variables,  Prev: Intrinsic Types,  Up: Interoperability with C

7.1.2 Derived Types and struct
------------------------------

For compatibility of derived types with 'struct', one needs to use the
'BIND(C)' attribute in the type declaration.  For instance, the
following type declaration

      USE ISO_C_BINDING
      TYPE, BIND(C) :: myType
        INTEGER(C_INT) :: i1, i2
        INTEGER(C_SIGNED_CHAR) :: i3
        REAL(C_DOUBLE) :: d1
        COMPLEX(C_FLOAT_COMPLEX) :: c1
        CHARACTER(KIND=C_CHAR) :: str(5)
      END TYPE

   matches the following 'struct' declaration in C

      struct {
        int i1, i2;
        /* Note: "char" might be signed or unsigned.  */
        signed char i3;
        double d1;
        float _Complex c1;
        char str[5];
      } myType;

   Derived types with the C binding attribute shall not have the
'sequence' attribute, type parameters, the 'extends' attribute, nor
type-bound procedures.  Every component must be of interoperable type
and kind and may not have the 'pointer' or 'allocatable' attribute.  The
names of the components are irrelevant for interoperability.

   As there exist no direct Fortran equivalents, neither unions nor
structs with bit field or variable-length array members are
interoperable.


File: gfortran.info,  Node: Interoperable Global Variables,  Next: Interoperable Subroutines and Functions,  Prev: Derived Types and struct,  Up: Interoperability with C

7.1.3 Interoperable Global Variables
------------------------------------

Variables can be made accessible from C using the C binding attribute,
optionally together with specifying a binding name.  Those variables
have to be declared in the declaration part of a 'MODULE', be of
interoperable type, and have neither the 'pointer' nor the 'allocatable'
attribute.

       MODULE m
         USE myType_module
         USE ISO_C_BINDING
         integer(C_INT), bind(C, name="_MyProject_flags") :: global_flag
         type(myType), bind(C) :: tp
       END MODULE

   Here, '_MyProject_flags' is the case-sensitive name of the variable
as seen from C programs while 'global_flag' is the case-insensitive name
as seen from Fortran.  If no binding name is specified, as for TP, the C
binding name is the (lowercase) Fortran binding name.  If a binding name
is specified, only a single variable may be after the double colon.
Note of warning: You cannot use a global variable to access ERRNO of the
C library as the C standard allows it to be a macro.  Use the 'IERRNO'
intrinsic (GNU extension) instead.


File: gfortran.info,  Node: Interoperable Subroutines and Functions,  Next: Working with Pointers,  Prev: Interoperable Global Variables,  Up: Interoperability with C

7.1.4 Interoperable Subroutines and Functions
---------------------------------------------

Subroutines and functions have to have the 'BIND(C)' attribute to be
compatible with C. The dummy argument declaration is relatively
straightforward.  However, one needs to be careful because C uses
call-by-value by default while Fortran behaves usually similar to
call-by-reference.  Furthermore, strings and pointers are handled
differently.  Note that in Fortran 2003 and 2008 only explicit size and
assumed-size arrays are supported but not assumed-shape or
deferred-shape (i.e.  allocatable or pointer) arrays.  However, those
are allowed since the Technical Specification 29113, see *note Further
Interoperability of Fortran with C::

   To pass a variable by value, use the 'VALUE' attribute.  Thus, the
following C prototype

     int func(int i, int *j)

   matches the Fortran declaration

       integer(c_int) function func(i,j)
         use iso_c_binding, only: c_int
         integer(c_int), VALUE :: i
         integer(c_int) :: j

   Note that pointer arguments also frequently need the 'VALUE'
attribute, see *note Working with Pointers::.

   Strings are handled quite differently in C and Fortran.  In C a
string is a 'NUL'-terminated array of characters while in Fortran each
string has a length associated with it and is thus not terminated (by
e.g.  'NUL').  For example, if one wants to use the following C
function,

       #include <stdio.h>
       void print_C(char *string) /* equivalent: char string[]  */
       {
          printf("%s\n", string);
       }

   to print "Hello World" from Fortran, one can call it using

       use iso_c_binding, only: C_CHAR, C_NULL_CHAR
       interface
         subroutine print_c(string) bind(C, name="print_C")
           use iso_c_binding, only: c_char
           character(kind=c_char) :: string(*)
         end subroutine print_c
       end interface
       call print_c(C_CHAR_"Hello World"//C_NULL_CHAR)

   As the example shows, one needs to ensure that the string is 'NUL'
terminated.  Additionally, the dummy argument STRING of 'print_C' is a
length-one assumed-size array; using 'character(len=*)' is not allowed.
The example above uses 'c_char_"Hello World"' to ensure the string
literal has the right type; typically the default character kind and
'c_char' are the same and thus '"Hello World"' is equivalent.  However,
the standard does not guarantee this.

   The use of strings is now further illustrated using the C library
function 'strncpy', whose prototype is

       char *strncpy(char *restrict s1, const char *restrict s2, size_t n);

   The function 'strncpy' copies at most N characters from string S2 to
S1 and returns S1.  In the following example, we ignore the return
value:

       use iso_c_binding
       implicit none
       character(len=30) :: str,str2
       interface
         ! Ignore the return value of strncpy -> subroutine
         ! "restrict" is always assumed if we do not pass a pointer
         subroutine strncpy(dest, src, n) bind(C)
           import
           character(kind=c_char),  intent(out) :: dest(*)
           character(kind=c_char),  intent(in)  :: src(*)
           integer(c_size_t), value, intent(in) :: n
         end subroutine strncpy
       end interface
       str = repeat('X',30) ! Initialize whole string with 'X'
       call strncpy(str, c_char_"Hello World"//C_NULL_CHAR, &
                    len(c_char_"Hello World",kind=c_size_t))
       print '(a)', str ! prints: "Hello WorldXXXXXXXXXXXXXXXXXXX"
       end

   The intrinsic procedures are described in *note Intrinsic
Procedures::.


File: gfortran.info,  Node: Working with Pointers,  Next: Further Interoperability of Fortran with C,  Prev: Interoperable Subroutines and Functions,  Up: Interoperability with C

7.1.5 Working with Pointers
---------------------------

C pointers are represented in Fortran via the special opaque derived
type 'type(c_ptr)' (with private components).  Thus one needs to use
intrinsic conversion procedures to convert from or to C pointers.

   For some applications, using an assumed type ('TYPE(*)') can be an
alternative to a C pointer; see *note Further Interoperability of
Fortran with C::.

   For example,

       use iso_c_binding
       type(c_ptr) :: cptr1, cptr2
       integer, target :: array(7), scalar
       integer, pointer :: pa(:), ps
       cptr1 = c_loc(array(1)) ! The programmer needs to ensure that the
                               ! array is contiguous if required by the C
                               ! procedure
       cptr2 = c_loc(scalar)
       call c_f_pointer(cptr2, ps)
       call c_f_pointer(cptr2, pa, shape=[7])

   When converting C to Fortran arrays, the one-dimensional 'SHAPE'
argument has to be passed.

   If a pointer is a dummy-argument of an interoperable procedure, it
usually has to be declared using the 'VALUE' attribute.  'void*' matches
'TYPE(C_PTR), VALUE', while 'TYPE(C_PTR)' alone matches 'void**'.

   Procedure pointers are handled analogously to pointers; the C type is
'TYPE(C_FUNPTR)' and the intrinsic conversion procedures are
'C_F_PROCPOINTER' and 'C_FUNLOC'.

   Let us consider two examples of actually passing a procedure pointer
from C to Fortran and vice versa.  Note that these examples are also
very similar to passing ordinary pointers between both languages.
First, consider this code in C:

     /* Procedure implemented in Fortran.  */
     void get_values (void (*)(double));

     /* Call-back routine we want called from Fortran.  */
     void
     print_it (double x)
     {
       printf ("Number is %f.\n", x);
     }

     /* Call Fortran routine and pass call-back to it.  */
     void
     foobar ()
     {
       get_values (&print_it);
     }

   A matching implementation for 'get_values' in Fortran, that correctly
receives the procedure pointer from C and is able to call it, is given
in the following 'MODULE':

     MODULE m
       IMPLICIT NONE

       ! Define interface of call-back routine.
       ABSTRACT INTERFACE
         SUBROUTINE callback (x)
           USE, INTRINSIC :: ISO_C_BINDING
           REAL(KIND=C_DOUBLE), INTENT(IN), VALUE :: x
         END SUBROUTINE callback
       END INTERFACE

     CONTAINS

       ! Define C-bound procedure.
       SUBROUTINE get_values (cproc) BIND(C)
         USE, INTRINSIC :: ISO_C_BINDING
         TYPE(C_FUNPTR), INTENT(IN), VALUE :: cproc

         PROCEDURE(callback), POINTER :: proc

         ! Convert C to Fortran procedure pointer.
         CALL C_F_PROCPOINTER (cproc, proc)

         ! Call it.
         CALL proc (1.0_C_DOUBLE)
         CALL proc (-42.0_C_DOUBLE)
         CALL proc (18.12_C_DOUBLE)
       END SUBROUTINE get_values

     END MODULE m

   Next, we want to call a C routine that expects a procedure pointer
argument and pass it a Fortran procedure (which clearly must be
interoperable!).  Again, the C function may be:

     int
     call_it (int (*func)(int), int arg)
     {
       return func (arg);
     }

   It can be used as in the following Fortran code:

     MODULE m
       USE, INTRINSIC :: ISO_C_BINDING
       IMPLICIT NONE

       ! Define interface of C function.
       INTERFACE
         INTEGER(KIND=C_INT) FUNCTION call_it (func, arg) BIND(C)
           USE, INTRINSIC :: ISO_C_BINDING
           TYPE(C_FUNPTR), INTENT(IN), VALUE :: func
           INTEGER(KIND=C_INT), INTENT(IN), VALUE :: arg
         END FUNCTION call_it
       END INTERFACE

     CONTAINS

       ! Define procedure passed to C function.
       ! It must be interoperable!
       INTEGER(KIND=C_INT) FUNCTION double_it (arg) BIND(C)
         INTEGER(KIND=C_INT), INTENT(IN), VALUE :: arg
         double_it = arg + arg
       END FUNCTION double_it

       ! Call C function.
       SUBROUTINE foobar ()
         TYPE(C_FUNPTR) :: cproc
         INTEGER(KIND=C_INT) :: i

         ! Get C procedure pointer.
         cproc = C_FUNLOC (double_it)

         ! Use it.
         DO i = 1_C_INT, 10_C_INT
           PRINT *, call_it (cproc, i)
         END DO
       END SUBROUTINE foobar

     END MODULE m


File: gfortran.info,  Node: Further Interoperability of Fortran with C,  Prev: Working with Pointers,  Up: Interoperability with C

7.1.6 Further Interoperability of Fortran with C
------------------------------------------------

The Technical Specification ISO/IEC TS 29113:2012 on further
interoperability of Fortran with C extends the interoperability support
of Fortran 2003 and Fortran 2008.  Besides removing some restrictions
and constraints, it adds assumed-type ('TYPE(*)') and assumed-rank
('dimension') variables and allows for interoperability of
assumed-shape, assumed-rank and deferred-shape arrays, including
allocatables and pointers.

   Note: Currently, GNU Fortran does not use internally the array
descriptor (dope vector) as specified in the Technical Specification,
but uses an array descriptor with different fields.  Assumed type and
assumed rank formal arguments are converted in the library to the
specified form.  The ISO_Fortran_binding API functions (also Fortran
2018 18.4) are implemented in libgfortran.  Alternatively, the Chasm
Language Interoperability Tools,
<http://chasm-interop.sourceforge.net/>, provide an interface to GNU
Fortran's array descriptor.

   The Technical Specification adds the following new features, which
are supported by GNU Fortran:

   * The 'ASYNCHRONOUS' attribute has been clarified and extended to
     allow its use with asynchronous communication in user-provided
     libraries such as in implementations of the Message Passing
     Interface specification.

   * Many constraints have been relaxed, in particular for the 'C_LOC'
     and 'C_F_POINTER' intrinsics.

   * The 'OPTIONAL' attribute is now allowed for dummy arguments; an
     absent argument matches a 'NULL' pointer.

   * Assumed types ('TYPE(*)') have been added, which may only be used
     for dummy arguments.  They are unlimited polymorphic but contrary
     to 'CLASS(*)' they do not contain any type information, similar to
     C's 'void *' pointers.  Expressions of any type and kind can be
     passed; thus, it can be used as replacement for 'TYPE(C_PTR)',
     avoiding the use of 'C_LOC' in the caller.

     Note, however, that 'TYPE(*)' only accepts scalar arguments, unless
     the 'DIMENSION' is explicitly specified.  As 'DIMENSION(*)' only
     supports array (including array elements) but no scalars, it is not
     a full replacement for 'C_LOC'.  On the other hand, assumed-type
     assumed-rank dummy arguments ('TYPE(*), DIMENSION(..)') allow for
     both scalars and arrays, but require special code on the callee
     side to handle the array descriptor.

   * Assumed-rank arrays ('DIMENSION(..)') as dummy argument allow that
     scalars and arrays of any rank can be passed as actual argument.
     As the Technical Specification does not provide for direct means to
     operate with them, they have to be used either from the C side or
     be converted using 'C_LOC' and 'C_F_POINTER' to scalars or arrays
     of a specific rank.  The rank can be determined using the 'RANK'
     intrinisic.

   Currently unimplemented:

   * GNU Fortran always uses an array descriptor, which does not match
     the one of the Technical Specification.  The
     'ISO_Fortran_binding.h' header file and the C functions it
     specifies are not available.

   * Using assumed-shape, assumed-rank and deferred-shape arrays in
     'BIND(C)' procedures is not fully supported.  In particular, C
     interoperable strings of other length than one are not supported as
     this requires the new array descriptor.


File: gfortran.info,  Node: GNU Fortran Compiler Directives,  Next: Non-Fortran Main Program,  Prev: Interoperability with C,  Up: Mixed-Language Programming

7.2 GNU Fortran Compiler Directives
===================================

* Menu:

* ATTRIBUTES directive::
* UNROLL directive::
* BUILTIN directive::
* IVDEP directive::
* VECTOR directive::
* NOVECTOR directive::


File: gfortran.info,  Node: ATTRIBUTES directive,  Next: UNROLL directive,  Up: GNU Fortran Compiler Directives

7.2.1 ATTRIBUTES directive
--------------------------

The Fortran standard describes how a conforming program shall behave;
however, the exact implementation is not standardized.  In order to
allow the user to choose specific implementation details, compiler
directives can be used to set attributes of variables and procedures
which are not part of the standard.  Whether a given attribute is
supported and its exact effects depend on both the operating system and
on the processor; see *note C Extensions: (gcc)Top. for details.

   For procedures and procedure pointers, the following attributes can
be used to change the calling convention:

   * 'CDECL' - standard C calling convention
   * 'STDCALL' - convention where the called procedure pops the stack
   * 'FASTCALL' - part of the arguments are passed via registers instead
     using the stack

   Besides changing the calling convention, the attributes also
influence the decoration of the symbol name, e.g., by a leading
underscore or by a trailing at-sign followed by the number of bytes on
the stack.  When assigning a procedure to a procedure pointer, both
should use the same calling convention.

   On some systems, procedures and global variables (module variables
and 'COMMON' blocks) need special handling to be accessible when they
are in a shared library.  The following attributes are available:

   * 'DLLEXPORT' - provide a global pointer to a pointer in the DLL
   * 'DLLIMPORT' - reference the function or variable using a global
     pointer

   For dummy arguments, the 'NO_ARG_CHECK' attribute can be used; in
other compilers, it is also known as 'IGNORE_TKR'.  For dummy arguments
with this attribute actual arguments of any type and kind (similar to
'TYPE(*)'), scalars and arrays of any rank (no equivalent in Fortran
standard) are accepted.  As with 'TYPE(*)', the argument is unlimited
polymorphic and no type information is available.  Additionally, the
argument may only be passed to dummy arguments with the 'NO_ARG_CHECK'
attribute and as argument to the 'PRESENT' intrinsic function and to
'C_LOC' of the 'ISO_C_BINDING' module.

   Variables with 'NO_ARG_CHECK' attribute shall be of assumed-type
('TYPE(*)'; recommended) or of type 'INTEGER', 'LOGICAL', 'REAL' or
'COMPLEX'.  They shall not have the 'ALLOCATE', 'CODIMENSION',
'INTENT(OUT)', 'POINTER' or 'VALUE' attribute; furthermore, they shall
be either scalar or of assumed-size ('dimension(*)').  As 'TYPE(*)', the
'NO_ARG_CHECK' attribute requires an explicit interface.

   * 'NO_ARG_CHECK' - disable the type, kind and rank checking

   The attributes are specified using the syntax

   '!GCC$ ATTRIBUTES' ATTRIBUTE-LIST '::' VARIABLE-LIST

   where in free-form source code only whitespace is allowed before
'!GCC$' and in fixed-form source code '!GCC$', 'cGCC$' or '*GCC$' shall
start in the first column.

   For procedures, the compiler directives shall be placed into the body
of the procedure; for variables and procedure pointers, they shall be in
the same declaration part as the variable or procedure pointer.


File: gfortran.info,  Node: UNROLL directive,  Next: BUILTIN directive,  Prev: ATTRIBUTES directive,  Up: GNU Fortran Compiler Directives

7.2.2 UNROLL directive
----------------------

The syntax of the directive is

   '!GCC$ unroll N'

   You can use this directive to control how many times a loop should be
unrolled.  It must be placed immediately before a 'DO' loop and applies
only to the loop that follows.  N is an integer constant specifying the
unrolling factor.  The values of 0 and 1 block any unrolling of the
loop.


File: gfortran.info,  Node: BUILTIN directive,  Next: IVDEP directive,  Prev: UNROLL directive,  Up: GNU Fortran Compiler Directives

7.2.3 BUILTIN directive
-----------------------

The syntax of the directive is

   '!GCC$ BUILTIN (B) attributes simd FLAGS IF('target')'

   You can use this directive to define which middle-end built-ins
provide vector implementations.  'B' is name of the middle-end built-in.
'FLAGS' are optional and must be either "(inbranch)" or "(notinbranch)".
'IF' statement is optional and is used to filter multilib ABIs for the
built-in that should be vectorized.  Example usage:

     !GCC$ builtin (sinf) attributes simd (notinbranch) if('x86_64')

   The purpose of the directive is to provide an API among the GCC
compiler and the GNU C Library which would define vector implementations
of math routines.


File: gfortran.info,  Node: IVDEP directive,  Next: VECTOR directive,  Prev: BUILTIN directive,  Up: GNU Fortran Compiler Directives

7.2.4 IVDEP directive
---------------------

The syntax of the directive is

   '!GCC$ ivdep'

   This directive tells the compiler to ignore vector dependencies in
the following loop.  It must be placed immediately before a 'DO' loop
and applies only to the loop that follows.

   Sometimes the compiler may not have sufficient information to decide
whether a particular loop is vectorizable due to potential dependencies
between iterations.  The purpose of the directive is to tell the
compiler that vectorization is safe.

   This directive is intended for annotation of existing code.  For new
code it is recommended to consider OpenMP SIMD directives as potential
alternative.


File: gfortran.info,  Node: VECTOR directive,  Next: NOVECTOR directive,  Prev: IVDEP directive,  Up: GNU Fortran Compiler Directives

7.2.5 VECTOR directive
----------------------

The syntax of the directive is

   '!GCC$ vector'

   This directive tells the compiler to vectorize the following loop.
It must be placed immediately before a 'DO' loop and applies only to the
loop that follows.


File: gfortran.info,  Node: NOVECTOR directive,  Prev: VECTOR directive,  Up: GNU Fortran Compiler Directives

7.2.6 NOVECTOR directive
------------------------

The syntax of the directive is

   '!GCC$ novector'

   This directive tells the compiler to not vectorize the following
loop.  It must be placed immediately before a 'DO' loop and applies only
to the loop that follows.


File: gfortran.info,  Node: Non-Fortran Main Program,  Next: Naming and argument-passing conventions,  Prev: GNU Fortran Compiler Directives,  Up: Mixed-Language Programming

7.3 Non-Fortran Main Program
============================

* Menu:

* _gfortran_set_args:: Save command-line arguments
* _gfortran_set_options:: Set library option flags
* _gfortran_set_convert:: Set endian conversion
* _gfortran_set_record_marker:: Set length of record markers
* _gfortran_set_fpe:: Set when a Floating Point Exception should be raised
* _gfortran_set_max_subrecord_length:: Set subrecord length

Even if you are doing mixed-language programming, it is very likely that
you do not need to know or use the information in this section.  Since
it is about the internal structure of GNU Fortran, it may also change in
GCC minor releases.

   When you compile a 'PROGRAM' with GNU Fortran, a function with the
name 'main' (in the symbol table of the object file) is generated, which
initializes the libgfortran library and then calls the actual program
which uses the name 'MAIN__', for historic reasons.  If you link GNU
Fortran compiled procedures to, e.g., a C or C++ program or to a Fortran
program compiled by a different compiler, the libgfortran library is not
initialized and thus a few intrinsic procedures do not work properly,
e.g.  those for obtaining the command-line arguments.

   Therefore, if your 'PROGRAM' is not compiled with GNU Fortran and the
GNU Fortran compiled procedures require intrinsics relying on the
library initialization, you need to initialize the library yourself.
Using the default options, gfortran calls '_gfortran_set_args' and
'_gfortran_set_options'.  The initialization of the former is needed if
the called procedures access the command line (and for backtracing); the
latter sets some flags based on the standard chosen or to enable
backtracing.  In typical programs, it is not necessary to call any
initialization function.

   If your 'PROGRAM' is compiled with GNU Fortran, you shall not call
any of the following functions.  The libgfortran initialization
functions are shown in C syntax but using C bindings they are also
accessible from Fortran.


File: gfortran.info,  Node: _gfortran_set_args,  Next: _gfortran_set_options,  Up: Non-Fortran Main Program

7.3.1 '_gfortran_set_args' -- Save command-line arguments
---------------------------------------------------------

_Description_:
     '_gfortran_set_args' saves the command-line arguments; this
     initialization is required if any of the command-line intrinsics is
     called.  Additionally, it shall be called if backtracing is enabled
     (see '_gfortran_set_options').

_Syntax_:
     'void _gfortran_set_args (int argc, char *argv[])'

_Arguments_:
     ARGC        number of command line argument strings
     ARGV        the command-line argument strings; argv[0] is
                 the pathname of the executable itself.

_Example_:
          int main (int argc, char *argv[])
          {
            /* Initialize libgfortran.  */
            _gfortran_set_args (argc, argv);
            return 0;
          }


File: gfortran.info,  Node: _gfortran_set_options,  Next: _gfortran_set_convert,  Prev: _gfortran_set_args,  Up: Non-Fortran Main Program

7.3.2 '_gfortran_set_options' -- Set library option flags
---------------------------------------------------------

_Description_:
     '_gfortran_set_options' sets several flags related to the Fortran
     standard to be used, whether backtracing should be enabled and
     whether range checks should be performed.  The syntax allows for
     upward compatibility since the number of passed flags is specified;
     for non-passed flags, the default value is used.  See also *note
     Code Gen Options::.  Please note that not all flags are actually
     used.

_Syntax_:
     'void _gfortran_set_options (int num, int options[])'

_Arguments_:
     NUM         number of options passed
     ARGV        The list of flag values

_option flag list_:
     OPTION[0]   Allowed standard; can give run-time errors if
                 e.g.  an input-output edit descriptor is invalid
                 in a given standard.  Possible values are
                 (bitwise or-ed) 'GFC_STD_F77' (1),
                 'GFC_STD_F95_OBS' (2), 'GFC_STD_F95_DEL' (4),
                 'GFC_STD_F95' (8), 'GFC_STD_F2003' (16),
                 'GFC_STD_GNU' (32), 'GFC_STD_LEGACY' (64),
                 'GFC_STD_F2008' (128), 'GFC_STD_F2008_OBS'
                 (256), 'GFC_STD_F2008_TS' (512), 'GFC_STD_F2018'
                 (1024), 'GFC_STD_F2018_OBS' (2048), and
                 'GFC_STD=F2018_DEL' (4096).  Default:
                 'GFC_STD_F95_OBS | GFC_STD_F95_DEL | GFC_STD_F95
                 | GFC_STD_F2003 | GFC_STD_F2008 |
                 GFC_STD_F2008_TS | GFC_STD_F2008_OBS |
                 GFC_STD_F77 | GFC_STD_F2018 | GFC_STD_F2018_OBS
                 | GFC_STD_F2018_DEL | GFC_STD_GNU |
                 GFC_STD_LEGACY'.
     OPTION[1]   Standard-warning flag; prints a warning to
                 standard error.  Default: 'GFC_STD_F95_DEL |
                 GFC_STD_LEGACY'.
     OPTION[2]   If non zero, enable pedantic checking.  Default:
                 off.
     OPTION[3]   Unused.
     OPTION[4]   If non zero, enable backtracing on run-time
                 errors.  Default: off.  (Default in the
                 compiler: on.)  Note: Installs a signal handler
                 and requires command-line initialization using
                 '_gfortran_set_args'.
     OPTION[5]   If non zero, supports signed zeros.  Default:
                 enabled.
     OPTION[6]   Enables run-time checking.  Possible values are
                 (bitwise or-ed): GFC_RTCHECK_BOUNDS (1),
                 GFC_RTCHECK_ARRAY_TEMPS (2),
                 GFC_RTCHECK_RECURSION (4), GFC_RTCHECK_DO (16),
                 GFC_RTCHECK_POINTER (32).  Default: disabled.
     OPTION[7]   Unused.
     OPTION[8]   Show a warning when invoking 'STOP' and 'ERROR
                 STOP' if a floating-point exception occurred.
                 Possible values are (bitwise or-ed)
                 'GFC_FPE_INVALID' (1), 'GFC_FPE_DENORMAL' (2),
                 'GFC_FPE_ZERO' (4), 'GFC_FPE_OVERFLOW' (8),
                 'GFC_FPE_UNDERFLOW' (16), 'GFC_FPE_INEXACT'
                 (32).  Default: None (0).  (Default in the
                 compiler: 'GFC_FPE_INVALID | GFC_FPE_DENORMAL |
                 GFC_FPE_ZERO | GFC_FPE_OVERFLOW |
                 GFC_FPE_UNDERFLOW'.)

_Example_:
            /* Use gfortran 4.9 default options.  */
            static int options[] = {68, 511, 0, 0, 1, 1, 0, 0, 31};
            _gfortran_set_options (9, &options);


File: gfortran.info,  Node: _gfortran_set_convert,  Next: _gfortran_set_record_marker,  Prev: _gfortran_set_options,  Up: Non-Fortran Main Program

7.3.3 '_gfortran_set_convert' -- Set endian conversion
------------------------------------------------------

_Description_:
     '_gfortran_set_convert' set the representation of data for
     unformatted files.

_Syntax_:
     'void _gfortran_set_convert (int conv)'

_Arguments_:
     CONV        Endian conversion, possible values:
                 GFC_CONVERT_NATIVE (0, default),
                 GFC_CONVERT_SWAP (1), GFC_CONVERT_BIG (2),
                 GFC_CONVERT_LITTLE (3).

_Example_:
          int main (int argc, char *argv[])
          {
            /* Initialize libgfortran.  */
            _gfortran_set_args (argc, argv);
            _gfortran_set_convert (1);
            return 0;
          }


File: gfortran.info,  Node: _gfortran_set_record_marker,  Next: _gfortran_set_fpe,  Prev: _gfortran_set_convert,  Up: Non-Fortran Main Program

7.3.4 '_gfortran_set_record_marker' -- Set length of record markers
-------------------------------------------------------------------

_Description_:
     '_gfortran_set_record_marker' sets the length of record markers for
     unformatted files.

_Syntax_:
     'void _gfortran_set_record_marker (int val)'

_Arguments_:
     VAL         Length of the record marker; valid values are 4
                 and 8.  Default is 4.

_Example_:
          int main (int argc, char *argv[])
          {
            /* Initialize libgfortran.  */
            _gfortran_set_args (argc, argv);
            _gfortran_set_record_marker (8);
            return 0;
          }


File: gfortran.info,  Node: _gfortran_set_fpe,  Next: _gfortran_set_max_subrecord_length,  Prev: _gfortran_set_record_marker,  Up: Non-Fortran Main Program

7.3.5 '_gfortran_set_fpe' -- Enable floating point exception traps
------------------------------------------------------------------

_Description_:
     '_gfortran_set_fpe' enables floating point exception traps for the
     specified exceptions.  On most systems, this will result in a
     SIGFPE signal being sent and the program being aborted.

_Syntax_:
     'void _gfortran_set_fpe (int val)'

_Arguments_:
     OPTION[0]   IEEE exceptions.  Possible values are (bitwise
                 or-ed) zero (0, default) no trapping,
                 'GFC_FPE_INVALID' (1), 'GFC_FPE_DENORMAL' (2),
                 'GFC_FPE_ZERO' (4), 'GFC_FPE_OVERFLOW' (8),
                 'GFC_FPE_UNDERFLOW' (16), and 'GFC_FPE_INEXACT'
                 (32).

_Example_:
          int main (int argc, char *argv[])
          {
            /* Initialize libgfortran.  */
            _gfortran_set_args (argc, argv);
            /* FPE for invalid operations such as SQRT(-1.0).  */
            _gfortran_set_fpe (1);
            return 0;
          }


File: gfortran.info,  Node: _gfortran_set_max_subrecord_length,  Prev: _gfortran_set_fpe,  Up: Non-Fortran Main Program

7.3.6 '_gfortran_set_max_subrecord_length' -- Set subrecord length
------------------------------------------------------------------

_Description_:
     '_gfortran_set_max_subrecord_length' set the maximum length for a
     subrecord.  This option only makes sense for testing and debugging
     of unformatted I/O.

_Syntax_:
     'void _gfortran_set_max_subrecord_length (int val)'

_Arguments_:
     VAL         the maximum length for a subrecord; the maximum
                 permitted value is 2147483639, which is also the
                 default.

_Example_:
          int main (int argc, char *argv[])
          {
            /* Initialize libgfortran.  */
            _gfortran_set_args (argc, argv);
            _gfortran_set_max_subrecord_length (8);
            return 0;
          }


File: gfortran.info,  Node: Naming and argument-passing conventions,  Prev: Non-Fortran Main Program,  Up: Mixed-Language Programming

7.4 Naming and argument-passing conventions
===========================================

This section gives an overview about the naming convention of procedures
and global variables and about the argument passing conventions used by
GNU Fortran.  If a C binding has been specified, the naming convention
and some of the argument-passing conventions change.  If possible,
mixed-language and mixed-compiler projects should use the better defined
C binding for interoperability.  See *note Interoperability with C::.

* Menu:

* Naming conventions::
* Argument passing conventions::


File: gfortran.info,  Node: Naming conventions,  Next: Argument passing conventions,  Up: Naming and argument-passing conventions

7.4.1 Naming conventions
------------------------

According the Fortran standard, valid Fortran names consist of a letter
between 'A' to 'Z', 'a' to 'z', digits '0', '1' to '9' and underscores
('_') with the restriction that names may only start with a letter.  As
vendor extension, the dollar sign ('$') is additionally permitted with
the option '-fdollar-ok', but not as first character and only if the
target system supports it.

   By default, the procedure name is the lower-cased Fortran name with
an appended underscore ('_'); using '-fno-underscoring' no underscore is
appended while '-fsecond-underscore' appends two underscores.  Depending
on the target system and the calling convention, the procedure might be
additionally dressed; for instance, on 32bit Windows with 'stdcall', an
at-sign '@' followed by an integer number is appended.  For the changing
the calling convention, see *note GNU Fortran Compiler Directives::.

   For common blocks, the same convention is used, i.e.  by default an
underscore is appended to the lower-cased Fortran name.  Blank commons
have the name '__BLNK__'.

   For procedures and variables declared in the specification space of a
module, the name is formed by '__', followed by the lower-cased module
name, '_MOD_', and the lower-cased Fortran name.  Note that no
underscore is appended.


File: gfortran.info,  Node: Argument passing conventions,  Prev: Naming conventions,  Up: Naming and argument-passing conventions

7.4.2 Argument passing conventions
----------------------------------

Subroutines do not return a value (matching C99's 'void') while
functions either return a value as specified in the platform ABI or the
result variable is passed as hidden argument to the function and no
result is returned.  A hidden result variable is used when the result
variable is an array or of type 'CHARACTER'.

   Arguments are passed according to the platform ABI. In particular,
complex arguments might not be compatible to a struct with two real
components for the real and imaginary part.  The argument passing
matches the one of C99's '_Complex'.  Functions with scalar complex
result variables return their value and do not use a by-reference
argument.  Note that with the '-ff2c' option, the argument passing is
modified and no longer completely matches the platform ABI. Some other
Fortran compilers use 'f2c' semantic by default; this might cause
problems with interoperablility.

   GNU Fortran passes most arguments by reference, i.e.  by passing a
pointer to the data.  Note that the compiler might use a temporary
variable into which the actual argument has been copied, if required
semantically (copy-in/copy-out).

   For arguments with 'ALLOCATABLE' and 'POINTER' attribute (including
procedure pointers), a pointer to the pointer is passed such that the
pointer address can be modified in the procedure.

   For dummy arguments with the 'VALUE' attribute: Scalar arguments of
the type 'INTEGER', 'LOGICAL', 'REAL' and 'COMPLEX' are passed by value
according to the platform ABI. (As vendor extension and not recommended,
using '%VAL()' in the call to a procedure has the same effect.)  For
'TYPE(C_PTR)' and procedure pointers, the pointer itself is passed such
that it can be modified without affecting the caller.

   For Boolean ('LOGICAL') arguments, please note that GCC expects only
the integer value 0 and 1.  If a GNU Fortran 'LOGICAL' variable contains
another integer value, the result is undefined.  As some other Fortran
compilers use -1 for '.TRUE.', extra care has to be taken - such as
passing the value as 'INTEGER'.  (The same value restriction also
applies to other front ends of GCC, e.g.  to GCC's C99 compiler for
'_Bool' or GCC's Ada compiler for 'Boolean'.)

   For arguments of 'CHARACTER' type, the character length is passed as
a hidden argument at the end of the argument list.  For deferred-length
strings, the value is passed by reference, otherwise by value.  The
character length has the C type 'size_t' (or 'INTEGER(kind=C_SIZE_T)' in
Fortran).  Note that this is different to older versions of the GNU
Fortran compiler, where the type of the hidden character length argument
was a C 'int'.  In order to retain compatibility with older versions,
one can e.g.  for the following Fortran procedure

     subroutine fstrlen (s, a)
        character(len=*) :: s
        integer :: a
        print*, len(s)
     end subroutine fstrlen

   define the corresponding C prototype as follows:

     #if __GNUC__ > 7
     typedef size_t fortran_charlen_t;
     #else
     typedef int fortran_charlen_t;
     #endif

     void fstrlen_ (char*, int*, fortran_charlen_t);

   In order to avoid such compiler-specific details, for new code it is
instead recommended to use the ISO_C_BINDING feature.

   Note with C binding, 'CHARACTER(len=1)' result variables are returned
according to the platform ABI and no hidden length argument is used for
dummy arguments; with 'VALUE', those variables are passed by value.

   For 'OPTIONAL' dummy arguments, an absent argument is denoted by a
NULL pointer, except for scalar dummy arguments of type 'INTEGER',
'LOGICAL', 'REAL' and 'COMPLEX' which have the 'VALUE' attribute.  For
those, a hidden Boolean argument ('logical(kind=C_bool),value') is used
to indicate whether the argument is present.

   Arguments which are assumed-shape, assumed-rank or deferred-rank
arrays or, with '-fcoarray=lib', allocatable scalar coarrays use an
array descriptor.  All other arrays pass the address of the first
element of the array.  With '-fcoarray=lib', the token and the offset
belonging to nonallocatable coarrays dummy arguments are passed as
hidden argument along the character length hidden arguments.  The token
is an oparque pointer identifying the coarray and the offset is a
passed-by-value integer of kind 'C_PTRDIFF_T', denoting the byte offset
between the base address of the coarray and the passed scalar or first
element of the passed array.

   The arguments are passed in the following order
   * Result variable, when the function result is passed by reference
   * Character length of the function result, if it is a of type
     'CHARACTER' and no C binding is used
   * The arguments in the order in which they appear in the Fortran
     declaration
   * The the present status for optional arguments with value attribute,
     which are internally passed by value
   * The character length and/or coarray token and offset for the first
     argument which is a 'CHARACTER' or a nonallocatable coarray dummy
     argument, followed by the hidden arguments of the next dummy
     argument of such a type


File: gfortran.info,  Node: Coarray Programming,  Next: Intrinsic Procedures,  Prev: Mixed-Language Programming,  Up: Top

8 Coarray Programming
*********************

* Menu:

* Type and enum ABI Documentation::
* Function ABI Documentation::


File: gfortran.info,  Node: Type and enum ABI Documentation,  Next: Function ABI Documentation,  Up: Coarray Programming

8.1 Type and enum ABI Documentation
===================================

* Menu:

* caf_token_t::
* caf_register_t::
* caf_deregister_t::
* caf_reference_t::
* caf_team_t::


File: gfortran.info,  Node: caf_token_t,  Next: caf_register_t,  Up: Type and enum ABI Documentation

8.1.1 'caf_token_t'
-------------------

Typedef of type 'void *' on the compiler side.  Can be any data type on
the library side.


File: gfortran.info,  Node: caf_register_t,  Next: caf_deregister_t,  Prev: caf_token_t,  Up: Type and enum ABI Documentation

8.1.2 'caf_register_t'
----------------------

Indicates which kind of coarray variable should be registered.

typedef enum caf_register_t {
  CAF_REGTYPE_COARRAY_STATIC,
  CAF_REGTYPE_COARRAY_ALLOC,
  CAF_REGTYPE_LOCK_STATIC,
  CAF_REGTYPE_LOCK_ALLOC,
  CAF_REGTYPE_CRITICAL,
  CAF_REGTYPE_EVENT_STATIC,
  CAF_REGTYPE_EVENT_ALLOC,
  CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY,
  CAF_REGTYPE_COARRAY_ALLOC_ALLOCATE_ONLY
}
caf_register_t;

   The values 'CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY' and
'CAF_REGTYPE_COARRAY_ALLOC_ALLOCATE_ONLY' are for allocatable components
in derived type coarrays only.  The first one sets up the token without
allocating memory for allocatable component.  The latter one only
allocates the memory for an allocatable component in a derived type
coarray.  The token needs to be setup previously by the REGISTER_ONLY.
This allows to have allocatable components un-allocated on some images.
The status whether an allocatable component is allocated on a remote
image can be queried by '_caf_is_present' which used internally by the
'ALLOCATED' intrinsic.


File: gfortran.info,  Node: caf_deregister_t,  Next: caf_reference_t,  Prev: caf_register_t,  Up: Type and enum ABI Documentation

8.1.3 'caf_deregister_t'
------------------------

typedef enum caf_deregister_t {
  CAF_DEREGTYPE_COARRAY_DEREGISTER,
  CAF_DEREGTYPE_COARRAY_DEALLOCATE_ONLY
}
caf_deregister_t;

   Allows to specifiy the type of deregistration of a coarray object.
The 'CAF_DEREGTYPE_COARRAY_DEALLOCATE_ONLY' flag is only allowed for
allocatable components in derived type coarrays.


File: gfortran.info,  Node: caf_reference_t,  Next: caf_team_t,  Prev: caf_deregister_t,  Up: Type and enum ABI Documentation

8.1.4 'caf_reference_t'
-----------------------

The structure used for implementing arbitrary reference chains.  A
'CAF_REFERENCE_T' allows to specify a component reference or any kind of
array reference of any rank supported by gfortran.  For array references
all kinds as known by the compiler/Fortran standard are supported
indicated by a 'MODE'.

typedef enum caf_ref_type_t {
  /* Reference a component of a derived type, either regular one or an
     allocatable or pointer type.  For regular ones idx in caf_reference_t is
     set to -1.  */
  CAF_REF_COMPONENT,
  /* Reference an allocatable array.  */
  CAF_REF_ARRAY,
  /* Reference a non-allocatable/non-pointer array.  I.e., the coarray object
     has no array descriptor associated and the addressing is done
     completely using the ref.  */
  CAF_REF_STATIC_ARRAY
} caf_ref_type_t;

typedef enum caf_array_ref_t {
  /* No array ref.  This terminates the array ref.  */
  CAF_ARR_REF_NONE = 0,
  /* Reference array elements given by a vector.  Only for this mode
     caf_reference_t.u.a.dim[i].v is valid.  */
  CAF_ARR_REF_VECTOR,
  /* A full array ref (:).  */
  CAF_ARR_REF_FULL,
  /* Reference a range on elements given by start, end and stride.  */
  CAF_ARR_REF_RANGE,
  /* Only a single item is referenced given in the start member.  */
  CAF_ARR_REF_SINGLE,
  /* An array ref of the kind (i:), where i is an arbitrary valid index in the
     array.  The index i is given in the start member.  */
  CAF_ARR_REF_OPEN_END,
  /* An array ref of the kind (:i), where the lower bound of the array ref
     is given by the remote side.  The index i is given in the end member.  */
  CAF_ARR_REF_OPEN_START
} caf_array_ref_t;

/* References to remote components of a derived type.  */
typedef struct caf_reference_t {
  /* A pointer to the next ref or NULL.  */
  struct caf_reference_t *next;
  /* The type of the reference.  */
  /* caf_ref_type_t, replaced by int to allow specification in fortran FE.  */
  int type;
  /* The size of an item referenced in bytes.  I.e. in an array ref this is
     the factor to advance the array pointer with to get to the next item.
     For component refs this gives just the size of the element referenced.  */
  size_t item_size;
  union {
    struct {
      /* The offset (in bytes) of the component in the derived type.
         Unused for allocatable or pointer components.  */
      ptrdiff_t offset;
      /* The offset (in bytes) to the caf_token associated with this
         component.  NULL, when not allocatable/pointer ref.  */
      ptrdiff_t caf_token_offset;
    } c;
    struct {
      /* The mode of the array ref.  See CAF_ARR_REF_*.  */
      /* caf_array_ref_t, replaced by unsigend char to allow specification in
         fortran FE.  */
     unsigned char mode[GFC_MAX_DIMENSIONS];
      /* The type of a static array.  Unset for array's with descriptors.  */
      int static_array_type;
      /* Subscript refs (s) or vector refs (v).  */
      union {
        struct {
          /* The start and end boundary of the ref and the stride.  */
          index_type start, end, stride;
        } s;
        struct {
          /* nvec entries of kind giving the elements to reference.  */
          void *vector;
          /* The number of entries in vector.  */
          size_t nvec;
          /* The integer kind used for the elements in vector.  */
          int kind;
        } v;
      } dim[GFC_MAX_DIMENSIONS];
    } a;
  } u;
} caf_reference_t;

   The references make up a single linked list of reference operations.
The 'NEXT' member links to the next reference or NULL to indicate the
end of the chain.  Component and array refs can be arbitrarly mixed as
long as they comply to the Fortran standard.

   _NOTES_ The member 'STATIC_ARRAY_TYPE' is used only when the 'TYPE'
is 'CAF_REF_STATIC_ARRAY'.  The member gives the type of the data
referenced.  Because no array descriptor is available for a
descriptor-less array and type conversion still needs to take place the
type is transported here.

   At the moment 'CAF_ARR_REF_VECTOR' is not implemented in the front
end for descriptor-less arrays.  The library caf_single has untested
support for it.


File: gfortran.info,  Node: caf_team_t,  Prev: caf_reference_t,  Up: Type and enum ABI Documentation

8.1.5 'caf_team_t'
------------------

Opaque pointer to represent a team-handle.  This type is a stand-in for
the future implementation of teams.  It is about to change without
further notice.


File: gfortran.info,  Node: Function ABI Documentation,  Prev: Type and enum ABI Documentation,  Up: Coarray Programming

8.2 Function ABI Documentation
==============================

* Menu:

* _gfortran_caf_init:: Initialiation function
* _gfortran_caf_finish:: Finalization function
* _gfortran_caf_this_image:: Querying the image number
* _gfortran_caf_num_images:: Querying the maximal number of images
* _gfortran_caf_image_status :: Query the status of an image
* _gfortran_caf_failed_images :: Get an array of the indexes of the failed images
* _gfortran_caf_stopped_images :: Get an array of the indexes of the stopped images
* _gfortran_caf_register:: Registering coarrays
* _gfortran_caf_deregister:: Deregistering coarrays
* _gfortran_caf_is_present:: Query whether an allocatable or pointer component in a derived type coarray is allocated
* _gfortran_caf_send:: Sending data from a local image to a remote image
* _gfortran_caf_get:: Getting data from a remote image
* _gfortran_caf_sendget:: Sending data between remote images
* _gfortran_caf_send_by_ref:: Sending data from a local image to a remote image using enhanced references
* _gfortran_caf_get_by_ref:: Getting data from a remote image using enhanced references
* _gfortran_caf_sendget_by_ref:: Sending data between remote images using enhanced references
* _gfortran_caf_lock:: Locking a lock variable
* _gfortran_caf_unlock:: Unlocking a lock variable
* _gfortran_caf_event_post:: Post an event
* _gfortran_caf_event_wait:: Wait that an event occurred
* _gfortran_caf_event_query:: Query event count
* _gfortran_caf_sync_all:: All-image barrier
* _gfortran_caf_sync_images:: Barrier for selected images
* _gfortran_caf_sync_memory:: Wait for completion of segment-memory operations
* _gfortran_caf_error_stop:: Error termination with exit code
* _gfortran_caf_error_stop_str:: Error termination with string
* _gfortran_caf_fail_image :: Mark the image failed and end its execution
* _gfortran_caf_atomic_define:: Atomic variable assignment
* _gfortran_caf_atomic_ref:: Atomic variable reference
* _gfortran_caf_atomic_cas:: Atomic compare and swap
* _gfortran_caf_atomic_op:: Atomic operation
* _gfortran_caf_co_broadcast:: Sending data to all images
* _gfortran_caf_co_max:: Collective maximum reduction
* _gfortran_caf_co_min:: Collective minimum reduction
* _gfortran_caf_co_sum:: Collective summing reduction
* _gfortran_caf_co_reduce:: Generic collective reduction


File: gfortran.info,  Node: _gfortran_caf_init,  Next: _gfortran_caf_finish,  Up: Function ABI Documentation

8.2.1 '_gfortran_caf_init' -- Initialiation function
----------------------------------------------------

_Description_:
     This function is called at startup of the program before the
     Fortran main program, if the latter has been compiled with
     '-fcoarray=lib'.  It takes as arguments the command-line arguments
     of the program.  It is permitted to pass two 'NULL' pointers as
     argument; if non-'NULL', the library is permitted to modify the
     arguments.

_Syntax_:
     'void _gfortran_caf_init (int *argc, char ***argv)'

_Arguments_:
     ARGC        intent(inout) An integer pointer with the number
                 of arguments passed to the program or 'NULL'.
     ARGV        intent(inout) A pointer to an array of strings
                 with the command-line arguments or 'NULL'.

_NOTES_
     The function is modelled after the initialization function of the
     Message Passing Interface (MPI) specification.  Due to the way
     coarray registration works, it might not be the first call to the
     library.  If the main program is not written in Fortran and only a
     library uses coarrays, it can happen that this function is never
     called.  Therefore, it is recommended that the library does not
     rely on the passed arguments and whether the call has been done.


File: gfortran.info,  Node: _gfortran_caf_finish,  Next: _gfortran_caf_this_image,  Prev: _gfortran_caf_init,  Up: Function ABI Documentation

8.2.2 '_gfortran_caf_finish' -- Finalization function
-----------------------------------------------------

_Description_:
     This function is called at the end of the Fortran main program, if
     it has been compiled with the '-fcoarray=lib' option.

_Syntax_:
     'void _gfortran_caf_finish (void)'

_NOTES_
     For non-Fortran programs, it is recommended to call the function at
     the end of the main program.  To ensure that the shutdown is also
     performed for programs where this function is not explicitly
     invoked, for instance non-Fortran programs or calls to the system's
     exit() function, the library can use a destructor function.  Note
     that programs can also be terminated using the STOP and ERROR STOP
     statements; those use different library calls.


File: gfortran.info,  Node: _gfortran_caf_this_image,  Next: _gfortran_caf_num_images,  Prev: _gfortran_caf_finish,  Up: Function ABI Documentation

8.2.3 '_gfortran_caf_this_image' -- Querying the image number
-------------------------------------------------------------

_Description_:
     This function returns the current image number, which is a positive
     number.

_Syntax_:
     'int _gfortran_caf_this_image (int distance)'

_Arguments_:
     DISTANCE    As specified for the 'this_image' intrinsic in
                 TS18508.  Shall be a non-negative number.

_NOTES_
     If the Fortran intrinsic 'this_image' is invoked without an
     argument, which is the only permitted form in Fortran 2008, GCC
     passes '0' as first argument.


File: gfortran.info,  Node: _gfortran_caf_num_images,  Next: _gfortran_caf_image_status,  Prev: _gfortran_caf_this_image,  Up: Function ABI Documentation

8.2.4 '_gfortran_caf_num_images' -- Querying the maximal number of images
-------------------------------------------------------------------------

_Description_:
     This function returns the number of images in the current team, if
     DISTANCE is 0 or the number of images in the parent team at the
     specified distance.  If failed is -1, the function returns the
     number of all images at the specified distance; if it is 0, the
     function returns the number of nonfailed images, and if it is 1, it
     returns the number of failed images.

_Syntax_:
     'int _gfortran_caf_num_images(int distance, int failed)'

_Arguments_:
     DISTANCE    the distance from this image to the ancestor.
                 Shall be positive.
     FAILED      shall be -1, 0, or 1

_NOTES_
     This function follows TS18508.  If the num_image intrinsic has no
     arguments, then the compiler passes 'distance=0' and 'failed=-1' to
     the function.


File: gfortran.info,  Node: _gfortran_caf_image_status,  Next: _gfortran_caf_failed_images,  Prev: _gfortran_caf_num_images,  Up: Function ABI Documentation

8.2.5 '_gfortran_caf_image_status' -- Query the status of an image
------------------------------------------------------------------

_Description_:
     Get the status of the image given by the id IMAGE of the team given
     by TEAM.  Valid results are zero, for image is ok,
     'STAT_STOPPED_IMAGE' from the ISO_FORTRAN_ENV module to indicate
     that the image has been stopped and 'STAT_FAILED_IMAGE' also from
     ISO_FORTRAN_ENV to indicate that the image has executed a 'FAIL
     IMAGE' statement.

_Syntax_:
     'int _gfortran_caf_image_status (int image, caf_team_t * team)'

_Arguments_:
     IMAGE       the positive scalar id of the image in the
                 current TEAM.
     TEAM        optional; team on the which the inquiry is to be
                 performed.

_NOTES_
     This function follows TS18508.  Because team-functionality is not
     yet implemented a null-pointer is passed for the TEAM argument at
     the moment.


File: gfortran.info,  Node: _gfortran_caf_failed_images,  Next: _gfortran_caf_stopped_images,  Prev: _gfortran_caf_image_status,  Up: Function ABI Documentation

8.2.6 '_gfortran_caf_failed_images' -- Get an array of the indexes of the failed images
---------------------------------------------------------------------------------------

_Description_:
     Get an array of image indexes in the current TEAM that have failed.
     The array is sorted ascendingly.  When TEAM is not provided the
     current team is to be used.  When KIND is provided then the
     resulting array is of that integer kind else it is of default
     integer kind.  The returns an unallocated size zero array when no
     images have failed.

_Syntax_:
     'int _gfortran_caf_failed_images (caf_team_t * team, int * kind)'

_Arguments_:
     TEAM        optional; team on the which the inquiry is to be
                 performed.
     IMAGE       optional; the kind of the resulting integer
                 array.

_NOTES_
     This function follows TS18508.  Because team-functionality is not
     yet implemented a null-pointer is passed for the TEAM argument at
     the moment.


File: gfortran.info,  Node: _gfortran_caf_stopped_images,  Next: _gfortran_caf_register,  Prev: _gfortran_caf_failed_images,  Up: Function ABI Documentation

8.2.7 '_gfortran_caf_stopped_images' -- Get an array of the indexes of the stopped images
-----------------------------------------------------------------------------------------

_Description_:
     Get an array of image indexes in the current TEAM that have
     stopped.  The array is sorted ascendingly.  When TEAM is not
     provided the current team is to be used.  When KIND is provided
     then the resulting array is of that integer kind else it is of
     default integer kind.  The returns an unallocated size zero array
     when no images have failed.

_Syntax_:
     'int _gfortran_caf_stopped_images (caf_team_t * team, int * kind)'

_Arguments_:
     TEAM        optional; team on the which the inquiry is to be
                 performed.
     IMAGE       optional; the kind of the resulting integer
                 array.

_NOTES_
     This function follows TS18508.  Because team-functionality is not
     yet implemented a null-pointer is passed for the TEAM argument at
     the moment.


File: gfortran.info,  Node: _gfortran_caf_register,  Next: _gfortran_caf_deregister,  Prev: _gfortran_caf_stopped_images,  Up: Function ABI Documentation

8.2.8 '_gfortran_caf_register' -- Registering coarrays
------------------------------------------------------

_Description_:
     Registers memory for a coarray and creates a token to identify the
     coarray.  The routine is called for both coarrays with 'SAVE'
     attribute and using an explicit 'ALLOCATE' statement.  If an error
     occurs and STAT is a 'NULL' pointer, the function shall abort with
     printing an error message and starting the error termination.  If
     no error occurs and STAT is present, it shall be set to zero.
     Otherwise, it shall be set to a positive value and, if not-'NULL',
     ERRMSG shall be set to a string describing the failure.  The
     routine shall register the memory provided in the 'DATA'-component
     of the array descriptor DESC, when that component is non-'NULL',
     else it shall allocate sufficient memory and provide a pointer to
     it in the 'DATA'-component of DESC.  The array descriptor has rank
     zero, when a scalar object is to be registered and the array
     descriptor may be invalid after the call to
     '_gfortran_caf_register'.  When an array is to be allocated the
     descriptor persists.

     For 'CAF_REGTYPE_COARRAY_STATIC' and 'CAF_REGTYPE_COARRAY_ALLOC',
     the passed size is the byte size requested.  For
     'CAF_REGTYPE_LOCK_STATIC', 'CAF_REGTYPE_LOCK_ALLOC' and
     'CAF_REGTYPE_CRITICAL' it is the array size or one for a scalar.

     When 'CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY' is used, then only a
     token for an allocatable or pointer component is created.  The
     'SIZE' parameter is not used then.  On the contrary when
     'CAF_REGTYPE_COARRAY_ALLOC_ALLOCATE_ONLY' is specified, then the
     TOKEN needs to be registered by a previous call with regtype
     'CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY' and either the memory
     specified in the DESC's data-ptr is registered or allocate when the
     data-ptr is 'NULL'.

_Syntax_:
     'void caf_register (size_t size, caf_register_t type, caf_token_t
     *token, gfc_descriptor_t *desc, int *stat, char *errmsg, size_t
     errmsg_len)'

_Arguments_:
     SIZE        For normal coarrays, the byte size of the
                 coarray to be allocated; for lock types and
                 event types, the number of elements.
     TYPE        one of the caf_register_t types.
     TOKEN       intent(out) An opaque pointer identifying the
                 coarray.
     DESC        intent(inout) The (pseudo) array descriptor.
     STAT        intent(out) For allocatable coarrays, stores the
                 STAT=; may be 'NULL'
     ERRMSG      intent(out) When an error occurs, this will be
                 set to an error message; may be 'NULL'
     ERRMSG_LEN  the buffer size of errmsg.

_NOTES_
     Nonallocatable coarrays have to be registered prior use from remote
     images.  In order to guarantee this, they have to be registered
     before the main program.  This can be achieved by creating
     constructor functions.  That is what GCC does such that also for
     nonallocatable coarrays the memory is allocated and no static
     memory is used.  The token permits to identify the coarray; to the
     processor, the token is a nonaliasing pointer.  The library can,
     for instance, store the base address of the coarray in the token,
     some handle or a more complicated struct.  The library may also
     store the array descriptor DESC when its rank is non-zero.

     For lock types, the value shall only be used for checking the
     allocation status.  Note that for critical blocks, the locking is
     only required on one image; in the locking statement, the processor
     shall always pass an image index of one for critical-block lock
     variables ('CAF_REGTYPE_CRITICAL').  For lock types and
     critical-block variables, the initial value shall be unlocked (or,
     respecitively, not in critical section) such as the value false;
     for event types, the initial state should be no event, e.g.  zero.


File: gfortran.info,  Node: _gfortran_caf_deregister,  Next: _gfortran_caf_is_present,  Prev: _gfortran_caf_register,  Up: Function ABI Documentation

8.2.9 '_gfortran_caf_deregister' -- Deregistering coarrays
----------------------------------------------------------

_Description_:
     Called to free or deregister the memory of a coarray; the processor
     calls this function for automatic and explicit deallocation.  In
     case of an error, this function shall fail with an error message,
     unless the STAT variable is not null.  The library is only expected
     to free memory it allocated itself during a call to
     '_gfortran_caf_register'.

_Syntax_:
     'void caf_deregister (caf_token_t *token, caf_deregister_t type,
     int *stat, char *errmsg, size_t errmsg_len)'

_Arguments_:
     TOKEN       the token to free.
     TYPE        the type of action to take for the coarray.  A
                 'CAF_DEREGTYPE_COARRAY_DEALLOCATE_ONLY' is
                 allowed only for allocatable or pointer
                 components of derived type coarrays.  The action
                 only deallocates the local memory without
                 deleting the token.
     STAT        intent(out) Stores the STAT=; may be NULL
     ERRMSG      intent(out) When an error occurs, this will be
                 set to an error message; may be NULL
     ERRMSG_LEN  the buffer size of errmsg.

_NOTES_
     For nonalloatable coarrays this function is never called.  If a
     cleanup is required, it has to be handled via the finish, stop and
     error stop functions, and via destructors.


File: gfortran.info,  Node: _gfortran_caf_is_present,  Next: _gfortran_caf_send,  Prev: _gfortran_caf_deregister,  Up: Function ABI Documentation

8.2.10 '_gfortran_caf_is_present' -- Query whether an allocatable or pointer component in a derived type coarray is allocated
-----------------------------------------------------------------------------------------------------------------------------

_Description_:
     Used to query the coarray library whether an allocatable component
     in a derived type coarray is allocated on a remote image.

_Syntax_:
     'void _gfortran_caf_is_present (caf_token_t token, int image_index,
     gfc_reference_t *ref)'

_Arguments_:
     TOKEN       An opaque pointer identifying the coarray.
     IMAGE_INDEX The ID of the remote image; must be a positive
                 number.
     REF         A chain of references to address the allocatable
                 or pointer component in the derived type
                 coarray.  The object reference needs to be a
                 scalar or a full array reference, respectively.


File: gfortran.info,  Node: _gfortran_caf_send,  Next: _gfortran_caf_get,  Prev: _gfortran_caf_is_present,  Up: Function ABI Documentation

8.2.11 '_gfortran_caf_send' -- Sending data from a local image to a remote image
--------------------------------------------------------------------------------

_Description_:
     Called to send a scalar, an array section or a whole array from a
     local to a remote image identified by the image_index.

_Syntax_:
     'void _gfortran_caf_send (caf_token_t token, size_t offset, int
     image_index, gfc_descriptor_t *dest, caf_vector_t *dst_vector,
     gfc_descriptor_t *src, int dst_kind, int src_kind, bool
     may_require_tmp, int *stat)'

_Arguments_:
     TOKEN       intent(in) An opaque pointer identifying the
                 coarray.
     OFFSET      intent(in) By which amount of bytes the actual
                 data is shifted compared to the base address of
                 the coarray.
     IMAGE_INDEX intent(in) The ID of the remote image; must be a
                 positive number.
     DEST        intent(in) Array descriptor for the remote image
                 for the bounds and the size.  The 'base_addr'
                 shall not be accessed.
     DST_VECTOR  intent(in) If not NULL, it contains the vector
                 subscript of the destination array; the values
                 are relative to the dimension triplet of the
                 dest argument.
     SRC         intent(in) Array descriptor of the local array
                 to be transferred to the remote image
     DST_KIND    intent(in) Kind of the destination argument
     SRC_KIND    intent(in) Kind of the source argument
     MAY_REQUIRE_TMPintent(in) The variable is 'false' when it is
                 known at compile time that the DEST and SRC
                 either cannot overlap or overlap (fully or
                 partially) such that walking SRC and DEST in
                 element wise element order (honoring the stride
                 value) will not lead to wrong results.
                 Otherwise, the value is 'true'.
     STAT        intent(out) when non-NULL give the result of the
                 operation, i.e., zero on success and non-zero on
                 error.  When NULL and an error occurs, then an
                 error message is printed and the program is
                 terminated.

_NOTES_
     It is permitted to have IMAGE_INDEX equal the current image; the
     memory of the send-to and the send-from might (partially) overlap
     in that case.  The implementation has to take care that it handles
     this case, e.g.  using 'memmove' which handles (partially)
     overlapping memory.  If MAY_REQUIRE_TMP is true, the library might
     additionally create a temporary variable, unless additional checks
     show that this is not required (e.g.  because walking backward is
     possible or because both arrays are contiguous and 'memmove' takes
     care of overlap issues).

     Note that the assignment of a scalar to an array is permitted.  In
     addition, the library has to handle numeric-type conversion and for
     strings, padding and different character kinds.


File: gfortran.info,  Node: _gfortran_caf_get,  Next: _gfortran_caf_sendget,  Prev: _gfortran_caf_send,  Up: Function ABI Documentation

8.2.12 '_gfortran_caf_get' -- Getting data from a remote image
--------------------------------------------------------------

_Description_:
     Called to get an array section or a whole array from a remote,
     image identified by the image_index.

_Syntax_:
     'void _gfortran_caf_get (caf_token_t token, size_t offset, int
     image_index, gfc_descriptor_t *src, caf_vector_t *src_vector,
     gfc_descriptor_t *dest, int src_kind, int dst_kind, bool
     may_require_tmp, int *stat)'

_Arguments_:
     TOKEN       intent(in) An opaque pointer identifying the
                 coarray.
     OFFSET      intent(in) By which amount of bytes the actual
                 data is shifted compared to the base address of
                 the coarray.
     IMAGE_INDEX intent(in) The ID of the remote image; must be a
                 positive number.
     DEST        intent(out) Array descriptor of the local array
                 to store the data retrieved from the remote
                 image
     SRC         intent(in) Array descriptor for the remote image
                 for the bounds and the size.  The 'base_addr'
                 shall not be accessed.
     SRC_VECTOR  intent(in) If not NULL, it contains the vector
                 subscript of the source array; the values are
                 relative to the dimension triplet of the SRC
                 argument.
     DST_KIND    intent(in) Kind of the destination argument
     SRC_KIND    intent(in) Kind of the source argument
     MAY_REQUIRE_TMPintent(in) The variable is 'false' when it is
                 known at compile time that the DEST and SRC
                 either cannot overlap or overlap (fully or
                 partially) such that walking SRC and DEST in
                 element wise element order (honoring the stride
                 value) will not lead to wrong results.
                 Otherwise, the value is 'true'.
     STAT        intent(out) When non-NULL give the result of the
                 operation, i.e., zero on success and non-zero on
                 error.  When NULL and an error occurs, then an
                 error message is printed and the program is
                 terminated.

_NOTES_
     It is permitted to have IMAGE_INDEX equal the current image; the
     memory of the send-to and the send-from might (partially) overlap
     in that case.  The implementation has to take care that it handles
     this case, e.g.  using 'memmove' which handles (partially)
     overlapping memory.  If MAY_REQUIRE_TMP is true, the library might
     additionally create a temporary variable, unless additional checks
     show that this is not required (e.g.  because walking backward is
     possible or because both arrays are contiguous and 'memmove' takes
     care of overlap issues).

     Note that the library has to handle numeric-type conversion and for
     strings, padding and different character kinds.


File: gfortran.info,  Node: _gfortran_caf_sendget,  Next: _gfortran_caf_send_by_ref,  Prev: _gfortran_caf_get,  Up: Function ABI Documentation

8.2.13 '_gfortran_caf_sendget' -- Sending data between remote images
--------------------------------------------------------------------

_Description_:
     Called to send a scalar, an array section or a whole array from a
     remote image identified by the SRC_IMAGE_INDEX to a remote image
     identified by the DST_IMAGE_INDEX.

_Syntax_:
     'void _gfortran_caf_sendget (caf_token_t dst_token, size_t
     dst_offset, int dst_image_index, gfc_descriptor_t *dest,
     caf_vector_t *dst_vector, caf_token_t src_token, size_t src_offset,
     int src_image_index, gfc_descriptor_t *src, caf_vector_t
     *src_vector, int dst_kind, int src_kind, bool may_require_tmp, int
     *stat)'

_Arguments_:
     DST_TOKEN   intent(in) An opaque pointer identifying the
                 destination coarray.
     DST_OFFSET  intent(in) By which amount of bytes the actual
                 data is shifted compared to the base address of
                 the destination coarray.
     DST_IMAGE_INDEXintent(in) The ID of the destination remote
                 image; must be a positive number.
     DEST        intent(in) Array descriptor for the destination
                 remote image for the bounds and the size.  The
                 'base_addr' shall not be accessed.
     DST_VECTOR  intent(int) If not NULL, it contains the vector
                 subscript of the destination array; the values
                 are relative to the dimension triplet of the
                 DEST argument.
     SRC_TOKEN   intent(in) An opaque pointer identifying the
                 source coarray.
     SRC_OFFSET  intent(in) By which amount of bytes the actual
                 data is shifted compared to the base address of
                 the source coarray.
     SRC_IMAGE_INDEXintent(in) The ID of the source remote image;
                 must be a positive number.
     SRC         intent(in) Array descriptor of the local array
                 to be transferred to the remote image.
     SRC_VECTOR  intent(in) Array descriptor of the local array
                 to be transferred to the remote image
     DST_KIND    intent(in) Kind of the destination argument
     SRC_KIND    intent(in) Kind of the source argument
     MAY_REQUIRE_TMPintent(in) The variable is 'false' when it is
                 known at compile time that the DEST and SRC
                 either cannot overlap or overlap (fully or
                 partially) such that walking SRC and DEST in
                 element wise element order (honoring the stride
                 value) will not lead to wrong results.
                 Otherwise, the value is 'true'.
     STAT        intent(out) when non-NULL give the result of the
                 operation, i.e., zero on success and non-zero on
                 error.  When NULL and an error occurs, then an
                 error message is printed and the program is
                 terminated.

_NOTES_
     It is permitted to have the same image index for both
     SRC_IMAGE_INDEX and DST_IMAGE_INDEX; the memory of the send-to and
     the send-from might (partially) overlap in that case.  The
     implementation has to take care that it handles this case, e.g.
     using 'memmove' which handles (partially) overlapping memory.  If
     MAY_REQUIRE_TMP is true, the library might additionally create a
     temporary variable, unless additional checks show that this is not
     required (e.g.  because walking backward is possible or because
     both arrays are contiguous and 'memmove' takes care of overlap
     issues).

     Note that the assignment of a scalar to an array is permitted.  In
     addition, the library has to handle numeric-type conversion and for
     strings, padding and different character kinds.


File: gfortran.info,  Node: _gfortran_caf_send_by_ref,  Next: _gfortran_caf_get_by_ref,  Prev: _gfortran_caf_sendget,  Up: Function ABI Documentation

8.2.14 '_gfortran_caf_send_by_ref' -- Sending data from a local image to a remote image with enhanced referencing options
-------------------------------------------------------------------------------------------------------------------------

_Description_:
     Called to send a scalar, an array section or a whole array from a
     local to a remote image identified by the IMAGE_INDEX.

_Syntax_:
     'void _gfortran_caf_send_by_ref (caf_token_t token, int
     image_index, gfc_descriptor_t *src, caf_reference_t *refs, int
     dst_kind, int src_kind, bool may_require_tmp, bool
     dst_reallocatable, int *stat, int dst_type)'

_Arguments_:
     TOKEN       intent(in) An opaque pointer identifying the
                 coarray.
     IMAGE_INDEX intent(in) The ID of the remote image; must be a
                 positive number.
     SRC         intent(in) Array descriptor of the local array
                 to be transferred to the remote image
     REFS        intent(in) The references on the remote array to
                 store the data given by src.  Guaranteed to have
                 at least one entry.
     DST_KIND    intent(in) Kind of the destination argument
     SRC_KIND    intent(in) Kind of the source argument
     MAY_REQUIRE_TMPintent(in) The variable is 'false' when it is
                 known at compile time that the DEST and SRC
                 either cannot overlap or overlap (fully or
                 partially) such that walking SRC and DEST in
                 element wise element order (honoring the stride
                 value) will not lead to wrong results.
                 Otherwise, the value is 'true'.
     DST_REALLOCATABLEintent(in) Set when the destination is of
                 allocatable or pointer type and the refs will
                 allow reallocation, i.e., the ref is a full
                 array or component ref.
     STAT        intent(out) When non-'NULL' give the result of
                 the operation, i.e., zero on success and
                 non-zero on error.  When 'NULL' and an error
                 occurs, then an error message is printed and the
                 program is terminated.
     DST_TYPE    intent(in) Give the type of the destination.
                 When the destination is not an array, than the
                 precise type, e.g.  of a component in a derived
                 type, is not known, but provided here.

_NOTES_
     It is permitted to have IMAGE_INDEX equal the current image; the
     memory of the send-to and the send-from might (partially) overlap
     in that case.  The implementation has to take care that it handles
     this case, e.g.  using 'memmove' which handles (partially)
     overlapping memory.  If MAY_REQUIRE_TMP is true, the library might
     additionally create a temporary variable, unless additional checks
     show that this is not required (e.g.  because walking backward is
     possible or because both arrays are contiguous and 'memmove' takes
     care of overlap issues).

     Note that the assignment of a scalar to an array is permitted.  In
     addition, the library has to handle numeric-type conversion and for
     strings, padding and different character kinds.

     Because of the more complicated references possible some operations
     may be unsupported by certain libraries.  The library is expected
     to issue a precise error message why the operation is not
     permitted.


File: gfortran.info,  Node: _gfortran_caf_get_by_ref,  Next: _gfortran_caf_sendget_by_ref,  Prev: _gfortran_caf_send_by_ref,  Up: Function ABI Documentation

8.2.15 '_gfortran_caf_get_by_ref' -- Getting data from a remote image using enhanced references
-----------------------------------------------------------------------------------------------

_Description_:
     Called to get a scalar, an array section or a whole array from a
     remote image identified by the IMAGE_INDEX.

_Syntax_:
     'void _gfortran_caf_get_by_ref (caf_token_t token, int image_index,
     caf_reference_t *refs, gfc_descriptor_t *dst, int dst_kind, int
     src_kind, bool may_require_tmp, bool dst_reallocatable, int *stat,
     int src_type)'

_Arguments_:
     TOKEN       intent(in) An opaque pointer identifying the
                 coarray.
     IMAGE_INDEX intent(in) The ID of the remote image; must be a
                 positive number.
     REFS        intent(in) The references to apply to the remote
                 structure to get the data.
     DST         intent(in) Array descriptor of the local array
                 to store the data transferred from the remote
                 image.  May be reallocated where needed and when
                 DST_REALLOCATABLE allows it.
     DST_KIND    intent(in) Kind of the destination argument
     SRC_KIND    intent(in) Kind of the source argument
     MAY_REQUIRE_TMPintent(in) The variable is 'false' when it is
                 known at compile time that the DEST and SRC
                 either cannot overlap or overlap (fully or
                 partially) such that walking SRC and DEST in
                 element wise element order (honoring the stride
                 value) will not lead to wrong results.
                 Otherwise, the value is 'true'.
     DST_REALLOCATABLEintent(in) Set when DST is of allocatable or
                 pointer type and its refs allow reallocation,
                 i.e., the full array or a component is
                 referenced.
     STAT        intent(out) When non-'NULL' give the result of
                 the operation, i.e., zero on success and
                 non-zero on error.  When 'NULL' and an error
                 occurs, then an error message is printed and the
                 program is terminated.
     SRC_TYPE    intent(in) Give the type of the source.  When
                 the source is not an array, than the precise
                 type, e.g.  of a component in a derived type, is
                 not known, but provided here.

_NOTES_
     It is permitted to have 'image_index' equal the current image; the
     memory of the send-to and the send-from might (partially) overlap
     in that case.  The implementation has to take care that it handles
     this case, e.g.  using 'memmove' which handles (partially)
     overlapping memory.  If MAY_REQUIRE_TMP is true, the library might
     additionally create a temporary variable, unless additional checks
     show that this is not required (e.g.  because walking backward is
     possible or because both arrays are contiguous and 'memmove' takes
     care of overlap issues).

     Note that the library has to handle numeric-type conversion and for
     strings, padding and different character kinds.

     Because of the more complicated references possible some operations
     may be unsupported by certain libraries.  The library is expected
     to issue a precise error message why the operation is not
     permitted.


File: gfortran.info,  Node: _gfortran_caf_sendget_by_ref,  Next: _gfortran_caf_lock,  Prev: _gfortran_caf_get_by_ref,  Up: Function ABI Documentation

8.2.16 '_gfortran_caf_sendget_by_ref' -- Sending data between remote images using enhanced references on both sides
-------------------------------------------------------------------------------------------------------------------

_Description_:
     Called to send a scalar, an array section or a whole array from a
     remote image identified by the SRC_IMAGE_INDEX to a remote image
     identified by the DST_IMAGE_INDEX.

_Syntax_:
     'void _gfortran_caf_sendget_by_ref (caf_token_t dst_token, int
     dst_image_index, caf_reference_t *dst_refs, caf_token_t src_token,
     int src_image_index, caf_reference_t *src_refs, int dst_kind, int
     src_kind, bool may_require_tmp, int *dst_stat, int *src_stat, int
     dst_type, int src_type)'

_Arguments_:
     DST_TOKEN   intent(in) An opaque pointer identifying the
                 destination coarray.
     DST_IMAGE_INDEXintent(in) The ID of the destination remote
                 image; must be a positive number.
     DST_REFS    intent(in) The references on the remote array to
                 store the data given by the source.  Guaranteed
                 to have at least one entry.
     SRC_TOKEN   intent(in) An opaque pointer identifying the
                 source coarray.
     SRC_IMAGE_INDEXintent(in) The ID of the source remote image;
                 must be a positive number.
     SRC_REFS    intent(in) The references to apply to the remote
                 structure to get the data.
     DST_KIND    intent(in) Kind of the destination argument
     SRC_KIND    intent(in) Kind of the source argument
     MAY_REQUIRE_TMPintent(in) The variable is 'false' when it is
                 known at compile time that the DEST and SRC
                 either cannot overlap or overlap (fully or
                 partially) such that walking SRC and DEST in
                 element wise element order (honoring the stride
                 value) will not lead to wrong results.
                 Otherwise, the value is 'true'.
     DST_STAT    intent(out) when non-'NULL' give the result of
                 the send-operation, i.e., zero on success and
                 non-zero on error.  When 'NULL' and an error
                 occurs, then an error message is printed and the
                 program is terminated.
     SRC_STAT    intent(out) When non-'NULL' give the result of
                 the get-operation, i.e., zero on success and
                 non-zero on error.  When 'NULL' and an error
                 occurs, then an error message is printed and the
                 program is terminated.
     DST_TYPE    intent(in) Give the type of the destination.
                 When the destination is not an array, than the
                 precise type, e.g.  of a component in a derived
                 type, is not known, but provided here.
     SRC_TYPE    intent(in) Give the type of the source.  When
                 the source is not an array, than the precise
                 type, e.g.  of a component in a derived type, is
                 not known, but provided here.

_NOTES_
     It is permitted to have the same image index for both
     SRC_IMAGE_INDEX and DST_IMAGE_INDEX; the memory of the send-to and
     the send-from might (partially) overlap in that case.  The
     implementation has to take care that it handles this case, e.g.
     using 'memmove' which handles (partially) overlapping memory.  If
     MAY_REQUIRE_TMP is true, the library might additionally create a
     temporary variable, unless additional checks show that this is not
     required (e.g.  because walking backward is possible or because
     both arrays are contiguous and 'memmove' takes care of overlap
     issues).

     Note that the assignment of a scalar to an array is permitted.  In
     addition, the library has to handle numeric-type conversion and for
     strings, padding and different character kinds.

     Because of the more complicated references possible some operations
     may be unsupported by certain libraries.  The library is expected
     to issue a precise error message why the operation is not
     permitted.


File: gfortran.info,  Node: _gfortran_caf_lock,  Next: _gfortran_caf_unlock,  Prev: _gfortran_caf_sendget_by_ref,  Up: Function ABI Documentation

8.2.17 '_gfortran_caf_lock' -- Locking a lock variable
------------------------------------------------------

_Description_:
     Acquire a lock on the given image on a scalar locking variable or
     for the given array element for an array-valued variable.  If the
     AQUIRED_LOCK is 'NULL', the function returns after having obtained
     the lock.  If it is non-'NULL', then ACQUIRED_LOCK is assigned the
     value true (one) when the lock could be obtained and false (zero)
     otherwise.  Locking a lock variable which has already been locked
     by the same image is an error.

_Syntax_:
     'void _gfortran_caf_lock (caf_token_t token, size_t index, int
     image_index, int *aquired_lock, int *stat, char *errmsg, size_t
     errmsg_len)'

_Arguments_:
     TOKEN       intent(in) An opaque pointer identifying the
                 coarray.
     INDEX       intent(in) Array index; first array index is 0.
                 For scalars, it is always 0.
     IMAGE_INDEX intent(in) The ID of the remote image; must be a
                 positive number.
     AQUIRED_LOCKintent(out) If not NULL, it returns whether lock
                 could be obtained.
     STAT        intent(out) Stores the STAT=; may be NULL.
     ERRMSG      intent(out) When an error occurs, this will be
                 set to an error message; may be NULL.
     ERRMSG_LEN  intent(in) the buffer size of errmsg

_NOTES_
     This function is also called for critical blocks; for those, the
     array index is always zero and the image index is one.  Libraries
     are permitted to use other images for critical-block locking
     variables.


File: gfortran.info,  Node: _gfortran_caf_unlock,  Next: _gfortran_caf_event_post,  Prev: _gfortran_caf_lock,  Up: Function ABI Documentation

8.2.18 '_gfortran_caf_lock' -- Unlocking a lock variable
--------------------------------------------------------

_Description_:
     Release a lock on the given image on a scalar locking variable or
     for the given array element for an array-valued variable.
     Unlocking a lock variable which is unlocked or has been locked by a
     different image is an error.

_Syntax_:
     'void _gfortran_caf_unlock (caf_token_t token, size_t index, int
     image_index, int *stat, char *errmsg, size_t errmsg_len)'

_Arguments_:
     TOKEN       intent(in) An opaque pointer identifying the
                 coarray.
     INDEX       intent(in) Array index; first array index is 0.
                 For scalars, it is always 0.
     IMAGE_INDEX intent(in) The ID of the remote image; must be a
                 positive number.
     STAT        intent(out) For allocatable coarrays, stores the
                 STAT=; may be NULL.
     ERRMSG      intent(out) When an error occurs, this will be
                 set to an error message; may be NULL.
     ERRMSG_LEN  intent(in) the buffer size of errmsg

_NOTES_
     This function is also called for critical block; for those, the
     array index is always zero and the image index is one.  Libraries
     are permitted to use other images for critical-block locking
     variables.


File: gfortran.info,  Node: _gfortran_caf_event_post,  Next: _gfortran_caf_event_wait,  Prev: _gfortran_caf_unlock,  Up: Function ABI Documentation

8.2.19 '_gfortran_caf_event_post' -- Post an event
--------------------------------------------------

_Description_:
     Increment the event count of the specified event variable.

_Syntax_:
     'void _gfortran_caf_event_post (caf_token_t token, size_t index,
     int image_index, int *stat, char *errmsg, size_t errmsg_len)'

_Arguments_:
     TOKEN       intent(in) An opaque pointer identifying the
                 coarray.
     INDEX       intent(in) Array index; first array index is 0.
                 For scalars, it is always 0.
     IMAGE_INDEX intent(in) The ID of the remote image; must be a
                 positive number; zero indicates the current
                 image, when accessed noncoindexed.
     STAT        intent(out) Stores the STAT=; may be NULL.
     ERRMSG      intent(out) When an error occurs, this will be
                 set to an error message; may be NULL.
     ERRMSG_LEN  intent(in) the buffer size of errmsg

_NOTES_
     This acts like an atomic add of one to the remote image's event
     variable.  The statement is an image-control statement but does not
     imply sync memory.  Still, all preceeding push communications of
     this image to the specified remote image have to be completed
     before 'event_wait' on the remote image returns.


File: gfortran.info,  Node: _gfortran_caf_event_wait,  Next: _gfortran_caf_event_query,  Prev: _gfortran_caf_event_post,  Up: Function ABI Documentation

8.2.20 '_gfortran_caf_event_wait' -- Wait that an event occurred
----------------------------------------------------------------

_Description_:
     Wait until the event count has reached at least the specified
     UNTIL_COUNT; if so, atomically decrement the event variable by this
     amount and return.

_Syntax_:
     'void _gfortran_caf_event_wait (caf_token_t token, size_t index,
     int until_count, int *stat, char *errmsg, size_t errmsg_len)'

_Arguments_:
     TOKEN       intent(in) An opaque pointer identifying the
                 coarray.
     INDEX       intent(in) Array index; first array index is 0.
                 For scalars, it is always 0.
     UNTIL_COUNT intent(in) The number of events which have to be
                 available before the function returns.
     STAT        intent(out) Stores the STAT=; may be NULL.
     ERRMSG      intent(out) When an error occurs, this will be
                 set to an error message; may be NULL.
     ERRMSG_LEN  intent(in) the buffer size of errmsg

_NOTES_
     This function only operates on a local coarray.  It acts like a
     loop checking atomically the value of the event variable, breaking
     if the value is greater or equal the requested number of counts.
     Before the function returns, the event variable has to be
     decremented by the requested UNTIL_COUNT value.  A possible
     implementation would be a busy loop for a certain number of spins
     (possibly depending on the number of threads relative to the number
     of available cores) followed by another waiting strategy such as a
     sleeping wait (possibly with an increasing number of sleep time)
     or, if possible, a futex wait.

     The statement is an image-control statement but does not imply sync
     memory.  Still, all preceeding push communications of this image to
     the specified remote image have to be completed before 'event_wait'
     on the remote image returns.


File: gfortran.info,  Node: _gfortran_caf_event_query,  Next: _gfortran_caf_sync_all,  Prev: _gfortran_caf_event_wait,  Up: Function ABI Documentation

8.2.21 '_gfortran_caf_event_query' -- Query event count
-------------------------------------------------------

_Description_:
     Return the event count of the specified event variable.

_Syntax_:
     'void _gfortran_caf_event_query (caf_token_t token, size_t index,
     int image_index, int *count, int *stat)'

_Arguments_:
     TOKEN       intent(in) An opaque pointer identifying the
                 coarray.
     INDEX       intent(in) Array index; first array index is 0.
                 For scalars, it is always 0.
     IMAGE_INDEX intent(in) The ID of the remote image; must be a
                 positive number; zero indicates the current
                 image when accessed noncoindexed.
     COUNT       intent(out) The number of events currently
                 posted to the event variable.
     STAT        intent(out) Stores the STAT=; may be NULL.

_NOTES_
     The typical use is to check the local event variable to only call
     'event_wait' when the data is available.  However, a coindexed
     variable is permitted; there is no ordering or synchronization
     implied.  It acts like an atomic fetch of the value of the event
     variable.


File: gfortran.info,  Node: _gfortran_caf_sync_all,  Next: _gfortran_caf_sync_images,  Prev: _gfortran_caf_event_query,  Up: Function ABI Documentation

8.2.22 '_gfortran_caf_sync_all' -- All-image barrier
----------------------------------------------------

_Description_:
     Synchronization of all images in the current team; the program only
     continues on a given image after this function has been called on
     all images of the current team.  Additionally, it ensures that all
     pending data transfers of previous segment have completed.

_Syntax_:
     'void _gfortran_caf_sync_all (int *stat, char *errmsg, size_t
     errmsg_len)'

_Arguments_:
     STAT        intent(out) Stores the status STAT= and may be
                 NULL.
     ERRMSG      intent(out) When an error occurs, this will be
                 set to an error message; may be NULL.
     ERRMSG_LEN  intent(in) the buffer size of errmsg


File: gfortran.info,  Node: _gfortran_caf_sync_images,  Next: _gfortran_caf_sync_memory,  Prev: _gfortran_caf_sync_all,  Up: Function ABI Documentation

8.2.23 '_gfortran_caf_sync_images' -- Barrier for selected images
-----------------------------------------------------------------

_Description_:
     Synchronization between the specified images; the program only
     continues on a given image after this function has been called on
     all images specified for that image.  Note that one image can wait
     for all other images in the current team (e.g.  via 'sync
     images(*)') while those only wait for that specific image.
     Additionally, 'sync images' ensures that all pending data transfers
     of previous segments have completed.

_Syntax_:
     'void _gfortran_caf_sync_images (int count, int images[], int
     *stat, char *errmsg, size_t errmsg_len)'

_Arguments_:
     COUNT       intent(in) The number of images which are
                 provided in the next argument.  For a zero-sized
                 array, the value is zero.  For 'sync images
                 (*)', the value is -1.
     IMAGES      intent(in) An array with the images provided by
                 the user.  If COUNT is zero, a NULL pointer is
                 passed.
     STAT        intent(out) Stores the status STAT= and may be
                 NULL.
     ERRMSG      intent(out) When an error occurs, this will be
                 set to an error message; may be NULL.
     ERRMSG_LEN  intent(in) the buffer size of errmsg


File: gfortran.info,  Node: _gfortran_caf_sync_memory,  Next: _gfortran_caf_error_stop,  Prev: _gfortran_caf_sync_images,  Up: Function ABI Documentation

8.2.24 '_gfortran_caf_sync_memory' -- Wait for completion of segment-memory operations
--------------------------------------------------------------------------------------

_Description_:
     Acts as optimization barrier between different segments.  It also
     ensures that all pending memory operations of this image have been
     completed.

_Syntax_:
     'void _gfortran_caf_sync_memory (int *stat, char *errmsg, size_t
     errmsg_len)'

_Arguments_:
     STAT        intent(out) Stores the status STAT= and may be
                 NULL.
     ERRMSG      intent(out) When an error occurs, this will be
                 set to an error message; may be NULL.
     ERRMSG_LEN  intent(in) the buffer size of errmsg

_NOTE_ A simple implementation could be
     '__asm__ __volatile__ ("":::"memory")' to prevent code movements.


File: gfortran.info,  Node: _gfortran_caf_error_stop,  Next: _gfortran_caf_error_stop_str,  Prev: _gfortran_caf_sync_memory,  Up: Function ABI Documentation

8.2.25 '_gfortran_caf_error_stop' -- Error termination with exit code
---------------------------------------------------------------------

_Description_:
     Invoked for an 'ERROR STOP' statement which has an integer
     argument.  The function should terminate the program with the
     specified exit code.

_Syntax_:
     'void _gfortran_caf_error_stop (int error)'

_Arguments_:
     ERROR       intent(in) The exit status to be used.


File: gfortran.info,  Node: _gfortran_caf_error_stop_str,  Next: _gfortran_caf_fail_image,  Prev: _gfortran_caf_error_stop,  Up: Function ABI Documentation

8.2.26 '_gfortran_caf_error_stop_str' -- Error termination with string
----------------------------------------------------------------------

_Description_:
     Invoked for an 'ERROR STOP' statement which has a string as
     argument.  The function should terminate the program with a
     nonzero-exit code.

_Syntax_:
     'void _gfortran_caf_error_stop (const char *string, size_t len)'

_Arguments_:
     STRING      intent(in) the error message (not zero
                 terminated)
     LEN         intent(in) the length of the string


File: gfortran.info,  Node: _gfortran_caf_fail_image,  Next: _gfortran_caf_atomic_define,  Prev: _gfortran_caf_error_stop_str,  Up: Function ABI Documentation

8.2.27 '_gfortran_caf_fail_image' -- Mark the image failed and end its execution
--------------------------------------------------------------------------------

_Description_:
     Invoked for an 'FAIL IMAGE' statement.  The function should
     terminate the current image.

_Syntax_:
     'void _gfortran_caf_fail_image ()'

_NOTES_
     This function follows TS18508.


File: gfortran.info,  Node: _gfortran_caf_atomic_define,  Next: _gfortran_caf_atomic_ref,  Prev: _gfortran_caf_fail_image,  Up: Function ABI Documentation

8.2.28 '_gfortran_caf_atomic_define' -- Atomic variable assignment
------------------------------------------------------------------

_Description_:
     Assign atomically a value to an integer or logical variable.

_Syntax_:
     'void _gfortran_caf_atomic_define (caf_token_t token, size_t
     offset, int image_index, void *value, int *stat, int type, int
     kind)'

_Arguments_:
     TOKEN       intent(in) An opaque pointer identifying the
                 coarray.
     OFFSET      intent(in) By which amount of bytes the actual
                 data is shifted compared to the base address of
                 the coarray.
     IMAGE_INDEX intent(in) The ID of the remote image; must be a
                 positive number; zero indicates the current
                 image when used noncoindexed.
     VALUE       intent(in) the value to be assigned, passed by
                 reference
     STAT        intent(out) Stores the status STAT= and may be
                 NULL.
     TYPE        intent(in) The data type, i.e.  'BT_INTEGER' (1)
                 or 'BT_LOGICAL' (2).
     KIND        intent(in) The kind value (only 4; always 'int')


File: gfortran.info,  Node: _gfortran_caf_atomic_ref,  Next: _gfortran_caf_atomic_cas,  Prev: _gfortran_caf_atomic_define,  Up: Function ABI Documentation

8.2.29 '_gfortran_caf_atomic_ref' -- Atomic variable reference
--------------------------------------------------------------

_Description_:
     Reference atomically a value of a kind-4 integer or logical
     variable.

_Syntax_:
     'void _gfortran_caf_atomic_ref (caf_token_t token, size_t offset,
     int image_index, void *value, int *stat, int type, int kind)'

_Arguments_:
     TOKEN       intent(in) An opaque pointer identifying the
                 coarray.
     OFFSET      intent(in) By which amount of bytes the actual
                 data is shifted compared to the base address of
                 the coarray.
     IMAGE_INDEX intent(in) The ID of the remote image; must be a
                 positive number; zero indicates the current
                 image when used noncoindexed.
     VALUE       intent(out) The variable assigned the atomically
                 referenced variable.
     STAT        intent(out) Stores the status STAT= and may be
                 NULL.
     TYPE        the data type, i.e.  'BT_INTEGER' (1) or
                 'BT_LOGICAL' (2).
     KIND        The kind value (only 4; always 'int')


File: gfortran.info,  Node: _gfortran_caf_atomic_cas,  Next: _gfortran_caf_atomic_op,  Prev: _gfortran_caf_atomic_ref,  Up: Function ABI Documentation

8.2.30 '_gfortran_caf_atomic_cas' -- Atomic compare and swap
------------------------------------------------------------

_Description_:
     Atomic compare and swap of a kind-4 integer or logical variable.
     Assigns atomically the specified value to the atomic variable, if
     the latter has the value specified by the passed condition value.

_Syntax_:
     'void _gfortran_caf_atomic_cas (caf_token_t token, size_t offset,
     int image_index, void *old, void *compare, void *new_val, int
     *stat, int type, int kind)'

_Arguments_:
     TOKEN       intent(in) An opaque pointer identifying the
                 coarray.
     OFFSET      intent(in) By which amount of bytes the actual
                 data is shifted compared to the base address of
                 the coarray.
     IMAGE_INDEX intent(in) The ID of the remote image; must be a
                 positive number; zero indicates the current
                 image when used noncoindexed.
     OLD         intent(out) The value which the atomic variable
                 had just before the cas operation.
     COMPARE     intent(in) The value used for comparision.
     NEW_VAL     intent(in) The new value for the atomic
                 variable, assigned to the atomic variable, if
                 'compare' equals the value of the atomic
                 variable.
     STAT        intent(out) Stores the status STAT= and may be
                 NULL.
     TYPE        intent(in) the data type, i.e.  'BT_INTEGER' (1)
                 or 'BT_LOGICAL' (2).
     KIND        intent(in) The kind value (only 4; always 'int')


File: gfortran.info,  Node: _gfortran_caf_atomic_op,  Next: _gfortran_caf_co_broadcast,  Prev: _gfortran_caf_atomic_cas,  Up: Function ABI Documentation

8.2.31 '_gfortran_caf_atomic_op' -- Atomic operation
----------------------------------------------------

_Description_:
     Apply an operation atomically to an atomic integer or logical
     variable.  After the operation, OLD contains the value just before
     the operation, which, respectively, adds (GFC_CAF_ATOMIC_ADD)
     atomically the 'value' to the atomic integer variable or does a
     bitwise AND, OR or exclusive OR between the atomic variable and
     VALUE; the result is then stored in the atomic variable.

_Syntax_:
     'void _gfortran_caf_atomic_op (int op, caf_token_t token, size_t
     offset, int image_index, void *value, void *old, int *stat, int
     type, int kind)'

_Arguments_:
     OP          intent(in) the operation to be performed;
                 possible values 'GFC_CAF_ATOMIC_ADD' (1),
                 'GFC_CAF_ATOMIC_AND' (2), 'GFC_CAF_ATOMIC_OR'
                 (3), 'GFC_CAF_ATOMIC_XOR' (4).
     TOKEN       intent(in) An opaque pointer identifying the
                 coarray.
     OFFSET      intent(in) By which amount of bytes the actual
                 data is shifted compared to the base address of
                 the coarray.
     IMAGE_INDEX intent(in) The ID of the remote image; must be a
                 positive number; zero indicates the current
                 image when used noncoindexed.
     OLD         intent(out) The value which the atomic variable
                 had just before the atomic operation.
     VAL         intent(in) The new value for the atomic
                 variable, assigned to the atomic variable, if
                 'compare' equals the value of the atomic
                 variable.
     STAT        intent(out) Stores the status STAT= and may be
                 NULL.
     TYPE        intent(in) the data type, i.e.  'BT_INTEGER' (1)
                 or 'BT_LOGICAL' (2)
     KIND        intent(in) the kind value (only 4; always 'int')


File: gfortran.info,  Node: _gfortran_caf_co_broadcast,  Next: _gfortran_caf_co_max,  Prev: _gfortran_caf_atomic_op,  Up: Function ABI Documentation

8.2.32 '_gfortran_caf_co_broadcast' -- Sending data to all images
-----------------------------------------------------------------

_Description_:
     Distribute a value from a given image to all other images in the
     team.  Has to be called collectively.

_Syntax_:
     'void _gfortran_caf_co_broadcast (gfc_descriptor_t *a, int
     source_image, int *stat, char *errmsg, size_t errmsg_len)'

_Arguments_:
     A           intent(inout) An array descriptor with the data
                 to be broadcasted (on SOURCE_IMAGE) or to be
                 received (other images).
     SOURCE_IMAGEintent(in) The ID of the image from which the
                 data should be broadcasted.
     STAT        intent(out) Stores the status STAT= and may be
                 NULL.
     ERRMSG      intent(out) When an error occurs, this will be
                 set to an error message; may be NULL.
     ERRMSG_LEN  intent(in) the buffer size of errmsg.


File: gfortran.info,  Node: _gfortran_caf_co_max,  Next: _gfortran_caf_co_min,  Prev: _gfortran_caf_co_broadcast,  Up: Function ABI Documentation

8.2.33 '_gfortran_caf_co_max' -- Collective maximum reduction
-------------------------------------------------------------

_Description_:
     Calculates for each array element of the variable A the maximum
     value for that element in the current team; if RESULT_IMAGE has the
     value 0, the result shall be stored on all images, otherwise, only
     on the specified image.  This function operates on numeric values
     and character strings.

_Syntax_:
     'void _gfortran_caf_co_max (gfc_descriptor_t *a, int result_image,
     int *stat, char *errmsg, int a_len, size_t errmsg_len)'

_Arguments_:
     A           intent(inout) An array descriptor for the data
                 to be processed.  On the destination image(s)
                 the result overwrites the old content.
     RESULT_IMAGEintent(in) The ID of the image to which the
                 reduced value should be copied to; if zero, it
                 has to be copied to all images.
     STAT        intent(out) Stores the status STAT= and may be
                 NULL.
     ERRMSG      intent(out) When an error occurs, this will be
                 set to an error message; may be NULL.
     A_LEN       intent(in) the string length of argument A
     ERRMSG_LEN  intent(in) the buffer size of errmsg

_NOTES_
     If RESULT_IMAGE is nonzero, the data in the array descriptor A on
     all images except of the specified one become undefined; hence, the
     library may make use of this.


File: gfortran.info,  Node: _gfortran_caf_co_min,  Next: _gfortran_caf_co_sum,  Prev: _gfortran_caf_co_max,  Up: Function ABI Documentation

8.2.34 '_gfortran_caf_co_min' -- Collective minimum reduction
-------------------------------------------------------------

_Description_:
     Calculates for each array element of the variable A the minimum
     value for that element in the current team; if RESULT_IMAGE has the
     value 0, the result shall be stored on all images, otherwise, only
     on the specified image.  This function operates on numeric values
     and character strings.

_Syntax_:
     'void _gfortran_caf_co_min (gfc_descriptor_t *a, int result_image,
     int *stat, char *errmsg, int a_len, size_t errmsg_len)'

_Arguments_:
     A           intent(inout) An array descriptor for the data
                 to be processed.  On the destination image(s)
                 the result overwrites the old content.
     RESULT_IMAGEintent(in) The ID of the image to which the
                 reduced value should be copied to; if zero, it
                 has to be copied to all images.
     STAT        intent(out) Stores the status STAT= and may be
                 NULL.
     ERRMSG      intent(out) When an error occurs, this will be
                 set to an error message; may be NULL.
     A_LEN       intent(in) the string length of argument A
     ERRMSG_LEN  intent(in) the buffer size of errmsg

_NOTES_
     If RESULT_IMAGE is nonzero, the data in the array descriptor A on
     all images except of the specified one become undefined; hence, the
     library may make use of this.


File: gfortran.info,  Node: _gfortran_caf_co_sum,  Next: _gfortran_caf_co_reduce,  Prev: _gfortran_caf_co_min,  Up: Function ABI Documentation

8.2.35 '_gfortran_caf_co_sum' -- Collective summing reduction
-------------------------------------------------------------

_Description_:
     Calculates for each array element of the variable A the sum of all
     values for that element in the current team; if RESULT_IMAGE has
     the value 0, the result shall be stored on all images, otherwise,
     only on the specified image.  This function operates on numeric
     values only.

_Syntax_:
     'void _gfortran_caf_co_sum (gfc_descriptor_t *a, int result_image,
     int *stat, char *errmsg, size_t errmsg_len)'

_Arguments_:
     A           intent(inout) An array descriptor with the data
                 to be processed.  On the destination image(s)
                 the result overwrites the old content.
     RESULT_IMAGEintent(in) The ID of the image to which the
                 reduced value should be copied to; if zero, it
                 has to be copied to all images.
     STAT        intent(out) Stores the status STAT= and may be
                 NULL.
     ERRMSG      intent(out) When an error occurs, this will be
                 set to an error message; may be NULL.
     ERRMSG_LEN  intent(in) the buffer size of errmsg

_NOTES_
     If RESULT_IMAGE is nonzero, the data in the array descriptor A on
     all images except of the specified one become undefined; hence, the
     library may make use of this.


File: gfortran.info,  Node: _gfortran_caf_co_reduce,  Prev: _gfortran_caf_co_sum,  Up: Function ABI Documentation

8.2.36 '_gfortran_caf_co_reduce' -- Generic collective reduction
----------------------------------------------------------------

_Description_:
     Calculates for each array element of the variable A the reduction
     value for that element in the current team; if RESULT_IMAGE has the
     value 0, the result shall be stored on all images, otherwise, only
     on the specified image.  The OPR is a pure function doing a
     mathematically commutative and associative operation.

     The OPR_FLAGS denote the following; the values are bitwise ored.
     'GFC_CAF_BYREF' (1) if the result should be returned by reference;
     'GFC_CAF_HIDDENLEN' (2) whether the result and argument string
     lengths shall be specified as hidden arguments; 'GFC_CAF_ARG_VALUE'
     (4) whether the arguments shall be passed by value,
     'GFC_CAF_ARG_DESC' (8) whether the arguments shall be passed by
     descriptor.

_Syntax_:
     'void _gfortran_caf_co_reduce (gfc_descriptor_t *a, void * (*opr)
     (void *, void *), int opr_flags, int result_image, int *stat, char
     *errmsg, int a_len, size_t errmsg_len)'

_Arguments_:
     A           intent(inout) An array descriptor with the data
                 to be processed.  On the destination image(s)
                 the result overwrites the old content.
     OPR         intent(in) Function pointer to the reduction
                 function
     OPR_FLAGS   intent(in) Flags regarding the reduction
                 function
     RESULT_IMAGEintent(in) The ID of the image to which the
                 reduced value should be copied to; if zero, it
                 has to be copied to all images.
     STAT        intent(out) Stores the status STAT= and may be
                 NULL.
     ERRMSG      intent(out) When an error occurs, this will be
                 set to an error message; may be NULL.
     A_LEN       intent(in) the string length of argument A
     ERRMSG_LEN  intent(in) the buffer size of errmsg

_NOTES_
     If RESULT_IMAGE is nonzero, the data in the array descriptor A on
     all images except of the specified one become undefined; hence, the
     library may make use of this.

     For character arguments, the result is passed as first argument,
     followed by the result string length, next come the two string
     arguments, followed by the two hidden string length arguments.
     With C binding, there are no hidden arguments and by-reference
     passing and either only a single character is passed or an array
     descriptor.


File: gfortran.info,  Node: Intrinsic Procedures,  Next: Intrinsic Modules,  Prev: Coarray Programming,  Up: Top

9 Intrinsic Procedures
**********************

* Menu:

* Introduction:         Introduction to Intrinsics
* 'ABORT':         ABORT,     Abort the program
* 'ABS':           ABS,       Absolute value
* 'ACCESS':        ACCESS,    Checks file access modes
* 'ACHAR':         ACHAR,     Character in ASCII collating sequence
* 'ACOS':          ACOS,      Arccosine function
* 'ACOSD':         ACOSD,     Arccosine function, degrees
* 'ACOSH':         ACOSH,     Inverse hyperbolic cosine function
* 'ADJUSTL':       ADJUSTL,   Left adjust a string
* 'ADJUSTR':       ADJUSTR,   Right adjust a string
* 'AIMAG':         AIMAG,     Imaginary part of complex number
* 'AINT':          AINT,      Truncate to a whole number
* 'ALARM':         ALARM,     Set an alarm clock
* 'ALL':           ALL,       Determine if all values are true
* 'ALLOCATED':     ALLOCATED, Status of allocatable entity
* 'AND':           AND,       Bitwise logical AND
* 'ANINT':         ANINT,     Nearest whole number
* 'ANY':           ANY,       Determine if any values are true
* 'ASIN':          ASIN,      Arcsine function
* 'ASIND':         ASIND,     Arcsine function, degrees
* 'ASINH':         ASINH,     Inverse hyperbolic sine function
* 'ASSOCIATED':    ASSOCIATED, Status of a pointer or pointer/target pair
* 'ATAN':          ATAN,      Arctangent function
* 'ATAND':         ATAND,     Arctangent function, degrees
* 'ATAN2':         ATAN2,     Arctangent function
* 'ATAN2D':        ATAN2D,    Arctangent function, degrees
* 'ATANH':         ATANH,     Inverse hyperbolic tangent function
* 'ATOMIC_ADD':    ATOMIC_ADD, Atomic ADD operation
* 'ATOMIC_AND':    ATOMIC_AND, Atomic bitwise AND operation
* 'ATOMIC_CAS':    ATOMIC_CAS, Atomic compare and swap
* 'ATOMIC_DEFINE': ATOMIC_DEFINE, Setting a variable atomically
* 'ATOMIC_FETCH_ADD': ATOMIC_FETCH_ADD, Atomic ADD operation with prior fetch
* 'ATOMIC_FETCH_AND': ATOMIC_FETCH_AND, Atomic bitwise AND operation with prior fetch
* 'ATOMIC_FETCH_OR': ATOMIC_FETCH_OR, Atomic bitwise OR operation with prior fetch
* 'ATOMIC_FETCH_XOR': ATOMIC_FETCH_XOR, Atomic bitwise XOR operation with prior fetch
* 'ATOMIC_OR':     ATOMIC_OR, Atomic bitwise OR operation
* 'ATOMIC_REF':    ATOMIC_REF, Obtaining the value of a variable atomically
* 'ATOMIC_XOR':    ATOMIC_XOR, Atomic bitwise OR operation
* 'BACKTRACE':     BACKTRACE, Show a backtrace
* 'BESSEL_J0':     BESSEL_J0, Bessel function of the first kind of order 0
* 'BESSEL_J1':     BESSEL_J1, Bessel function of the first kind of order 1
* 'BESSEL_JN':     BESSEL_JN, Bessel function of the first kind
* 'BESSEL_Y0':     BESSEL_Y0, Bessel function of the second kind of order 0
* 'BESSEL_Y1':     BESSEL_Y1, Bessel function of the second kind of order 1
* 'BESSEL_YN':     BESSEL_YN, Bessel function of the second kind
* 'BGE':           BGE,       Bitwise greater than or equal to
* 'BGT':           BGT,       Bitwise greater than
* 'BIT_SIZE':      BIT_SIZE,  Bit size inquiry function
* 'BLE':           BLE,       Bitwise less than or equal to
* 'BLT':           BLT,       Bitwise less than
* 'BTEST':         BTEST,     Bit test function
* 'C_ASSOCIATED':  C_ASSOCIATED, Status of a C pointer
* 'C_F_POINTER':   C_F_POINTER, Convert C into Fortran pointer
* 'C_F_PROCPOINTER': C_F_PROCPOINTER, Convert C into Fortran procedure pointer
* 'C_FUNLOC':      C_FUNLOC,  Obtain the C address of a procedure
* 'C_LOC':         C_LOC,     Obtain the C address of an object
* 'C_SIZEOF':      C_SIZEOF,  Size in bytes of an expression
* 'CEILING':       CEILING,   Integer ceiling function
* 'CHAR':          CHAR,      Integer-to-character conversion function
* 'CHDIR':         CHDIR,     Change working directory
* 'CHMOD':         CHMOD,     Change access permissions of files
* 'CMPLX':         CMPLX,     Complex conversion function
* 'CO_BROADCAST':  CO_BROADCAST, Copy a value to all images the current set of images
* 'CO_MAX':        CO_MAX,    Maximal value on the current set of images
* 'CO_MIN':        CO_MIN,    Minimal value on the current set of images
* 'CO_REDUCE':     CO_REDUCE, Reduction of values on the current set of images
* 'CO_SUM':        CO_SUM,    Sum of values on the current set of images
* 'COMMAND_ARGUMENT_COUNT': COMMAND_ARGUMENT_COUNT, Get number of command line arguments
* 'COMPILER_OPTIONS': COMPILER_OPTIONS, Options passed to the compiler
* 'COMPILER_VERSION': COMPILER_VERSION, Compiler version string
* 'COMPLEX':       COMPLEX,   Complex conversion function
* 'CONJG':         CONJG,     Complex conjugate function
* 'COS':           COS,       Cosine function
* 'COSD':          COSD,      Cosine function, degrees
* 'COSH':          COSH,      Hyperbolic cosine function
* 'COTAN':         COTAN,     Cotangent function
* 'COTAND':        COTAND,    Cotangent function, degrees
* 'COUNT':         COUNT,     Count occurrences of TRUE in an array
* 'CPU_TIME':      CPU_TIME,  CPU time subroutine
* 'CSHIFT':        CSHIFT,    Circular shift elements of an array
* 'CTIME':         CTIME,     Subroutine (or function) to convert a time into a string
* 'DATE_AND_TIME': DATE_AND_TIME, Date and time subroutine
* 'DBLE':          DBLE,      Double precision conversion function
* 'DCMPLX':        DCMPLX,    Double complex conversion function
* 'DIGITS':        DIGITS,    Significant digits function
* 'DIM':           DIM,       Positive difference
* 'DOT_PRODUCT':   DOT_PRODUCT, Dot product function
* 'DPROD':         DPROD,     Double product function
* 'DREAL':         DREAL,     Double real part function
* 'DSHIFTL':       DSHIFTL,   Combined left shift
* 'DSHIFTR':       DSHIFTR,   Combined right shift
* 'DTIME':         DTIME,     Execution time subroutine (or function)
* 'EOSHIFT':       EOSHIFT,   End-off shift elements of an array
* 'EPSILON':       EPSILON,   Epsilon function
* 'ERF':           ERF,       Error function
* 'ERFC':          ERFC,      Complementary error function
* 'ERFC_SCALED':   ERFC_SCALED, Exponentially-scaled complementary error function
* 'ETIME':         ETIME,     Execution time subroutine (or function)
* 'EVENT_QUERY': EVENT_QUERY, Query whether a coarray event has occurred
* 'EXECUTE_COMMAND_LINE': EXECUTE_COMMAND_LINE, Execute a shell command
* 'EXIT':          EXIT,      Exit the program with status.
* 'EXP':           EXP,       Exponential function
* 'EXPONENT':      EXPONENT,  Exponent function
* 'EXTENDS_TYPE_OF': EXTENDS_TYPE_OF,  Query dynamic type for extension
* 'FDATE':         FDATE,     Subroutine (or function) to get the current time as a string
* 'FGET':          FGET,      Read a single character in stream mode from stdin
* 'FGETC':         FGETC,     Read a single character in stream mode
* 'FINDLOC':       FINDLOC,   Search an array for a value
* 'FLOOR':         FLOOR,     Integer floor function
* 'FLUSH':         FLUSH,     Flush I/O unit(s)
* 'FNUM':          FNUM,      File number function
* 'FPUT':          FPUT,      Write a single character in stream mode to stdout
* 'FPUTC':         FPUTC,     Write a single character in stream mode
* 'FRACTION':      FRACTION,  Fractional part of the model representation
* 'FREE':          FREE,      Memory de-allocation subroutine
* 'FSEEK':         FSEEK,     Low level file positioning subroutine
* 'FSTAT':         FSTAT,     Get file status
* 'FTELL':         FTELL,     Current stream position
* 'GAMMA':         GAMMA,     Gamma function
* 'GERROR':        GERROR,    Get last system error message
* 'GETARG':        GETARG,    Get command line arguments
* 'GET_COMMAND':   GET_COMMAND, Get the entire command line
* 'GET_COMMAND_ARGUMENT': GET_COMMAND_ARGUMENT, Get command line arguments
* 'GETCWD':        GETCWD,    Get current working directory
* 'GETENV':        GETENV,    Get an environmental variable
* 'GET_ENVIRONMENT_VARIABLE': GET_ENVIRONMENT_VARIABLE, Get an environmental variable
* 'GETGID':        GETGID,    Group ID function
* 'GETLOG':        GETLOG,    Get login name
* 'GETPID':        GETPID,    Process ID function
* 'GETUID':        GETUID,    User ID function
* 'GMTIME':        GMTIME,    Convert time to GMT info
* 'HOSTNM':        HOSTNM,    Get system host name
* 'HUGE':          HUGE,      Largest number of a kind
* 'HYPOT':         HYPOT,     Euclidean distance function
* 'IACHAR':        IACHAR,    Code in ASCII collating sequence
* 'IALL':          IALL,      Bitwise AND of array elements
* 'IAND':          IAND,      Bitwise logical and
* 'IANY':          IANY,      Bitwise OR of array elements
* 'IARGC':         IARGC,     Get the number of command line arguments
* 'IBCLR':         IBCLR,     Clear bit
* 'IBITS':         IBITS,     Bit extraction
* 'IBSET':         IBSET,     Set bit
* 'ICHAR':         ICHAR,     Character-to-integer conversion function
* 'IDATE':         IDATE,     Current local time (day/month/year)
* 'IEOR':          IEOR,      Bitwise logical exclusive or
* 'IERRNO':        IERRNO,    Function to get the last system error number
* 'IMAGE_INDEX':   IMAGE_INDEX, Cosubscript to image index conversion
* 'INDEX':         INDEX intrinsic, Position of a substring within a string
* 'INT':           INT,       Convert to integer type
* 'INT2':          INT2,      Convert to 16-bit integer type
* 'INT8':          INT8,      Convert to 64-bit integer type
* 'IOR':           IOR,       Bitwise logical or
* 'IPARITY':       IPARITY,   Bitwise XOR of array elements
* 'IRAND':         IRAND,     Integer pseudo-random number
* 'IS_CONTIGUOUS':  IS_CONTIGUOUS, Test whether an array is contiguous
* 'IS_IOSTAT_END':  IS_IOSTAT_END, Test for end-of-file value
* 'IS_IOSTAT_EOR':  IS_IOSTAT_EOR, Test for end-of-record value
* 'ISATTY':        ISATTY,    Whether a unit is a terminal device
* 'ISHFT':         ISHFT,     Shift bits
* 'ISHFTC':        ISHFTC,    Shift bits circularly
* 'ISNAN':         ISNAN,     Tests for a NaN
* 'ITIME':         ITIME,     Current local time (hour/minutes/seconds)
* 'KILL':          KILL,      Send a signal to a process
* 'KIND':          KIND,      Kind of an entity
* 'LBOUND':        LBOUND,    Lower dimension bounds of an array
* 'LCOBOUND':      LCOBOUND,  Lower codimension bounds of an array
* 'LEADZ':         LEADZ,     Number of leading zero bits of an integer
* 'LEN':           LEN,       Length of a character entity
* 'LEN_TRIM':      LEN_TRIM,  Length of a character entity without trailing blank characters
* 'LGE':           LGE,       Lexical greater than or equal
* 'LGT':           LGT,       Lexical greater than
* 'LINK':          LINK,      Create a hard link
* 'LLE':           LLE,       Lexical less than or equal
* 'LLT':           LLT,       Lexical less than
* 'LNBLNK':        LNBLNK,    Index of the last non-blank character in a string
* 'LOC':           LOC,       Returns the address of a variable
* 'LOG':           LOG,       Logarithm function
* 'LOG10':         LOG10,     Base 10 logarithm function
* 'LOG_GAMMA':     LOG_GAMMA, Logarithm of the Gamma function
* 'LOGICAL':       LOGICAL,   Convert to logical type
* 'LONG':          LONG,      Convert to integer type
* 'LSHIFT':        LSHIFT,    Left shift bits
* 'LSTAT':         LSTAT,     Get file status
* 'LTIME':         LTIME,     Convert time to local time info
* 'MALLOC':        MALLOC,    Dynamic memory allocation function
* 'MASKL':         MASKL,     Left justified mask
* 'MASKR':         MASKR,     Right justified mask
* 'MATMUL':        MATMUL,    matrix multiplication
* 'MAX':           MAX,       Maximum value of an argument list
* 'MAXEXPONENT':   MAXEXPONENT, Maximum exponent of a real kind
* 'MAXLOC':        MAXLOC,    Location of the maximum value within an array
* 'MAXVAL':        MAXVAL,    Maximum value of an array
* 'MCLOCK':        MCLOCK,    Time function
* 'MCLOCK8':       MCLOCK8,   Time function (64-bit)
* 'MERGE':         MERGE,     Merge arrays
* 'MERGE_BITS':    MERGE_BITS, Merge of bits under mask
* 'MIN':           MIN,       Minimum value of an argument list
* 'MINEXPONENT':   MINEXPONENT, Minimum exponent of a real kind
* 'MINLOC':        MINLOC,    Location of the minimum value within an array
* 'MINVAL':        MINVAL,    Minimum value of an array
* 'MOD':           MOD,       Remainder function
* 'MODULO':        MODULO,    Modulo function
* 'MOVE_ALLOC':    MOVE_ALLOC, Move allocation from one object to another
* 'MVBITS':        MVBITS,    Move bits from one integer to another
* 'NEAREST':       NEAREST,   Nearest representable number
* 'NEW_LINE':      NEW_LINE,  New line character
* 'NINT':          NINT,      Nearest whole number
* 'NORM2':         NORM2,     Euclidean vector norm
* 'NOT':           NOT,       Logical negation
* 'NULL':          NULL,      Function that returns an disassociated pointer
* 'NUM_IMAGES':    NUM_IMAGES, Number of images
* 'OR':            OR,        Bitwise logical OR
* 'PACK':          PACK,      Pack an array into an array of rank one
* 'PARITY':        PARITY,    Reduction with exclusive OR
* 'PERROR':        PERROR,    Print system error message
* 'POPCNT':        POPCNT,    Number of bits set
* 'POPPAR':        POPPAR,    Parity of the number of bits set
* 'PRECISION':     PRECISION, Decimal precision of a real kind
* 'PRESENT':       PRESENT,   Determine whether an optional dummy argument is specified
* 'PRODUCT':       PRODUCT,   Product of array elements
* 'RADIX':         RADIX,     Base of a data model
* 'RAN':           RAN,       Real pseudo-random number
* 'RAND':          RAND,      Real pseudo-random number
* 'RANDOM_INIT':   RANDOM_INIT, Initialize pseudo-random number generator
* 'RANDOM_NUMBER': RANDOM_NUMBER, Pseudo-random number
* 'RANDOM_SEED':   RANDOM_SEED, Initialize a pseudo-random number sequence
* 'RANGE':         RANGE,     Decimal exponent range
* 'RANK' :         RANK,      Rank of a data object
* 'REAL':          REAL,      Convert to real type
* 'RENAME':        RENAME,    Rename a file
* 'REPEAT':        REPEAT,    Repeated string concatenation
* 'RESHAPE':       RESHAPE,   Function to reshape an array
* 'RRSPACING':     RRSPACING, Reciprocal of the relative spacing
* 'RSHIFT':        RSHIFT,    Right shift bits
* 'SAME_TYPE_AS':  SAME_TYPE_AS,  Query dynamic types for equality
* 'SCALE':         SCALE,     Scale a real value
* 'SCAN':          SCAN,      Scan a string for the presence of a set of characters
* 'SECNDS':        SECNDS,    Time function
* 'SECOND':        SECOND,    CPU time function
* 'SELECTED_CHAR_KIND': SELECTED_CHAR_KIND,  Choose character kind
* 'SELECTED_INT_KIND': SELECTED_INT_KIND,  Choose integer kind
* 'SELECTED_REAL_KIND': SELECTED_REAL_KIND,  Choose real kind
* 'SET_EXPONENT':  SET_EXPONENT, Set the exponent of the model
* 'SHAPE':         SHAPE,     Determine the shape of an array
* 'SHIFTA':        SHIFTA,    Right shift with fill
* 'SHIFTL':        SHIFTL,    Left shift
* 'SHIFTR':        SHIFTR,    Right shift
* 'SIGN':          SIGN,      Sign copying function
* 'SIGNAL':        SIGNAL,    Signal handling subroutine (or function)
* 'SIN':           SIN,       Sine function
* 'SIND':          SIND,      Sine function, degrees
* 'SINH':          SINH,      Hyperbolic sine function
* 'SIZE':          SIZE,      Function to determine the size of an array
* 'SIZEOF':        SIZEOF,    Determine the size in bytes of an expression
* 'SLEEP':         SLEEP,     Sleep for the specified number of seconds
* 'SPACING':       SPACING,   Smallest distance between two numbers of a given type
* 'SPREAD':        SPREAD,    Add a dimension to an array
* 'SQRT':          SQRT,      Square-root function
* 'SRAND':         SRAND,     Reinitialize the random number generator
* 'STAT':          STAT,      Get file status
* 'STORAGE_SIZE':  STORAGE_SIZE, Storage size in bits
* 'SUM':           SUM,       Sum of array elements
* 'SYMLNK':        SYMLNK,    Create a symbolic link
* 'SYSTEM':        SYSTEM,    Execute a shell command
* 'SYSTEM_CLOCK':  SYSTEM_CLOCK, Time function
* 'TAN':           TAN,       Tangent function
* 'TAND':          TAND,      Tangent function, degrees
* 'TANH':          TANH,      Hyperbolic tangent function
* 'THIS_IMAGE':    THIS_IMAGE, Cosubscript index of this image
* 'TIME':          TIME,      Time function
* 'TIME8':         TIME8,     Time function (64-bit)
* 'TINY':          TINY,      Smallest positive number of a real kind
* 'TRAILZ':        TRAILZ,    Number of trailing zero bits of an integer
* 'TRANSFER':      TRANSFER,  Transfer bit patterns
* 'TRANSPOSE':     TRANSPOSE, Transpose an array of rank two
* 'TRIM':          TRIM,      Remove trailing blank characters of a string
* 'TTYNAM':        TTYNAM,    Get the name of a terminal device.
* 'UBOUND':        UBOUND,    Upper dimension bounds of an array
* 'UCOBOUND':      UCOBOUND,  Upper codimension bounds of an array
* 'UMASK':         UMASK,     Set the file creation mask
* 'UNLINK':        UNLINK,    Remove a file from the file system
* 'UNPACK':        UNPACK,    Unpack an array of rank one into an array
* 'VERIFY':        VERIFY,    Scan a string for the absence of a set of characters
* 'XOR':           XOR,       Bitwise logical exclusive or


File: gfortran.info,  Node: Introduction to Intrinsics,  Next: ABORT,  Up: Intrinsic Procedures

9.1 Introduction to intrinsic procedures
========================================

The intrinsic procedures provided by GNU Fortran include all of the
intrinsic procedures required by the Fortran 95 standard, a set of
intrinsic procedures for backwards compatibility with G77, and a
selection of intrinsic procedures from the Fortran 2003 and Fortran 2008
standards.  Any conflict between a description here and a description in
either the Fortran 95 standard, the Fortran 2003 standard or the Fortran
2008 standard is unintentional, and the standard(s) should be considered
authoritative.

   The enumeration of the 'KIND' type parameter is processor defined in
the Fortran 95 standard.  GNU Fortran defines the default integer type
and default real type by 'INTEGER(KIND=4)' and 'REAL(KIND=4)',
respectively.  The standard mandates that both data types shall have
another kind, which have more precision.  On typical target
architectures supported by 'gfortran', this kind type parameter is
'KIND=8'.  Hence, 'REAL(KIND=8)' and 'DOUBLE PRECISION' are equivalent.
In the description of generic intrinsic procedures, the kind type
parameter will be specified by 'KIND=*', and in the description of
specific names for an intrinsic procedure the kind type parameter will
be explicitly given (e.g., 'REAL(KIND=4)' or 'REAL(KIND=8)').  Finally,
for brevity the optional 'KIND=' syntax will be omitted.

   Many of the intrinsic procedures take one or more optional arguments.
This document follows the convention used in the Fortran 95 standard,
and denotes such arguments by square brackets.

   GNU Fortran offers the '-std=f95' and '-std=gnu' options, which can
be used to restrict the set of intrinsic procedures to a given standard.
By default, 'gfortran' sets the '-std=gnu' option, and so all intrinsic
procedures described here are accepted.  There is one caveat.  For a
select group of intrinsic procedures, 'g77' implemented both a function
and a subroutine.  Both classes have been implemented in 'gfortran' for
backwards compatibility with 'g77'.  It is noted here that these
functions and subroutines cannot be intermixed in a given subprogram.
In the descriptions that follow, the applicable standard for each
intrinsic procedure is noted.


File: gfortran.info,  Node: ABORT,  Next: ABS,  Prev: Introduction to Intrinsics,  Up: Intrinsic Procedures

9.2 'ABORT' -- Abort the program
================================

_Description_:
     'ABORT' causes immediate termination of the program.  On operating
     systems that support a core dump, 'ABORT' will produce a core dump.
     It will also print a backtrace, unless '-fno-backtrace' is given.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL ABORT'

_Return value_:
     Does not return.

_Example_:
          program test_abort
            integer :: i = 1, j = 2
            if (i /= j) call abort
          end program test_abort

_See also_:
     *note EXIT::, *note KILL::, *note BACKTRACE::


File: gfortran.info,  Node: ABS,  Next: ACCESS,  Prev: ABORT,  Up: Intrinsic Procedures

9.3 'ABS' -- Absolute value
===========================

_Description_:
     'ABS(A)' computes the absolute value of 'A'.

_Standard_:
     Fortran 77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ABS(A)'

_Arguments_:
     A           The type of the argument shall be an 'INTEGER',
                 'REAL', or 'COMPLEX'.

_Return value_:
     The return value is of the same type and kind as the argument
     except the return value is 'REAL' for a 'COMPLEX' argument.

_Example_:
          program test_abs
            integer :: i = -1
            real :: x = -1.e0
            complex :: z = (-1.e0,0.e0)
            i = abs(i)
            x = abs(x)
            x = abs(z)
          end program test_abs

_Specific names_:
     Name           Argument       Return type    Standard
     'ABS(A)'       'REAL(4) A'    'REAL(4)'      Fortran 77 and
                                                  later
     'CABS(A)'      'COMPLEX(4)    'REAL(4)'      Fortran 77 and
                    A'                            later
     'DABS(A)'      'REAL(8) A'    'REAL(8)'      Fortran 77 and
                                                  later
     'IABS(A)'      'INTEGER(4)    'INTEGER(4)'   Fortran 77 and
                    A'                            later
     'BABS(A)'      'INTEGER(1)    'INTEGER(1)'   GNU extension
                    A'
     'IIABS(A)'     'INTEGER(2)    'INTEGER(2)'   GNU extension
                    A'
     'JIABS(A)'     'INTEGER(4)    'INTEGER(4)'   GNU extension
                    A'
     'KIABS(A)'     'INTEGER(8)    'INTEGER(8)'   GNU extension
                    A'
     'ZABS(A)'      'COMPLEX(8)    'COMPLEX(8)'   GNU extension
                    A'
     'CDABS(A)'     'COMPLEX(8)    'COMPLEX(8)'   GNU extension
                    A'


File: gfortran.info,  Node: ACCESS,  Next: ACHAR,  Prev: ABS,  Up: Intrinsic Procedures

9.4 'ACCESS' -- Checks file access modes
========================================

_Description_:
     'ACCESS(NAME, MODE)' checks whether the file NAME exists, is
     readable, writable or executable.  Except for the executable check,
     'ACCESS' can be replaced by Fortran 95's 'INQUIRE'.

_Standard_:
     GNU extension

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = ACCESS(NAME, MODE)'

_Arguments_:
     NAME        Scalar 'CHARACTER' of default kind with the file
                 name.  Tailing blank are ignored unless the
                 character 'achar(0)' is present, then all
                 characters up to and excluding 'achar(0)' are
                 used as file name.
     MODE        Scalar 'CHARACTER' of default kind with the file
                 access mode, may be any concatenation of '"r"'
                 (readable), '"w"' (writable) and '"x"'
                 (executable), or '" "' to check for existence.

_Return value_:
     Returns a scalar 'INTEGER', which is '0' if the file is accessible
     in the given mode; otherwise or if an invalid argument has been
     given for 'MODE' the value '1' is returned.

_Example_:
          program access_test
            implicit none
            character(len=*), parameter :: file  = 'test.dat'
            character(len=*), parameter :: file2 = 'test.dat  '//achar(0)
            if(access(file,' ') == 0) print *, trim(file),' is exists'
            if(access(file,'r') == 0) print *, trim(file),' is readable'
            if(access(file,'w') == 0) print *, trim(file),' is writable'
            if(access(file,'x') == 0) print *, trim(file),' is executable'
            if(access(file2,'rwx') == 0) &
              print *, trim(file2),' is readable, writable and executable'
          end program access_test
_Specific names_:
_See also_:


File: gfortran.info,  Node: ACHAR,  Next: ACOS,  Prev: ACCESS,  Up: Intrinsic Procedures

9.5 'ACHAR' -- Character in ASCII collating sequence
====================================================

_Description_:
     'ACHAR(I)' returns the character located at position 'I' in the
     ASCII collating sequence.

_Standard_:
     Fortran 77 and later, with KIND argument Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ACHAR(I [, KIND])'

_Arguments_:
     I           The type shall be 'INTEGER'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'CHARACTER' with a length of one.  If
     the KIND argument is present, the return value is of the specified
     kind and of the default kind otherwise.

_Example_:
          program test_achar
            character c
            c = achar(32)
          end program test_achar

_Note_:
     See *note ICHAR:: for a discussion of converting between numerical
     values and formatted string representations.

_See also_:
     *note CHAR::, *note IACHAR::, *note ICHAR::


File: gfortran.info,  Node: ACOS,  Next: ACOSD,  Prev: ACHAR,  Up: Intrinsic Procedures

9.6 'ACOS' -- Arccosine function
================================

_Description_:
     'ACOS(X)' computes the arccosine of X (inverse of 'COS(X)').

_Standard_:
     Fortran 77 and later, for a complex argument Fortran 2008 or later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ACOS(X)'

_Arguments_:
     X           The type shall either be 'REAL' with a magnitude
                 that is less than or equal to one - or the type
                 shall be 'COMPLEX'.

_Return value_:
     The return value is of the same type and kind as X.  The real part
     of the result is in radians and lies in the range 0 \leq \Re
     \acos(x) \leq \pi.

_Example_:
          program test_acos
            real(8) :: x = 0.866_8
            x = acos(x)
          end program test_acos

_Specific names_:
     Name           Argument       Return type    Standard
     'ACOS(X)'      'REAL(4) X'    'REAL(4)'      Fortran 77 and
                                                  later
     'DACOS(X)'     'REAL(8) X'    'REAL(8)'      Fortran 77 and
                                                  later

_See also_:
     Inverse function: *note COS:: Degrees function: *note ACOSD::


File: gfortran.info,  Node: ACOSD,  Next: ACOSH,  Prev: ACOS,  Up: Intrinsic Procedures

9.7 'ACOSD' -- Arccosine function, degrees
==========================================

_Description_:
     'ACOSD(X)' computes the arccosine of X in degrees (inverse of
     'COSD(X)').

     This function is for compatibility only and should be avoided in
     favor of standard constructs wherever possible.

_Standard_:
     GNU Extension, enabled with '-fdec-math'

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ACOSD(X)'

_Arguments_:
     X           The type shall either be 'REAL' with a magnitude
                 that is less than or equal to one - or the type
                 shall be 'COMPLEX'.

_Return value_:
     The return value is of the same type and kind as X.  The real part
     of the result is in degrees and lies in the range 0 \leq \Re
     \acos(x) \leq 180.

_Example_:
          program test_acosd
            real(8) :: x = 0.866_8
            x = acosd(x)
          end program test_acosd

_Specific names_:
     Name           Argument       Return type    Standard
     'ACOSD(X)'     'REAL(4) X'    'REAL(4)'      GNU Extension
     'DACOSD(X)'    'REAL(8) X'    'REAL(8)'      GNU Extension

_See also_:
     Inverse function: *note COSD:: Radians function: *note ACOS::


File: gfortran.info,  Node: ACOSH,  Next: ADJUSTL,  Prev: ACOSD,  Up: Intrinsic Procedures

9.8 'ACOSH' -- Inverse hyperbolic cosine function
=================================================

_Description_:
     'ACOSH(X)' computes the inverse hyperbolic cosine of X.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ACOSH(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value has the same type and kind as X.  If X is complex,
     the imaginary part of the result is in radians and lies between 0
     \leq \Im \acosh(x) \leq \pi.

_Example_:
          PROGRAM test_acosh
            REAL(8), DIMENSION(3) :: x = (/ 1.0, 2.0, 3.0 /)
            WRITE (*,*) ACOSH(x)
          END PROGRAM

_Specific names_:
     Name           Argument       Return type    Standard
     'DACOSH(X)'    'REAL(8) X'    'REAL(8)'      GNU extension

_See also_:
     Inverse function: *note COSH::


File: gfortran.info,  Node: ADJUSTL,  Next: ADJUSTR,  Prev: ACOSH,  Up: Intrinsic Procedures

9.9 'ADJUSTL' -- Left adjust a string
=====================================

_Description_:
     'ADJUSTL(STRING)' will left adjust a string by removing leading
     spaces.  Spaces are inserted at the end of the string as needed.

_Standard_:
     Fortran 90 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ADJUSTL(STRING)'

_Arguments_:
     STRING      The type shall be 'CHARACTER'.

_Return value_:
     The return value is of type 'CHARACTER' and of the same kind as
     STRING where leading spaces are removed and the same number of
     spaces are inserted on the end of STRING.

_Example_:
          program test_adjustl
            character(len=20) :: str = '   gfortran'
            str = adjustl(str)
            print *, str
          end program test_adjustl

_See also_:
     *note ADJUSTR::, *note TRIM::


File: gfortran.info,  Node: ADJUSTR,  Next: AIMAG,  Prev: ADJUSTL,  Up: Intrinsic Procedures

9.10 'ADJUSTR' -- Right adjust a string
=======================================

_Description_:
     'ADJUSTR(STRING)' will right adjust a string by removing trailing
     spaces.  Spaces are inserted at the start of the string as needed.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ADJUSTR(STRING)'

_Arguments_:
     STR         The type shall be 'CHARACTER'.

_Return value_:
     The return value is of type 'CHARACTER' and of the same kind as
     STRING where trailing spaces are removed and the same number of
     spaces are inserted at the start of STRING.

_Example_:
          program test_adjustr
            character(len=20) :: str = 'gfortran'
            str = adjustr(str)
            print *, str
          end program test_adjustr

_See also_:
     *note ADJUSTL::, *note TRIM::


File: gfortran.info,  Node: AIMAG,  Next: AINT,  Prev: ADJUSTR,  Up: Intrinsic Procedures

9.11 'AIMAG' -- Imaginary part of complex number
================================================

_Description_:
     'AIMAG(Z)' yields the imaginary part of complex argument 'Z'.  The
     'IMAG(Z)' and 'IMAGPART(Z)' intrinsic functions are provided for
     compatibility with 'g77', and their use in new code is strongly
     discouraged.

_Standard_:
     Fortran 77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = AIMAG(Z)'

_Arguments_:
     Z           The type of the argument shall be 'COMPLEX'.

_Return value_:
     The return value is of type 'REAL' with the kind type parameter of
     the argument.

_Example_:
          program test_aimag
            complex(4) z4
            complex(8) z8
            z4 = cmplx(1.e0_4, 0.e0_4)
            z8 = cmplx(0.e0_8, 1.e0_8)
            print *, aimag(z4), dimag(z8)
          end program test_aimag

_Specific names_:
     Name           Argument       Return type    Standard
     'AIMAG(Z)'     'COMPLEX Z'    'REAL'         GNU extension
     'DIMAG(Z)'     'COMPLEX(8)    'REAL(8)'      GNU extension
                    Z'
     'IMAG(Z)'      'COMPLEX Z'    'REAL'         GNU extension
     'IMAGPART(Z)'  'COMPLEX Z'    'REAL'         GNU extension


File: gfortran.info,  Node: AINT,  Next: ALARM,  Prev: AIMAG,  Up: Intrinsic Procedures

9.12 'AINT' -- Truncate to a whole number
=========================================

_Description_:
     'AINT(A [, KIND])' truncates its argument to a whole number.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = AINT(A [, KIND])'

_Arguments_:
     A           The type of the argument shall be 'REAL'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'REAL' with the kind type parameter of
     the argument if the optional KIND is absent; otherwise, the kind
     type parameter will be given by KIND.  If the magnitude of X is
     less than one, 'AINT(X)' returns zero.  If the magnitude is equal
     to or greater than one then it returns the largest whole number
     that does not exceed its magnitude.  The sign is the same as the
     sign of X.

_Example_:
          program test_aint
            real(4) x4
            real(8) x8
            x4 = 1.234E0_4
            x8 = 4.321_8
            print *, aint(x4), dint(x8)
            x8 = aint(x4,8)
          end program test_aint

_Specific names_:
     Name           Argument       Return type    Standard
     'AINT(A)'      'REAL(4) A'    'REAL(4)'      Fortran 77 and
                                                  later
     'DINT(A)'      'REAL(8) A'    'REAL(8)'      Fortran 77 and
                                                  later


File: gfortran.info,  Node: ALARM,  Next: ALL,  Prev: AINT,  Up: Intrinsic Procedures

9.13 'ALARM' -- Execute a routine after a given delay
=====================================================

_Description_:
     'ALARM(SECONDS, HANDLER [, STATUS])' causes external subroutine
     HANDLER to be executed after a delay of SECONDS by using 'alarm(2)'
     to set up a signal and 'signal(2)' to catch it.  If STATUS is
     supplied, it will be returned with the number of seconds remaining
     until any previously scheduled alarm was due to be delivered, or
     zero if there was no previously scheduled alarm.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL ALARM(SECONDS, HANDLER [, STATUS])'

_Arguments_:
     SECONDS     The type of the argument shall be a scalar
                 'INTEGER'.  It is 'INTENT(IN)'.
     HANDLER     Signal handler ('INTEGER FUNCTION' or
                 'SUBROUTINE') or dummy/global 'INTEGER' scalar.
                 The scalar values may be either 'SIG_IGN=1' to
                 ignore the alarm generated or 'SIG_DFL=0' to set
                 the default action.  It is 'INTENT(IN)'.
     STATUS      (Optional) STATUS shall be a scalar variable of
                 the default 'INTEGER' kind.  It is
                 'INTENT(OUT)'.

_Example_:
          program test_alarm
            external handler_print
            integer i
            call alarm (3, handler_print, i)
            print *, i
            call sleep(10)
          end program test_alarm
     This will cause the external routine HANDLER_PRINT to be called
     after 3 seconds.


File: gfortran.info,  Node: ALL,  Next: ALLOCATED,  Prev: ALARM,  Up: Intrinsic Procedures

9.14 'ALL' -- All values in MASK along DIM are true
===================================================

_Description_:
     'ALL(MASK [, DIM])' determines if all the values are true in MASK
     in the array along dimension DIM.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = ALL(MASK [, DIM])'

_Arguments_:
     MASK        The type of the argument shall be 'LOGICAL' and
                 it shall not be scalar.
     DIM         (Optional) DIM shall be a scalar integer with a
                 value that lies between one and the rank of
                 MASK.

_Return value_:
     'ALL(MASK)' returns a scalar value of type 'LOGICAL' where the kind
     type parameter is the same as the kind type parameter of MASK.  If
     DIM is present, then 'ALL(MASK, DIM)' returns an array with the
     rank of MASK minus 1.  The shape is determined from the shape of
     MASK where the DIM dimension is elided.

     (A)
          'ALL(MASK)' is true if all elements of MASK are true.  It also
          is true if MASK has zero size; otherwise, it is false.
     (B)
          If the rank of MASK is one, then 'ALL(MASK,DIM)' is equivalent
          to 'ALL(MASK)'.  If the rank is greater than one, then
          'ALL(MASK,DIM)' is determined by applying 'ALL' to the array
          sections.

_Example_:
          program test_all
            logical l
            l = all((/.true., .true., .true./))
            print *, l
            call section
            contains
              subroutine section
                integer a(2,3), b(2,3)
                a = 1
                b = 1
                b(2,2) = 2
                print *, all(a .eq. b, 1)
                print *, all(a .eq. b, 2)
              end subroutine section
          end program test_all


File: gfortran.info,  Node: ALLOCATED,  Next: AND,  Prev: ALL,  Up: Intrinsic Procedures

9.15 'ALLOCATED' -- Status of an allocatable entity
===================================================

_Description_:
     'ALLOCATED(ARRAY)' and 'ALLOCATED(SCALAR)' check the allocation
     status of ARRAY and SCALAR, respectively.

_Standard_:
     Fortran 95 and later.  Note, the 'SCALAR=' keyword and allocatable
     scalar entities are available in Fortran 2003 and later.

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = ALLOCATED(ARRAY)'
     'RESULT = ALLOCATED(SCALAR)'

_Arguments_:
     ARRAY       The argument shall be an 'ALLOCATABLE' array.
     SCALAR      The argument shall be an 'ALLOCATABLE' scalar.

_Return value_:
     The return value is a scalar 'LOGICAL' with the default logical
     kind type parameter.  If the argument is allocated, then the result
     is '.TRUE.'; otherwise, it returns '.FALSE.'

_Example_:
          program test_allocated
            integer :: i = 4
            real(4), allocatable :: x(:)
            if (.not. allocated(x)) allocate(x(i))
          end program test_allocated


File: gfortran.info,  Node: AND,  Next: ANINT,  Prev: ALLOCATED,  Up: Intrinsic Procedures

9.16 'AND' -- Bitwise logical AND
=================================

_Description_:
     Bitwise logical 'AND'.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  For integer arguments, programmers should consider
     the use of the *note IAND:: intrinsic defined by the Fortran
     standard.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = AND(I, J)'

_Arguments_:
     I           The type shall be either a scalar 'INTEGER' type
                 or a scalar 'LOGICAL' type or a
                 boz-literal-constant.
     J           The type shall be the same as the type of I or a
                 boz-literal-constant.  I and J shall not both be
                 boz-literal-constants.  If either I or J is a
                 boz-literal-constant, then the other argument
                 must be a scalar 'INTEGER'.

_Return value_:
     The return type is either a scalar 'INTEGER' or a scalar 'LOGICAL'.
     If the kind type parameters differ, then the smaller kind type is
     implicitly converted to larger kind, and the return has the larger
     kind.  A boz-literal-constant is converted to an 'INTEGER' with the
     kind type parameter of the other argument as-if a call to *note
     INT:: occurred.

_Example_:
          PROGRAM test_and
            LOGICAL :: T = .TRUE., F = .FALSE.
            INTEGER :: a, b
            DATA a / Z'F' /, b / Z'3' /

            WRITE (*,*) AND(T, T), AND(T, F), AND(F, T), AND(F, F)
            WRITE (*,*) AND(a, b)
          END PROGRAM

_See also_:
     Fortran 95 elemental function: *note IAND::


File: gfortran.info,  Node: ANINT,  Next: ANY,  Prev: AND,  Up: Intrinsic Procedures

9.17 'ANINT' -- Nearest whole number
====================================

_Description_:
     'ANINT(A [, KIND])' rounds its argument to the nearest whole
     number.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ANINT(A [, KIND])'

_Arguments_:
     A           The type of the argument shall be 'REAL'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type real with the kind type parameter of
     the argument if the optional KIND is absent; otherwise, the kind
     type parameter will be given by KIND.  If A is greater than zero,
     'ANINT(A)' returns 'AINT(X+0.5)'.  If A is less than or equal to
     zero then it returns 'AINT(X-0.5)'.

_Example_:
          program test_anint
            real(4) x4
            real(8) x8
            x4 = 1.234E0_4
            x8 = 4.321_8
            print *, anint(x4), dnint(x8)
            x8 = anint(x4,8)
          end program test_anint

_Specific names_:
     Name           Argument       Return type    Standard
     'AINT(A)'      'REAL(4) A'    'REAL(4)'      Fortran 77 and
                                                  later
     'DNINT(A)'     'REAL(8) A'    'REAL(8)'      Fortran 77 and
                                                  later


File: gfortran.info,  Node: ANY,  Next: ASIN,  Prev: ANINT,  Up: Intrinsic Procedures

9.18 'ANY' -- Any value in MASK along DIM is true
=================================================

_Description_:
     'ANY(MASK [, DIM])' determines if any of the values in the logical
     array MASK along dimension DIM are '.TRUE.'.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = ANY(MASK [, DIM])'

_Arguments_:
     MASK        The type of the argument shall be 'LOGICAL' and
                 it shall not be scalar.
     DIM         (Optional) DIM shall be a scalar integer with a
                 value that lies between one and the rank of
                 MASK.

_Return value_:
     'ANY(MASK)' returns a scalar value of type 'LOGICAL' where the kind
     type parameter is the same as the kind type parameter of MASK.  If
     DIM is present, then 'ANY(MASK, DIM)' returns an array with the
     rank of MASK minus 1.  The shape is determined from the shape of
     MASK where the DIM dimension is elided.

     (A)
          'ANY(MASK)' is true if any element of MASK is true; otherwise,
          it is false.  It also is false if MASK has zero size.
     (B)
          If the rank of MASK is one, then 'ANY(MASK,DIM)' is equivalent
          to 'ANY(MASK)'.  If the rank is greater than one, then
          'ANY(MASK,DIM)' is determined by applying 'ANY' to the array
          sections.

_Example_:
          program test_any
            logical l
            l = any((/.true., .true., .true./))
            print *, l
            call section
            contains
              subroutine section
                integer a(2,3), b(2,3)
                a = 1
                b = 1
                b(2,2) = 2
                print *, any(a .eq. b, 1)
                print *, any(a .eq. b, 2)
              end subroutine section
          end program test_any


File: gfortran.info,  Node: ASIN,  Next: ASIND,  Prev: ANY,  Up: Intrinsic Procedures

9.19 'ASIN' -- Arcsine function
===============================

_Description_:
     'ASIN(X)' computes the arcsine of its X (inverse of 'SIN(X)').

_Standard_:
     Fortran 77 and later, for a complex argument Fortran 2008 or later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ASIN(X)'

_Arguments_:
     X           The type shall be either 'REAL' and a magnitude
                 that is less than or equal to one - or be
                 'COMPLEX'.

_Return value_:
     The return value is of the same type and kind as X.  The real part
     of the result is in radians and lies in the range -\pi/2 \leq \Re
     \asin(x) \leq \pi/2.

_Example_:
          program test_asin
            real(8) :: x = 0.866_8
            x = asin(x)
          end program test_asin

_Specific names_:
     Name           Argument       Return type    Standard
     'ASIN(X)'      'REAL(4) X'    'REAL(4)'      Fortran 77 and
                                                  later
     'DASIN(X)'     'REAL(8) X'    'REAL(8)'      Fortran 77 and
                                                  later

_See also_:
     Inverse function: *note SIN:: Degrees function: *note ASIND::


File: gfortran.info,  Node: ASIND,  Next: ASINH,  Prev: ASIN,  Up: Intrinsic Procedures

9.20 'ASIND' -- Arcsine function, degrees
=========================================

_Description_:
     'ASIND(X)' computes the arcsine of its X in degrees (inverse of
     'SIND(X)').

     This function is for compatibility only and should be avoided in
     favor of standard constructs wherever possible.

_Standard_:
     GNU Extension, enabled with '-fdec-math'.

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ASIND(X)'

_Arguments_:
     X           The type shall be either 'REAL' and a magnitude
                 that is less than or equal to one - or be
                 'COMPLEX'.

_Return value_:
     The return value is of the same type and kind as X.  The real part
     of the result is in degrees and lies in the range -90 \leq \Re
     \asin(x) \leq 90.

_Example_:
          program test_asind
            real(8) :: x = 0.866_8
            x = asind(x)
          end program test_asind

_Specific names_:
     Name           Argument       Return type    Standard
     'ASIND(X)'     'REAL(4) X'    'REAL(4)'      GNU Extension
     'DASIND(X)'    'REAL(8) X'    'REAL(8)'      GNU Extension

_See also_:
     Inverse function: *note SIND:: Radians function: *note ASIN::


File: gfortran.info,  Node: ASINH,  Next: ASSOCIATED,  Prev: ASIND,  Up: Intrinsic Procedures

9.21 'ASINH' -- Inverse hyperbolic sine function
================================================

_Description_:
     'ASINH(X)' computes the inverse hyperbolic sine of X.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ASINH(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value is of the same type and kind as X.  If X is
     complex, the imaginary part of the result is in radians and lies
     between -\pi/2 \leq \Im \asinh(x) \leq \pi/2.

_Example_:
          PROGRAM test_asinh
            REAL(8), DIMENSION(3) :: x = (/ -1.0, 0.0, 1.0 /)
            WRITE (*,*) ASINH(x)
          END PROGRAM

_Specific names_:
     Name           Argument       Return type    Standard
     'DASINH(X)'    'REAL(8) X'    'REAL(8)'      GNU extension.

_See also_:
     Inverse function: *note SINH::


File: gfortran.info,  Node: ASSOCIATED,  Next: ATAN,  Prev: ASINH,  Up: Intrinsic Procedures

9.22 'ASSOCIATED' -- Status of a pointer or pointer/target pair
===============================================================

_Description_:
     'ASSOCIATED(POINTER [, TARGET])' determines the status of the
     pointer POINTER or if POINTER is associated with the target TARGET.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = ASSOCIATED(POINTER [, TARGET])'

_Arguments_:
     POINTER     POINTER shall have the 'POINTER' attribute and
                 it can be of any type.
     TARGET      (Optional) TARGET shall be a pointer or a
                 target.  It must have the same type, kind type
                 parameter, and array rank as POINTER.
     The association status of neither POINTER nor TARGET shall be
     undefined.

_Return value_:
     'ASSOCIATED(POINTER)' returns a scalar value of type 'LOGICAL(4)'.
     There are several cases:
     (A) When the optional TARGET is not present then
          'ASSOCIATED(POINTER)' is true if POINTER is associated with a
          target; otherwise, it returns false.
     (B) If TARGET is present and a scalar target, the result is true if
          TARGET is not a zero-sized storage sequence and the target
          associated with POINTER occupies the same storage units.  If
          POINTER is disassociated, the result is false.
     (C) If TARGET is present and an array target, the result is true if
          TARGET and POINTER have the same shape, are not zero-sized
          arrays, are arrays whose elements are not zero-sized storage
          sequences, and TARGET and POINTER occupy the same storage
          units in array element order.  As in case(B), the result is
          false, if POINTER is disassociated.
     (D) If TARGET is present and an scalar pointer, the result is true
          if TARGET is associated with POINTER, the target associated
          with TARGET are not zero-sized storage sequences and occupy
          the same storage units.  The result is false, if either TARGET
          or POINTER is disassociated.
     (E) If TARGET is present and an array pointer, the result is true if
          target associated with POINTER and the target associated with
          TARGET have the same shape, are not zero-sized arrays, are
          arrays whose elements are not zero-sized storage sequences,
          and TARGET and POINTER occupy the same storage units in array
          element order.  The result is false, if either TARGET or
          POINTER is disassociated.

_Example_:
          program test_associated
             implicit none
             real, target  :: tgt(2) = (/1., 2./)
             real, pointer :: ptr(:)
             ptr => tgt
             if (associated(ptr)     .eqv. .false.) call abort
             if (associated(ptr,tgt) .eqv. .false.) call abort
          end program test_associated

_See also_:
     *note NULL::


File: gfortran.info,  Node: ATAN,  Next: ATAND,  Prev: ASSOCIATED,  Up: Intrinsic Procedures

9.23 'ATAN' -- Arctangent function
==================================

_Description_:
     'ATAN(X)' computes the arctangent of X.

_Standard_:
     Fortran 77 and later, for a complex argument and for two arguments
     Fortran 2008 or later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ATAN(X)'
     'RESULT = ATAN(Y, X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'; if Y is
                 present, X shall be REAL.
     Y shall
     be of the
     same type
     and kind
     as X.

_Return value_:
     The return value is of the same type and kind as X.  If Y is
     present, the result is identical to 'ATAN2(Y,X)'.  Otherwise, it
     the arcus tangent of X, where the real part of the result is in
     radians and lies in the range -\pi/2 \leq \Re \atan(x) \leq \pi/2.

_Example_:
          program test_atan
            real(8) :: x = 2.866_8
            x = atan(x)
          end program test_atan

_Specific names_:
     Name           Argument       Return type    Standard
     'ATAN(X)'      'REAL(4) X'    'REAL(4)'      Fortran 77 and
                                                  later
     'DATAN(X)'     'REAL(8) X'    'REAL(8)'      Fortran 77 and
                                                  later

_See also_:
     Inverse function: *note TAN:: Degrees function: *note ATAND::


File: gfortran.info,  Node: ATAND,  Next: ATAN2,  Prev: ATAN,  Up: Intrinsic Procedures

9.24 'ATAND' -- Arctangent function, degrees
============================================

_Description_:
     'ATAND(X)' computes the arctangent of X in degrees (inverse of
     *note TAND::).

     This function is for compatibility only and should be avoided in
     favor of standard constructs wherever possible.

_Standard_:
     GNU Extension, enabled with '-fdec-math'.

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ATAND(X)'
     'RESULT = ATAND(Y, X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'; if Y is
                 present, X shall be REAL.
     Y shall
     be of the
     same type
     and kind
     as X.

_Return value_:
     The return value is of the same type and kind as X.  If Y is
     present, the result is identical to 'ATAND2(Y,X)'.  Otherwise, it
     is the arcus tangent of X, where the real part of the result is in
     degrees and lies in the range -90 \leq \Re \atand(x) \leq 90.

_Example_:
          program test_atand
            real(8) :: x = 2.866_8
            x = atand(x)
          end program test_atand

_Specific names_:
     Name           Argument       Return type    Standard
     'ATAND(X)'     'REAL(4) X'    'REAL(4)'      GNU Extension
     'DATAND(X)'    'REAL(8) X'    'REAL(8)'      GNU Extension

_See also_:
     Inverse function: *note TAND:: Radians function: *note ATAN::


File: gfortran.info,  Node: ATAN2,  Next: ATAN2D,  Prev: ATAND,  Up: Intrinsic Procedures

9.25 'ATAN2' -- Arctangent function
===================================

_Description_:
     'ATAN2(Y, X)' computes the principal value of the argument function
     of the complex number X + i Y.  This function can be used to
     transform from Cartesian into polar coordinates and allows to
     determine the angle in the correct quadrant.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ATAN2(Y, X)'

_Arguments_:
     Y           The type shall be 'REAL'.
     X           The type and kind type parameter shall be the
                 same as Y.  If Y is zero, then X must be
                 nonzero.

_Return value_:
     The return value has the same type and kind type parameter as Y.
     It is the principal value of the complex number X + i Y.  If X is
     nonzero, then it lies in the range -\pi \le \atan (x) \leq \pi.
     The sign is positive if Y is positive.  If Y is zero, then the
     return value is zero if X is strictly positive, \pi if X is
     negative and Y is positive zero (or the processor does not handle
     signed zeros), and -\pi if X is negative and Y is negative zero.
     Finally, if X is zero, then the magnitude of the result is \pi/2.

_Example_:
          program test_atan2
            real(4) :: x = 1.e0_4, y = 0.5e0_4
            x = atan2(y,x)
          end program test_atan2

_Specific names_:
     Name           Argument       Return type    Standard
     'ATAN2(X,      'REAL(4) X,    'REAL(4)'      Fortran 77 and
     Y)'            Y'                            later
     'DATAN2(X,     'REAL(8) X,    'REAL(8)'      Fortran 77 and
     Y)'            Y'                            later

_See also_:
     Alias: *note ATAN:: Degrees function: *note ATAN2D::


File: gfortran.info,  Node: ATAN2D,  Next: ATANH,  Prev: ATAN2,  Up: Intrinsic Procedures

9.26 'ATAN2D' -- Arctangent function, degrees
=============================================

_Description_:
     'ATAN2D(Y, X)' computes the principal value of the argument
     function of the complex number X + i Y in degrees.  This function
     can be used to transform from Cartesian into polar coordinates and
     allows to determine the angle in the correct quadrant.

     This function is for compatibility only and should be avoided in
     favor of standard constructs wherever possible.

_Standard_:
     GNU Extension, enabled with '-fdec-math'.

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ATAN2D(Y, X)'

_Arguments_:
     Y           The type shall be 'REAL'.
     X           The type and kind type parameter shall be the
                 same as Y.  If Y is zero, then X must be
                 nonzero.

_Return value_:
     The return value has the same type and kind type parameter as Y.
     It is the principal value of the complex number X + i Y.  If X is
     nonzero, then it lies in the range -180 \le \atan (x) \leq 180.
     The sign is positive if Y is positive.  If Y is zero, then the
     return value is zero if X is strictly positive, 180 if X is
     negative and Y is positive zero (or the processor does not handle
     signed zeros), and -180 if X is negative and Y is negative zero.
     Finally, if X is zero, then the magnitude of the result is 90.

_Example_:
          program test_atan2d
            real(4) :: x = 1.e0_4, y = 0.5e0_4
            x = atan2d(y,x)
          end program test_atan2d

_Specific names_:
     Name           Argument       Return type    Standard
     'ATAN2D(X,     'REAL(4) X,    'REAL(4)'      GNU Extension
     Y)'            Y'
     'DATAN2D(X,    'REAL(8) X,    'REAL(8)'      GNU Extension
     Y)'            Y'

_See also_:
     Alias: *note ATAND:: Radians function: *note ATAN2::


File: gfortran.info,  Node: ATANH,  Next: ATOMIC_ADD,  Prev: ATAN2D,  Up: Intrinsic Procedures

9.27 'ATANH' -- Inverse hyperbolic tangent function
===================================================

_Description_:
     'ATANH(X)' computes the inverse hyperbolic tangent of X.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ATANH(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value has same type and kind as X.  If X is complex, the
     imaginary part of the result is in radians and lies between -\pi/2
     \leq \Im \atanh(x) \leq \pi/2.

_Example_:
          PROGRAM test_atanh
            REAL, DIMENSION(3) :: x = (/ -1.0, 0.0, 1.0 /)
            WRITE (*,*) ATANH(x)
          END PROGRAM

_Specific names_:
     Name           Argument       Return type    Standard
     'DATANH(X)'    'REAL(8) X'    'REAL(8)'      GNU extension

_See also_:
     Inverse function: *note TANH::


File: gfortran.info,  Node: ATOMIC_ADD,  Next: ATOMIC_AND,  Prev: ATANH,  Up: Intrinsic Procedures

9.28 'ATOMIC_ADD' -- Atomic ADD operation
=========================================

_Description_:
     'ATOMIC_ADD(ATOM, VALUE)' atomically adds the value of VAR to the
     variable ATOM.  When STAT is present and the invocation was
     successful, it is assigned the value 0.  If it is present and the
     invocation has failed, it is assigned a positive value; in
     particular, for a coindexed ATOM, if the remote image has stopped,
     it is assigned the value of 'ISO_FORTRAN_ENV''s
     'STAT_STOPPED_IMAGE' and if the remote image has failed, the value
     'STAT_FAILED_IMAGE'.

_Standard_:
     TS 18508 or later

_Class_:
     Atomic subroutine

_Syntax_:
     'CALL ATOMIC_ADD (ATOM, VALUE [, STAT])'

_Arguments_:
     ATOM        Scalar coarray or coindexed variable of integer
                 type with 'ATOMIC_INT_KIND' kind.
     VALUE       Scalar of the same type as ATOM.  If the kind is
                 different, the value is converted to the kind of
                 ATOM.
     STAT        (optional) Scalar default-kind integer variable.

_Example_:
          program atomic
            use iso_fortran_env
            integer(atomic_int_kind) :: atom[*]
            call atomic_add (atom[1], this_image())
          end program atomic

_See also_:
     *note ATOMIC_DEFINE::, *note ATOMIC_FETCH_ADD::, *note
     ISO_FORTRAN_ENV::, *note ATOMIC_AND::, *note ATOMIC_OR::, *note
     ATOMIC_XOR::


File: gfortran.info,  Node: ATOMIC_AND,  Next: ATOMIC_CAS,  Prev: ATOMIC_ADD,  Up: Intrinsic Procedures

9.29 'ATOMIC_AND' -- Atomic bitwise AND operation
=================================================

_Description_:
     'ATOMIC_AND(ATOM, VALUE)' atomically defines ATOM with the bitwise
     AND between the values of ATOM and VALUE.  When STAT is present and
     the invocation was successful, it is assigned the value 0.  If it
     is present and the invocation has failed, it is assigned a positive
     value; in particular, for a coindexed ATOM, if the remote image has
     stopped, it is assigned the value of 'ISO_FORTRAN_ENV''s
     'STAT_STOPPED_IMAGE' and if the remote image has failed, the value
     'STAT_FAILED_IMAGE'.

_Standard_:
     TS 18508 or later

_Class_:
     Atomic subroutine

_Syntax_:
     'CALL ATOMIC_AND (ATOM, VALUE [, STAT])'

_Arguments_:
     ATOM        Scalar coarray or coindexed variable of integer
                 type with 'ATOMIC_INT_KIND' kind.
     VALUE       Scalar of the same type as ATOM.  If the kind is
                 different, the value is converted to the kind of
                 ATOM.
     STAT        (optional) Scalar default-kind integer variable.

_Example_:
          program atomic
            use iso_fortran_env
            integer(atomic_int_kind) :: atom[*]
            call atomic_and (atom[1], int(b'10100011101'))
          end program atomic

_See also_:
     *note ATOMIC_DEFINE::, *note ATOMIC_FETCH_AND::, *note
     ISO_FORTRAN_ENV::, *note ATOMIC_ADD::, *note ATOMIC_OR::, *note
     ATOMIC_XOR::


File: gfortran.info,  Node: ATOMIC_CAS,  Next: ATOMIC_DEFINE,  Prev: ATOMIC_AND,  Up: Intrinsic Procedures

9.30 'ATOMIC_CAS' -- Atomic compare and swap
============================================

_Description_:
     'ATOMIC_CAS' compares the variable ATOM with the value of COMPARE;
     if the value is the same, ATOM is set to the value of NEW.
     Additionally, OLD is set to the value of ATOM that was used for the
     comparison.  When STAT is present and the invocation was
     successful, it is assigned the value 0.  If it is present and the
     invocation has failed, it is assigned a positive value; in
     particular, for a coindexed ATOM, if the remote image has stopped,
     it is assigned the value of 'ISO_FORTRAN_ENV''s
     'STAT_STOPPED_IMAGE' and if the remote image has failed, the value
     'STAT_FAILED_IMAGE'.

_Standard_:
     TS 18508 or later

_Class_:
     Atomic subroutine

_Syntax_:
     'CALL ATOMIC_CAS (ATOM, OLD, COMPARE, NEW [, STAT])'

_Arguments_:
     ATOM        Scalar coarray or coindexed variable of either
                 integer type with 'ATOMIC_INT_KIND' kind or
                 logical type with 'ATOMIC_LOGICAL_KIND' kind.
     OLD         Scalar of the same type and kind as ATOM.
     COMPARE     Scalar variable of the same type and kind as
                 ATOM.
     NEW         Scalar variable of the same type as ATOM.  If
                 kind is different, the value is converted to the
                 kind of ATOM.
     STAT        (optional) Scalar default-kind integer variable.

_Example_:
          program atomic
            use iso_fortran_env
            logical(atomic_logical_kind) :: atom[*], prev
            call atomic_cas (atom[1], prev, .false., .true.))
          end program atomic

_See also_:
     *note ATOMIC_DEFINE::, *note ATOMIC_REF::, *note ISO_FORTRAN_ENV::


File: gfortran.info,  Node: ATOMIC_DEFINE,  Next: ATOMIC_FETCH_ADD,  Prev: ATOMIC_CAS,  Up: Intrinsic Procedures

9.31 'ATOMIC_DEFINE' -- Setting a variable atomically
=====================================================

_Description_:
     'ATOMIC_DEFINE(ATOM, VALUE)' defines the variable ATOM with the
     value VALUE atomically.  When STAT is present and the invocation
     was successful, it is assigned the value 0.  If it is present and
     the invocation has failed, it is assigned a positive value; in
     particular, for a coindexed ATOM, if the remote image has stopped,
     it is assigned the value of 'ISO_FORTRAN_ENV''s
     'STAT_STOPPED_IMAGE' and if the remote image has failed, the value
     'STAT_FAILED_IMAGE'.

_Standard_:
     Fortran 2008 and later; with STAT, TS 18508 or later

_Class_:
     Atomic subroutine

_Syntax_:
     'CALL ATOMIC_DEFINE (ATOM, VALUE [, STAT])'

_Arguments_:
     ATOM        Scalar coarray or coindexed variable of either
                 integer type with 'ATOMIC_INT_KIND' kind or
                 logical type with 'ATOMIC_LOGICAL_KIND' kind.
                 
     VALUE       Scalar of the same type as ATOM.  If the kind is
                 different, the value is converted to the kind of
                 ATOM.
     STAT        (optional) Scalar default-kind integer variable.

_Example_:
          program atomic
            use iso_fortran_env
            integer(atomic_int_kind) :: atom[*]
            call atomic_define (atom[1], this_image())
          end program atomic

_See also_:
     *note ATOMIC_REF::, *note ATOMIC_CAS::, *note ISO_FORTRAN_ENV::,
     *note ATOMIC_ADD::, *note ATOMIC_AND::, *note ATOMIC_OR::, *note
     ATOMIC_XOR::


File: gfortran.info,  Node: ATOMIC_FETCH_ADD,  Next: ATOMIC_FETCH_AND,  Prev: ATOMIC_DEFINE,  Up: Intrinsic Procedures

9.32 'ATOMIC_FETCH_ADD' -- Atomic ADD operation with prior fetch
================================================================

_Description_:
     'ATOMIC_FETCH_ADD(ATOM, VALUE, OLD)' atomically stores the value of
     ATOM in OLD and adds the value of VAR to the variable ATOM.  When
     STAT is present and the invocation was successful, it is assigned
     the value 0.  If it is present and the invocation has failed, it is
     assigned a positive value; in particular, for a coindexed ATOM, if
     the remote image has stopped, it is assigned the value of
     'ISO_FORTRAN_ENV''s 'STAT_STOPPED_IMAGE' and if the remote image
     has failed, the value 'STAT_FAILED_IMAGE'.

_Standard_:
     TS 18508 or later

_Class_:
     Atomic subroutine

_Syntax_:
     'CALL ATOMIC_FETCH_ADD (ATOM, VALUE, old [, STAT])'

_Arguments_:
     ATOM        Scalar coarray or coindexed variable of integer
                 type with 'ATOMIC_INT_KIND' kind.
                 'ATOMIC_LOGICAL_KIND' kind.
                 
     VALUE       Scalar of the same type as ATOM.  If the kind is
                 different, the value is converted to the kind of
                 ATOM.
     OLD         Scalar of the same type and kind as ATOM.
     STAT        (optional) Scalar default-kind integer variable.

_Example_:
          program atomic
            use iso_fortran_env
            integer(atomic_int_kind) :: atom[*], old
            call atomic_add (atom[1], this_image(), old)
          end program atomic

_See also_:
     *note ATOMIC_DEFINE::, *note ATOMIC_ADD::, *note ISO_FORTRAN_ENV::,
     *note ATOMIC_FETCH_AND::, *note ATOMIC_FETCH_OR::, *note
     ATOMIC_FETCH_XOR::


File: gfortran.info,  Node: ATOMIC_FETCH_AND,  Next: ATOMIC_FETCH_OR,  Prev: ATOMIC_FETCH_ADD,  Up: Intrinsic Procedures

9.33 'ATOMIC_FETCH_AND' -- Atomic bitwise AND operation with prior fetch
========================================================================

_Description_:
     'ATOMIC_AND(ATOM, VALUE)' atomically stores the value of ATOM in
     OLD and defines ATOM with the bitwise AND between the values of
     ATOM and VALUE.  When STAT is present and the invocation was
     successful, it is assigned the value 0.  If it is present and the
     invocation has failed, it is assigned a positive value; in
     particular, for a coindexed ATOM, if the remote image has stopped,
     it is assigned the value of 'ISO_FORTRAN_ENV''s
     'STAT_STOPPED_IMAGE' and if the remote image has failed, the value
     'STAT_FAILED_IMAGE'.

_Standard_:
     TS 18508 or later

_Class_:
     Atomic subroutine

_Syntax_:
     'CALL ATOMIC_FETCH_AND (ATOM, VALUE, OLD [, STAT])'

_Arguments_:
     ATOM        Scalar coarray or coindexed variable of integer
                 type with 'ATOMIC_INT_KIND' kind.
     VALUE       Scalar of the same type as ATOM.  If the kind is
                 different, the value is converted to the kind of
                 ATOM.
     OLD         Scalar of the same type and kind as ATOM.
     STAT        (optional) Scalar default-kind integer variable.

_Example_:
          program atomic
            use iso_fortran_env
            integer(atomic_int_kind) :: atom[*], old
            call atomic_fetch_and (atom[1], int(b'10100011101'), old)
          end program atomic

_See also_:
     *note ATOMIC_DEFINE::, *note ATOMIC_AND::, *note ISO_FORTRAN_ENV::,
     *note ATOMIC_FETCH_ADD::, *note ATOMIC_FETCH_OR::, *note
     ATOMIC_FETCH_XOR::


File: gfortran.info,  Node: ATOMIC_FETCH_OR,  Next: ATOMIC_FETCH_XOR,  Prev: ATOMIC_FETCH_AND,  Up: Intrinsic Procedures

9.34 'ATOMIC_FETCH_OR' -- Atomic bitwise OR operation with prior fetch
======================================================================

_Description_:
     'ATOMIC_OR(ATOM, VALUE)' atomically stores the value of ATOM in OLD
     and defines ATOM with the bitwise OR between the values of ATOM and
     VALUE.  When STAT is present and the invocation was successful, it
     is assigned the value 0.  If it is present and the invocation has
     failed, it is assigned a positive value; in particular, for a
     coindexed ATOM, if the remote image has stopped, it is assigned the
     value of 'ISO_FORTRAN_ENV''s 'STAT_STOPPED_IMAGE' and if the remote
     image has failed, the value 'STAT_FAILED_IMAGE'.

_Standard_:
     TS 18508 or later

_Class_:
     Atomic subroutine

_Syntax_:
     'CALL ATOMIC_FETCH_OR (ATOM, VALUE, OLD [, STAT])'

_Arguments_:
     ATOM        Scalar coarray or coindexed variable of integer
                 type with 'ATOMIC_INT_KIND' kind.
     VALUE       Scalar of the same type as ATOM.  If the kind is
                 different, the value is converted to the kind of
                 ATOM.
     OLD         Scalar of the same type and kind as ATOM.
     STAT        (optional) Scalar default-kind integer variable.

_Example_:
          program atomic
            use iso_fortran_env
            integer(atomic_int_kind) :: atom[*], old
            call atomic_fetch_or (atom[1], int(b'10100011101'), old)
          end program atomic

_See also_:
     *note ATOMIC_DEFINE::, *note ATOMIC_OR::, *note ISO_FORTRAN_ENV::,
     *note ATOMIC_FETCH_ADD::, *note ATOMIC_FETCH_AND::, *note
     ATOMIC_FETCH_XOR::


File: gfortran.info,  Node: ATOMIC_FETCH_XOR,  Next: ATOMIC_OR,  Prev: ATOMIC_FETCH_OR,  Up: Intrinsic Procedures

9.35 'ATOMIC_FETCH_XOR' -- Atomic bitwise XOR operation with prior fetch
========================================================================

_Description_:
     'ATOMIC_XOR(ATOM, VALUE)' atomically stores the value of ATOM in
     OLD and defines ATOM with the bitwise XOR between the values of
     ATOM and VALUE.  When STAT is present and the invocation was
     successful, it is assigned the value 0.  If it is present and the
     invocation has failed, it is assigned a positive value; in
     particular, for a coindexed ATOM, if the remote image has stopped,
     it is assigned the value of 'ISO_FORTRAN_ENV''s
     'STAT_STOPPED_IMAGE' and if the remote image has failed, the value
     'STAT_FAILED_IMAGE'.

_Standard_:
     TS 18508 or later

_Class_:
     Atomic subroutine

_Syntax_:
     'CALL ATOMIC_FETCH_XOR (ATOM, VALUE, OLD [, STAT])'

_Arguments_:
     ATOM        Scalar coarray or coindexed variable of integer
                 type with 'ATOMIC_INT_KIND' kind.
     VALUE       Scalar of the same type as ATOM.  If the kind is
                 different, the value is converted to the kind of
                 ATOM.
     OLD         Scalar of the same type and kind as ATOM.
     STAT        (optional) Scalar default-kind integer variable.

_Example_:
          program atomic
            use iso_fortran_env
            integer(atomic_int_kind) :: atom[*], old
            call atomic_fetch_xor (atom[1], int(b'10100011101'), old)
          end program atomic

_See also_:
     *note ATOMIC_DEFINE::, *note ATOMIC_XOR::, *note ISO_FORTRAN_ENV::,
     *note ATOMIC_FETCH_ADD::, *note ATOMIC_FETCH_AND::, *note
     ATOMIC_FETCH_OR::


File: gfortran.info,  Node: ATOMIC_OR,  Next: ATOMIC_REF,  Prev: ATOMIC_FETCH_XOR,  Up: Intrinsic Procedures

9.36 'ATOMIC_OR' -- Atomic bitwise OR operation
===============================================

_Description_:
     'ATOMIC_OR(ATOM, VALUE)' atomically defines ATOM with the bitwise
     AND between the values of ATOM and VALUE.  When STAT is present and
     the invocation was successful, it is assigned the value 0.  If it
     is present and the invocation has failed, it is assigned a positive
     value; in particular, for a coindexed ATOM, if the remote image has
     stopped, it is assigned the value of 'ISO_FORTRAN_ENV''s
     'STAT_STOPPED_IMAGE' and if the remote image has failed, the value
     'STAT_FAILED_IMAGE'.

_Standard_:
     TS 18508 or later

_Class_:
     Atomic subroutine

_Syntax_:
     'CALL ATOMIC_OR (ATOM, VALUE [, STAT])'

_Arguments_:
     ATOM        Scalar coarray or coindexed variable of integer
                 type with 'ATOMIC_INT_KIND' kind.
     VALUE       Scalar of the same type as ATOM.  If the kind is
                 different, the value is converted to the kind of
                 ATOM.
     STAT        (optional) Scalar default-kind integer variable.

_Example_:
          program atomic
            use iso_fortran_env
            integer(atomic_int_kind) :: atom[*]
            call atomic_or (atom[1], int(b'10100011101'))
          end program atomic

_See also_:
     *note ATOMIC_DEFINE::, *note ATOMIC_FETCH_OR::, *note
     ISO_FORTRAN_ENV::, *note ATOMIC_ADD::, *note ATOMIC_OR::, *note
     ATOMIC_XOR::


File: gfortran.info,  Node: ATOMIC_REF,  Next: ATOMIC_XOR,  Prev: ATOMIC_OR,  Up: Intrinsic Procedures

9.37 'ATOMIC_REF' -- Obtaining the value of a variable atomically
=================================================================

_Description_:
     'ATOMIC_DEFINE(ATOM, VALUE)' atomically assigns the value of the
     variable ATOM to VALUE.  When STAT is present and the invocation
     was successful, it is assigned the value 0.  If it is present and
     the invocation has failed, it is assigned a positive value; in
     particular, for a coindexed ATOM, if the remote image has stopped,
     it is assigned the value of 'ISO_FORTRAN_ENV''s
     'STAT_STOPPED_IMAGE' and if the remote image has failed, the value
     'STAT_FAILED_IMAGE'.

_Standard_:
     Fortran 2008 and later; with STAT, TS 18508 or later

_Class_:
     Atomic subroutine

_Syntax_:
     'CALL ATOMIC_REF(VALUE, ATOM [, STAT])'

_Arguments_:
     VALUE       Scalar of the same type as ATOM.  If the kind is
                 different, the value is converted to the kind of
                 ATOM.
     ATOM        Scalar coarray or coindexed variable of either
                 integer type with 'ATOMIC_INT_KIND' kind or
                 logical type with 'ATOMIC_LOGICAL_KIND' kind.
     STAT        (optional) Scalar default-kind integer variable.

_Example_:
          program atomic
            use iso_fortran_env
            logical(atomic_logical_kind) :: atom[*]
            logical :: val
            call atomic_ref (atom, .false.)
            ! ...
            call atomic_ref (atom, val)
            if (val) then
              print *, "Obtained"
            end if
          end program atomic

_See also_:
     *note ATOMIC_DEFINE::, *note ATOMIC_CAS::, *note ISO_FORTRAN_ENV::,
     *note ATOMIC_FETCH_ADD::, *note ATOMIC_FETCH_AND::, *note
     ATOMIC_FETCH_OR::, *note ATOMIC_FETCH_XOR::


File: gfortran.info,  Node: ATOMIC_XOR,  Next: BACKTRACE,  Prev: ATOMIC_REF,  Up: Intrinsic Procedures

9.38 'ATOMIC_XOR' -- Atomic bitwise OR operation
================================================

_Description_:
     'ATOMIC_AND(ATOM, VALUE)' atomically defines ATOM with the bitwise
     XOR between the values of ATOM and VALUE.  When STAT is present and
     the invocation was successful, it is assigned the value 0.  If it
     is present and the invocation has failed, it is assigned a positive
     value; in particular, for a coindexed ATOM, if the remote image has
     stopped, it is assigned the value of 'ISO_FORTRAN_ENV''s
     'STAT_STOPPED_IMAGE' and if the remote image has failed, the value
     'STAT_FAILED_IMAGE'.

_Standard_:
     TS 18508 or later

_Class_:
     Atomic subroutine

_Syntax_:
     'CALL ATOMIC_XOR (ATOM, VALUE [, STAT])'

_Arguments_:
     ATOM        Scalar coarray or coindexed variable of integer
                 type with 'ATOMIC_INT_KIND' kind.
     VALUE       Scalar of the same type as ATOM.  If the kind is
                 different, the value is converted to the kind of
                 ATOM.
     STAT        (optional) Scalar default-kind integer variable.

_Example_:
          program atomic
            use iso_fortran_env
            integer(atomic_int_kind) :: atom[*]
            call atomic_xor (atom[1], int(b'10100011101'))
          end program atomic

_See also_:
     *note ATOMIC_DEFINE::, *note ATOMIC_FETCH_XOR::, *note
     ISO_FORTRAN_ENV::, *note ATOMIC_ADD::, *note ATOMIC_OR::, *note
     ATOMIC_XOR::


File: gfortran.info,  Node: BACKTRACE,  Next: BESSEL_J0,  Prev: ATOMIC_XOR,  Up: Intrinsic Procedures

9.39 'BACKTRACE' -- Show a backtrace
====================================

_Description_:
     'BACKTRACE' shows a backtrace at an arbitrary place in user code.
     Program execution continues normally afterwards.  The backtrace
     information is printed to the unit corresponding to 'ERROR_UNIT' in
     'ISO_FORTRAN_ENV'.

_Standard_:
     GNU Extension

_Class_:
     Subroutine

_Syntax_:
     'CALL BACKTRACE'

_Arguments_:
     None

_See also_:
     *note ABORT::


File: gfortran.info,  Node: BESSEL_J0,  Next: BESSEL_J1,  Prev: BACKTRACE,  Up: Intrinsic Procedures

9.40 'BESSEL_J0' -- Bessel function of the first kind of order 0
================================================================

_Description_:
     'BESSEL_J0(X)' computes the Bessel function of the first kind of
     order 0 of X.  This function is available under the name 'BESJ0' as
     a GNU extension.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = BESSEL_J0(X)'

_Arguments_:
     X           The type shall be 'REAL'.

_Return value_:
     The return value is of type 'REAL' and lies in the range -
     0.4027... \leq Bessel (0,x) \leq 1.  It has the same kind as X.

_Example_:
          program test_besj0
            real(8) :: x = 0.0_8
            x = bessel_j0(x)
          end program test_besj0

_Specific names_:
     Name           Argument       Return type    Standard
     'DBESJ0(X)'    'REAL(8) X'    'REAL(8)'      GNU extension


File: gfortran.info,  Node: BESSEL_J1,  Next: BESSEL_JN,  Prev: BESSEL_J0,  Up: Intrinsic Procedures

9.41 'BESSEL_J1' -- Bessel function of the first kind of order 1
================================================================

_Description_:
     'BESSEL_J1(X)' computes the Bessel function of the first kind of
     order 1 of X.  This function is available under the name 'BESJ1' as
     a GNU extension.

_Standard_:
     Fortran 2008

_Class_:
     Elemental function

_Syntax_:
     'RESULT = BESSEL_J1(X)'

_Arguments_:
     X           The type shall be 'REAL'.

_Return value_:
     The return value is of type 'REAL' and lies in the range -
     0.5818... \leq Bessel (0,x) \leq 0.5818 .  It has the same kind as
     X.

_Example_:
          program test_besj1
            real(8) :: x = 1.0_8
            x = bessel_j1(x)
          end program test_besj1

_Specific names_:
     Name           Argument       Return type    Standard
     'DBESJ1(X)'    'REAL(8) X'    'REAL(8)'      GNU extension


File: gfortran.info,  Node: BESSEL_JN,  Next: BESSEL_Y0,  Prev: BESSEL_J1,  Up: Intrinsic Procedures

9.42 'BESSEL_JN' -- Bessel function of the first kind
=====================================================

_Description_:
     'BESSEL_JN(N, X)' computes the Bessel function of the first kind of
     order N of X.  This function is available under the name 'BESJN' as
     a GNU extension.  If N and X are arrays, their ranks and shapes
     shall conform.

     'BESSEL_JN(N1, N2, X)' returns an array with the Bessel functions
     of the first kind of the orders N1 to N2.

_Standard_:
     Fortran 2008 and later, negative N is allowed as GNU extension

_Class_:
     Elemental function, except for the transformational function
     'BESSEL_JN(N1, N2, X)'

_Syntax_:
     'RESULT = BESSEL_JN(N, X)'
     'RESULT = BESSEL_JN(N1, N2, X)'

_Arguments_:
     N           Shall be a scalar or an array of type 'INTEGER'.
     N1          Shall be a non-negative scalar of type
                 'INTEGER'.
     N2          Shall be a non-negative scalar of type
                 'INTEGER'.
     X           Shall be a scalar or an array of type 'REAL';
                 for 'BESSEL_JN(N1, N2, X)' it shall be scalar.

_Return value_:
     The return value is a scalar of type 'REAL'.  It has the same kind
     as X.

_Note_:
     The transformational function uses a recurrence algorithm which
     might, for some values of X, lead to different results than calls
     to the elemental function.

_Example_:
          program test_besjn
            real(8) :: x = 1.0_8
            x = bessel_jn(5,x)
          end program test_besjn

_Specific names_:
     Name           Argument       Return type    Standard
     'DBESJN(N,     'INTEGER N'    'REAL(8)'      GNU extension
     X)'
                    'REAL(8) X'


File: gfortran.info,  Node: BESSEL_Y0,  Next: BESSEL_Y1,  Prev: BESSEL_JN,  Up: Intrinsic Procedures

9.43 'BESSEL_Y0' -- Bessel function of the second kind of order 0
=================================================================

_Description_:
     'BESSEL_Y0(X)' computes the Bessel function of the second kind of
     order 0 of X.  This function is available under the name 'BESY0' as
     a GNU extension.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = BESSEL_Y0(X)'

_Arguments_:
     X           The type shall be 'REAL'.

_Return value_:
     The return value is of type 'REAL'.  It has the same kind as X.

_Example_:
          program test_besy0
            real(8) :: x = 0.0_8
            x = bessel_y0(x)
          end program test_besy0

_Specific names_:
     Name           Argument       Return type    Standard
     'DBESY0(X)'    'REAL(8) X'    'REAL(8)'      GNU extension


File: gfortran.info,  Node: BESSEL_Y1,  Next: BESSEL_YN,  Prev: BESSEL_Y0,  Up: Intrinsic Procedures

9.44 'BESSEL_Y1' -- Bessel function of the second kind of order 1
=================================================================

_Description_:
     'BESSEL_Y1(X)' computes the Bessel function of the second kind of
     order 1 of X.  This function is available under the name 'BESY1' as
     a GNU extension.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = BESSEL_Y1(X)'

_Arguments_:
     X           The type shall be 'REAL'.

_Return value_:
     The return value is of type 'REAL'.  It has the same kind as X.

_Example_:
          program test_besy1
            real(8) :: x = 1.0_8
            x = bessel_y1(x)
          end program test_besy1

_Specific names_:
     Name           Argument       Return type    Standard
     'DBESY1(X)'    'REAL(8) X'    'REAL(8)'      GNU extension


File: gfortran.info,  Node: BESSEL_YN,  Next: BGE,  Prev: BESSEL_Y1,  Up: Intrinsic Procedures

9.45 'BESSEL_YN' -- Bessel function of the second kind
======================================================

_Description_:
     'BESSEL_YN(N, X)' computes the Bessel function of the second kind
     of order N of X.  This function is available under the name 'BESYN'
     as a GNU extension.  If N and X are arrays, their ranks and shapes
     shall conform.

     'BESSEL_YN(N1, N2, X)' returns an array with the Bessel functions
     of the first kind of the orders N1 to N2.

_Standard_:
     Fortran 2008 and later, negative N is allowed as GNU extension

_Class_:
     Elemental function, except for the transformational function
     'BESSEL_YN(N1, N2, X)'

_Syntax_:
     'RESULT = BESSEL_YN(N, X)'
     'RESULT = BESSEL_YN(N1, N2, X)'

_Arguments_:
     N           Shall be a scalar or an array of type 'INTEGER'
                 .
     N1          Shall be a non-negative scalar of type
                 'INTEGER'.
     N2          Shall be a non-negative scalar of type
                 'INTEGER'.
     X           Shall be a scalar or an array of type 'REAL';
                 for 'BESSEL_YN(N1, N2, X)' it shall be scalar.

_Return value_:
     The return value is a scalar of type 'REAL'.  It has the same kind
     as X.

_Note_:
     The transformational function uses a recurrence algorithm which
     might, for some values of X, lead to different results than calls
     to the elemental function.

_Example_:
          program test_besyn
            real(8) :: x = 1.0_8
            x = bessel_yn(5,x)
          end program test_besyn

_Specific names_:
     Name           Argument       Return type    Standard
     'DBESYN(N,X)'  'INTEGER N'    'REAL(8)'      GNU extension
                    'REAL(8) X'


File: gfortran.info,  Node: BGE,  Next: BGT,  Prev: BESSEL_YN,  Up: Intrinsic Procedures

9.46 'BGE' -- Bitwise greater than or equal to
==============================================

_Description_:
     Determines whether an integral is a bitwise greater than or equal
     to another.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = BGE(I, J)'

_Arguments_:
     I           Shall be of 'INTEGER' type.
     J           Shall be of 'INTEGER' type, and of the same kind
                 as I.

_Return value_:
     The return value is of type 'LOGICAL' and of the default kind.

_See also_:
     *note BGT::, *note BLE::, *note BLT::


File: gfortran.info,  Node: BGT,  Next: BIT_SIZE,  Prev: BGE,  Up: Intrinsic Procedures

9.47 'BGT' -- Bitwise greater than
==================================

_Description_:
     Determines whether an integral is a bitwise greater than another.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = BGT(I, J)'

_Arguments_:
     I           Shall be of 'INTEGER' type.
     J           Shall be of 'INTEGER' type, and of the same kind
                 as I.

_Return value_:
     The return value is of type 'LOGICAL' and of the default kind.

_See also_:
     *note BGE::, *note BLE::, *note BLT::


File: gfortran.info,  Node: BIT_SIZE,  Next: BLE,  Prev: BGT,  Up: Intrinsic Procedures

9.48 'BIT_SIZE' -- Bit size inquiry function
============================================

_Description_:
     'BIT_SIZE(I)' returns the number of bits (integer precision plus
     sign bit) represented by the type of I.  The result of
     'BIT_SIZE(I)' is independent of the actual value of I.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = BIT_SIZE(I)'

_Arguments_:
     I           The type shall be 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER'

_Example_:
          program test_bit_size
              integer :: i = 123
              integer :: size
              size = bit_size(i)
              print *, size
          end program test_bit_size


File: gfortran.info,  Node: BLE,  Next: BLT,  Prev: BIT_SIZE,  Up: Intrinsic Procedures

9.49 'BLE' -- Bitwise less than or equal to
===========================================

_Description_:
     Determines whether an integral is a bitwise less than or equal to
     another.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = BLE(I, J)'

_Arguments_:
     I           Shall be of 'INTEGER' type.
     J           Shall be of 'INTEGER' type, and of the same kind
                 as I.

_Return value_:
     The return value is of type 'LOGICAL' and of the default kind.

_See also_:
     *note BGT::, *note BGE::, *note BLT::


File: gfortran.info,  Node: BLT,  Next: BTEST,  Prev: BLE,  Up: Intrinsic Procedures

9.50 'BLT' -- Bitwise less than
===============================

_Description_:
     Determines whether an integral is a bitwise less than another.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = BLT(I, J)'

_Arguments_:
     I           Shall be of 'INTEGER' type.
     J           Shall be of 'INTEGER' type, and of the same kind
                 as I.

_Return value_:
     The return value is of type 'LOGICAL' and of the default kind.

_See also_:
     *note BGE::, *note BGT::, *note BLE::


File: gfortran.info,  Node: BTEST,  Next: C_ASSOCIATED,  Prev: BLT,  Up: Intrinsic Procedures

9.51 'BTEST' -- Bit test function
=================================

_Description_:
     'BTEST(I,POS)' returns logical '.TRUE.' if the bit at POS in I is
     set.  The counting of the bits starts at 0.

_Standard_:
     Fortran 95 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = BTEST(I, POS)'

_Arguments_:
     I           The type shall be 'INTEGER'.
     POS         The type shall be 'INTEGER'.

_Return value_:
     The return value is of type 'LOGICAL'

_Example_:
          program test_btest
              integer :: i = 32768 + 1024 + 64
              integer :: pos
              logical :: bool
              do pos=0,16
                  bool = btest(i, pos)
                  print *, pos, bool
              end do
          end program test_btest

_Specific names_:
     Name           Argument       Return type    Standard
     'BTEST(I,POS)' 'INTEGER       'LOGICAL'      F95 and later
                    I,POS'
     'BBTEST(I,POS)''INTEGER(1)    'LOGICAL(1)'   GNU extension
                    I,POS'
     'BITEST(I,POS)''INTEGER(2)    'LOGICAL(2)'   GNU extension
                    I,POS'
     'BJTEST(I,POS)''INTEGER(4)    'LOGICAL(4)'   GNU extension
                    I,POS'
     'BKTEST(I,POS)''INTEGER(8)    'LOGICAL(8)'   GNU extension
                    I,POS'


File: gfortran.info,  Node: C_ASSOCIATED,  Next: C_F_POINTER,  Prev: BTEST,  Up: Intrinsic Procedures

9.52 'C_ASSOCIATED' -- Status of a C pointer
============================================

_Description_:
     'C_ASSOCIATED(c_ptr_1[, c_ptr_2])' determines the status of the C
     pointer C_PTR_1 or if C_PTR_1 is associated with the target
     C_PTR_2.

_Standard_:
     Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = C_ASSOCIATED(c_ptr_1[, c_ptr_2])'

_Arguments_:
     C_PTR_1     Scalar of the type 'C_PTR' or 'C_FUNPTR'.
     C_PTR_2     (Optional) Scalar of the same type as C_PTR_1.

_Return value_:
     The return value is of type 'LOGICAL'; it is '.false.' if either
     C_PTR_1 is a C NULL pointer or if C_PTR1 and C_PTR_2 point to
     different addresses.

_Example_:
          subroutine association_test(a,b)
            use iso_c_binding, only: c_associated, c_loc, c_ptr
            implicit none
            real, pointer :: a
            type(c_ptr) :: b
            if(c_associated(b, c_loc(a))) &
               stop 'b and a do not point to same target'
          end subroutine association_test

_See also_:
     *note C_LOC::, *note C_FUNLOC::


File: gfortran.info,  Node: C_F_POINTER,  Next: C_F_PROCPOINTER,  Prev: C_ASSOCIATED,  Up: Intrinsic Procedures

9.53 'C_F_POINTER' -- Convert C into Fortran pointer
====================================================

_Description_:
     'C_F_POINTER(CPTR, FPTR[, SHAPE])' assigns the target of the C
     pointer CPTR to the Fortran pointer FPTR and specifies its shape.

_Standard_:
     Fortran 2003 and later

_Class_:
     Subroutine

_Syntax_:
     'CALL C_F_POINTER(CPTR, FPTR[, SHAPE])'

_Arguments_:
     CPTR        scalar of the type 'C_PTR'.  It is 'INTENT(IN)'.
     FPTR        pointer interoperable with CPTR.  It is
                 'INTENT(OUT)'.
     SHAPE       (Optional) Rank-one array of type 'INTEGER' with
                 'INTENT(IN)'.  It shall be present if and only
                 if FPTR is an array.  The size must be equal to
                 the rank of FPTR.

_Example_:
          program main
            use iso_c_binding
            implicit none
            interface
              subroutine my_routine(p) bind(c,name='myC_func')
                import :: c_ptr
                type(c_ptr), intent(out) :: p
              end subroutine
            end interface
            type(c_ptr) :: cptr
            real,pointer :: a(:)
            call my_routine(cptr)
            call c_f_pointer(cptr, a, [12])
          end program main

_See also_:
     *note C_LOC::, *note C_F_PROCPOINTER::


File: gfortran.info,  Node: C_F_PROCPOINTER,  Next: C_FUNLOC,  Prev: C_F_POINTER,  Up: Intrinsic Procedures

9.54 'C_F_PROCPOINTER' -- Convert C into Fortran procedure pointer
==================================================================

_Description_:
     'C_F_PROCPOINTER(CPTR, FPTR)' Assign the target of the C function
     pointer CPTR to the Fortran procedure pointer FPTR.

_Standard_:
     Fortran 2003 and later

_Class_:
     Subroutine

_Syntax_:
     'CALL C_F_PROCPOINTER(cptr, fptr)'

_Arguments_:
     CPTR        scalar of the type 'C_FUNPTR'.  It is
                 'INTENT(IN)'.
     FPTR        procedure pointer interoperable with CPTR.  It
                 is 'INTENT(OUT)'.

_Example_:
          program main
            use iso_c_binding
            implicit none
            abstract interface
              function func(a)
                import :: c_float
                real(c_float), intent(in) :: a
                real(c_float) :: func
              end function
            end interface
            interface
               function getIterFunc() bind(c,name="getIterFunc")
                 import :: c_funptr
                 type(c_funptr) :: getIterFunc
               end function
            end interface
            type(c_funptr) :: cfunptr
            procedure(func), pointer :: myFunc
            cfunptr = getIterFunc()
            call c_f_procpointer(cfunptr, myFunc)
          end program main

_See also_:
     *note C_LOC::, *note C_F_POINTER::


File: gfortran.info,  Node: C_FUNLOC,  Next: C_LOC,  Prev: C_F_PROCPOINTER,  Up: Intrinsic Procedures

9.55 'C_FUNLOC' -- Obtain the C address of a procedure
======================================================

_Description_:
     'C_FUNLOC(x)' determines the C address of the argument.

_Standard_:
     Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = C_FUNLOC(x)'

_Arguments_:
     X           Interoperable function or pointer to such
                 function.

_Return value_:
     The return value is of type 'C_FUNPTR' and contains the C address
     of the argument.

_Example_:
          module x
            use iso_c_binding
            implicit none
          contains
            subroutine sub(a) bind(c)
              real(c_float) :: a
              a = sqrt(a)+5.0
            end subroutine sub
          end module x
          program main
            use iso_c_binding
            use x
            implicit none
            interface
              subroutine my_routine(p) bind(c,name='myC_func')
                import :: c_funptr
                type(c_funptr), intent(in) :: p
              end subroutine
            end interface
            call my_routine(c_funloc(sub))
          end program main

_See also_:
     *note C_ASSOCIATED::, *note C_LOC::, *note C_F_POINTER::, *note
     C_F_PROCPOINTER::


File: gfortran.info,  Node: C_LOC,  Next: C_SIZEOF,  Prev: C_FUNLOC,  Up: Intrinsic Procedures

9.56 'C_LOC' -- Obtain the C address of an object
=================================================

_Description_:
     'C_LOC(X)' determines the C address of the argument.

_Standard_:
     Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = C_LOC(X)'

_Arguments_:
     X       Shall have either the POINTER or TARGET attribute.
             It shall not be a coindexed object.  It shall either
             be a variable with interoperable type and kind type
             parameters, or be a scalar, nonpolymorphic variable
             with no length type parameters.
             

_Return value_:
     The return value is of type 'C_PTR' and contains the C address of
     the argument.

_Example_:
          subroutine association_test(a,b)
            use iso_c_binding, only: c_associated, c_loc, c_ptr
            implicit none
            real, pointer :: a
            type(c_ptr) :: b
            if(c_associated(b, c_loc(a))) &
               stop 'b and a do not point to same target'
          end subroutine association_test

_See also_:
     *note C_ASSOCIATED::, *note C_FUNLOC::, *note C_F_POINTER::, *note
     C_F_PROCPOINTER::


File: gfortran.info,  Node: C_SIZEOF,  Next: CEILING,  Prev: C_LOC,  Up: Intrinsic Procedures

9.57 'C_SIZEOF' -- Size in bytes of an expression
=================================================

_Description_:
     'C_SIZEOF(X)' calculates the number of bytes of storage the
     expression 'X' occupies.

_Standard_:
     Fortran 2008

_Class_:
     Inquiry function of the module 'ISO_C_BINDING'

_Syntax_:
     'N = C_SIZEOF(X)'

_Arguments_:
     X           The argument shall be an interoperable data
                 entity.

_Return value_:
     The return value is of type integer and of the system-dependent
     kind 'C_SIZE_T' (from the 'ISO_C_BINDING' module).  Its value is
     the number of bytes occupied by the argument.  If the argument has
     the 'POINTER' attribute, the number of bytes of the storage area
     pointed to is returned.  If the argument is of a derived type with
     'POINTER' or 'ALLOCATABLE' components, the return value does not
     account for the sizes of the data pointed to by these components.

_Example_:
             use iso_c_binding
             integer(c_int) :: i
             real(c_float) :: r, s(5)
             print *, (c_sizeof(s)/c_sizeof(r) == 5)
             end
     The example will print '.TRUE.' unless you are using a platform
     where default 'REAL' variables are unusually padded.

_See also_:
     *note SIZEOF::, *note STORAGE_SIZE::


File: gfortran.info,  Node: CEILING,  Next: CHAR,  Prev: C_SIZEOF,  Up: Intrinsic Procedures

9.58 'CEILING' -- Integer ceiling function
==========================================

_Description_:
     'CEILING(A)' returns the least integer greater than or equal to A.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = CEILING(A [, KIND])'

_Arguments_:
     A           The type shall be 'REAL'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER(KIND)' if KIND is present and
     a default-kind 'INTEGER' otherwise.

_Example_:
          program test_ceiling
              real :: x = 63.29
              real :: y = -63.59
              print *, ceiling(x) ! returns 64
              print *, ceiling(y) ! returns -63
          end program test_ceiling

_See also_:
     *note FLOOR::, *note NINT::


File: gfortran.info,  Node: CHAR,  Next: CHDIR,  Prev: CEILING,  Up: Intrinsic Procedures

9.59 'CHAR' -- Character conversion function
============================================

_Description_:
     'CHAR(I [, KIND])' returns the character represented by the integer
     I.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = CHAR(I [, KIND])'

_Arguments_:
     I           The type shall be 'INTEGER'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'CHARACTER(1)'

_Example_:
          program test_char
              integer :: i = 74
              character(1) :: c
              c = char(i)
              print *, i, c ! returns 'J'
          end program test_char

_Specific names_:
     Name           Argument       Return type    Standard
     'CHAR(I)'      'INTEGER I'    'CHARACTER(LEN=1)'F77 and later

_Note_:
     See *note ICHAR:: for a discussion of converting between numerical
     values and formatted string representations.

_See also_:
     *note ACHAR::, *note IACHAR::, *note ICHAR::


File: gfortran.info,  Node: CHDIR,  Next: CHMOD,  Prev: CHAR,  Up: Intrinsic Procedures

9.60 'CHDIR' -- Change working directory
========================================

_Description_:
     Change current working directory to a specified path.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL CHDIR(NAME [, STATUS])'
     'STATUS = CHDIR(NAME)'

_Arguments_:
     NAME        The type shall be 'CHARACTER' of default kind
                 and shall specify a valid path within the file
                 system.
     STATUS      (Optional) 'INTEGER' status flag of the default
                 kind.  Returns 0 on success, and a system
                 specific and nonzero error code otherwise.

_Example_:
          PROGRAM test_chdir
            CHARACTER(len=255) :: path
            CALL getcwd(path)
            WRITE(*,*) TRIM(path)
            CALL chdir("/tmp")
            CALL getcwd(path)
            WRITE(*,*) TRIM(path)
          END PROGRAM

_See also_:
     *note GETCWD::


File: gfortran.info,  Node: CHMOD,  Next: CMPLX,  Prev: CHDIR,  Up: Intrinsic Procedures

9.61 'CHMOD' -- Change access permissions of files
==================================================

_Description_:
     'CHMOD' changes the permissions of a file.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL CHMOD(NAME, MODE[, STATUS])'
     'STATUS = CHMOD(NAME, MODE)'

_Arguments_:

     NAME        Scalar 'CHARACTER' of default kind with the file
                 name.  Trailing blanks are ignored unless the
                 character 'achar(0)' is present, then all
                 characters up to and excluding 'achar(0)' are
                 used as the file name.
                 
     MODE        Scalar 'CHARACTER' of default kind giving the
                 file permission.  MODE uses the same syntax as
                 the 'chmod' utility as defined by the POSIX
                 standard.  The argument shall either be a string
                 of a nonnegative octal number or a symbolic
                 mode.
                 
     STATUS      (optional) scalar 'INTEGER', which is '0' on
                 success and nonzero otherwise.

_Return value_:
     In either syntax, STATUS is set to '0' on success and nonzero
     otherwise.

_Example_:
     'CHMOD' as subroutine
          program chmod_test
            implicit none
            integer :: status
            call chmod('test.dat','u+x',status)
            print *, 'Status: ', status
          end program chmod_test
     'CHMOD' as function:
          program chmod_test
            implicit none
            integer :: status
            status = chmod('test.dat','u+x')
            print *, 'Status: ', status
          end program chmod_test


File: gfortran.info,  Node: CMPLX,  Next: CO_BROADCAST,  Prev: CHMOD,  Up: Intrinsic Procedures

9.62 'CMPLX' -- Complex conversion function
===========================================

_Description_:
     'CMPLX(X [, Y [, KIND]])' returns a complex number where X is
     converted to the real component.  If Y is present it is converted
     to the imaginary component.  If Y is not present then the imaginary
     component is set to 0.0.  If X is complex then Y must not be
     present.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = CMPLX(X [, Y [, KIND]])'

_Arguments_:
     X           The type may be 'INTEGER', 'REAL', or 'COMPLEX'.
     Y           (Optional; only allowed if X is not 'COMPLEX'.)
                 May be 'INTEGER' or 'REAL'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of 'COMPLEX' type, with a kind equal to KIND if
     it is specified.  If KIND is not specified, the result is of the
     default 'COMPLEX' kind, regardless of the kinds of X and Y.

_Example_:
          program test_cmplx
              integer :: i = 42
              real :: x = 3.14
              complex :: z
              z = cmplx(i, x)
              print *, z, cmplx(x)
          end program test_cmplx

_See also_:
     *note COMPLEX::


File: gfortran.info,  Node: CO_BROADCAST,  Next: CO_MAX,  Prev: CMPLX,  Up: Intrinsic Procedures

9.63 'CO_BROADCAST' -- Copy a value to all images the current set of images
===========================================================================

_Description_:
     'CO_BROADCAST' copies the value of argument A on the image with
     image index 'SOURCE_IMAGE' to all images in the current team.  A
     becomes defined as if by intrinsic assignment.  If the execution
     was successful and STAT is present, it is assigned the value zero.
     If the execution failed, STAT gets assigned a nonzero value and, if
     present, ERRMSG gets assigned a value describing the occurred
     error.

_Standard_:
     Technical Specification (TS) 18508 or later

_Class_:
     Collective subroutine

_Syntax_:
     'CALL CO_BROADCAST(A, SOURCE_IMAGE [, STAT, ERRMSG])'

_Arguments_:
     A           INTENT(INOUT) argument; shall have the same
                 dynamic type and type paramters on all images of
                 the current team.  If it is an array, it shall
                 have the same shape on all images.
     SOURCE_IMAGEa scalar integer expression.  It shall have the
                 same the same value on all images and refer to
                 an image of the current team.
     STAT        (optional) a scalar integer variable
     ERRMSG      (optional) a scalar character variable

_Example_:
          program test
            integer :: val(3)
            if (this_image() == 1) then
              val = [1, 5, 3]
            end if
            call co_broadcast (val, source_image=1)
            print *, this_image, ":", val
          end program test

_See also_:
     *note CO_MAX::, *note CO_MIN::, *note CO_SUM::, *note CO_REDUCE::


File: gfortran.info,  Node: CO_MAX,  Next: CO_MIN,  Prev: CO_BROADCAST,  Up: Intrinsic Procedures

9.64 'CO_MAX' -- Maximal value on the current set of images
===========================================================

_Description_:
     'CO_MAX' determines element-wise the maximal value of A on all
     images of the current team.  If RESULT_IMAGE is present, the
     maximum values are returned in A on the specified image only and
     the value of A on the other images become undefined.  If
     RESULT_IMAGE is not present, the value is returned on all images.
     If the execution was successful and STAT is present, it is assigned
     the value zero.  If the execution failed, STAT gets assigned a
     nonzero value and, if present, ERRMSG gets assigned a value
     describing the occurred error.

_Standard_:
     Technical Specification (TS) 18508 or later

_Class_:
     Collective subroutine

_Syntax_:
     'CALL CO_MAX(A [, RESULT_IMAGE, STAT, ERRMSG])'

_Arguments_:
     A           shall be an integer, real or character variable,
                 which has the same type and type parameters on
                 all images of the team.
     RESULT_IMAGE(optional) a scalar integer expression; if
                 present, it shall have the same the same value
                 on all images and refer to an image of the
                 current team.
     STAT        (optional) a scalar integer variable
     ERRMSG      (optional) a scalar character variable

_Example_:
          program test
            integer :: val
            val = this_image ()
            call co_max (val, result_image=1)
            if (this_image() == 1) then
              write(*,*) "Maximal value", val  ! prints num_images()
            end if
          end program test

_See also_:
     *note CO_MIN::, *note CO_SUM::, *note CO_REDUCE::, *note
     CO_BROADCAST::


File: gfortran.info,  Node: CO_MIN,  Next: CO_REDUCE,  Prev: CO_MAX,  Up: Intrinsic Procedures

9.65 'CO_MIN' -- Minimal value on the current set of images
===========================================================

_Description_:
     'CO_MIN' determines element-wise the minimal value of A on all
     images of the current team.  If RESULT_IMAGE is present, the
     minimal values are returned in A on the specified image only and
     the value of A on the other images become undefined.  If
     RESULT_IMAGE is not present, the value is returned on all images.
     If the execution was successful and STAT is present, it is assigned
     the value zero.  If the execution failed, STAT gets assigned a
     nonzero value and, if present, ERRMSG gets assigned a value
     describing the occurred error.

_Standard_:
     Technical Specification (TS) 18508 or later

_Class_:
     Collective subroutine

_Syntax_:
     'CALL CO_MIN(A [, RESULT_IMAGE, STAT, ERRMSG])'

_Arguments_:
     A           shall be an integer, real or character variable,
                 which has the same type and type parameters on
                 all images of the team.
     RESULT_IMAGE(optional) a scalar integer expression; if
                 present, it shall have the same the same value
                 on all images and refer to an image of the
                 current team.
     STAT        (optional) a scalar integer variable
     ERRMSG      (optional) a scalar character variable

_Example_:
          program test
            integer :: val
            val = this_image ()
            call co_min (val, result_image=1)
            if (this_image() == 1) then
              write(*,*) "Minimal value", val  ! prints 1
            end if
          end program test

_See also_:
     *note CO_MAX::, *note CO_SUM::, *note CO_REDUCE::, *note
     CO_BROADCAST::


File: gfortran.info,  Node: CO_REDUCE,  Next: CO_SUM,  Prev: CO_MIN,  Up: Intrinsic Procedures

9.66 'CO_REDUCE' -- Reduction of values on the current set of images
====================================================================

_Description_:
     'CO_REDUCE' determines element-wise the reduction of the value of A
     on all images of the current team.  The pure function passed as
     OPERATOR is used to pairwise reduce the values of A by passing
     either the value of A of different images or the result values of
     such a reduction as argument.  If A is an array, the deduction is
     done element wise.  If RESULT_IMAGE is present, the result values
     are returned in A on the specified image only and the value of A on
     the other images become undefined.  If RESULT_IMAGE is not present,
     the value is returned on all images.  If the execution was
     successful and STAT is present, it is assigned the value zero.  If
     the execution failed, STAT gets assigned a nonzero value and, if
     present, ERRMSG gets assigned a value describing the occurred
     error.

_Standard_:
     Technical Specification (TS) 18508 or later

_Class_:
     Collective subroutine

_Syntax_:
     'CALL CO_REDUCE(A, OPERATOR, [, RESULT_IMAGE, STAT, ERRMSG])'

_Arguments_:
     A           is an 'INTENT(INOUT)' argument and shall be
                 nonpolymorphic.  If it is allocatable, it shall
                 be allocated; if it is a pointer, it shall be
                 associated.  A shall have the same type and type
                 parameters on all images of the team; if it is
                 an array, it shall have the same shape on all
                 images.
     OPERATOR    pure function with two scalar nonallocatable
                 arguments, which shall be nonpolymorphic and
                 have the same type and type parameters as A.
                 The function shall return a nonallocatable
                 scalar of the same type and type parameters as
                 A.  The function shall be the same on all images
                 and with regards to the arguments mathematically
                 commutative and associative.  Note that OPERATOR
                 may not be an elemental function, unless it is
                 an intrisic function.
     RESULT_IMAGE(optional) a scalar integer expression; if
                 present, it shall have the same the same value
                 on all images and refer to an image of the
                 current team.
     STAT        (optional) a scalar integer variable
     ERRMSG      (optional) a scalar character variable

_Example_:
          program test
            integer :: val
            val = this_image ()
            call co_reduce (val, result_image=1, operator=myprod)
            if (this_image() == 1) then
              write(*,*) "Product value", val  ! prints num_images() factorial
            end if
          contains
            pure function myprod(a, b)
              integer, value :: a, b
              integer :: myprod
              myprod = a * b
            end function myprod
          end program test

_Note_:
     While the rules permit in principle an intrinsic function, none of
     the intrinsics in the standard fulfill the criteria of having a
     specific function, which takes two arguments of the same type and
     returning that type as result.

_See also_:
     *note CO_MIN::, *note CO_MAX::, *note CO_SUM::, *note
     CO_BROADCAST::


File: gfortran.info,  Node: CO_SUM,  Next: COMMAND_ARGUMENT_COUNT,  Prev: CO_REDUCE,  Up: Intrinsic Procedures

9.67 'CO_SUM' -- Sum of values on the current set of images
===========================================================

_Description_:
     'CO_SUM' sums up the values of each element of A on all images of
     the current team.  If RESULT_IMAGE is present, the summed-up values
     are returned in A on the specified image only and the value of A on
     the other images become undefined.  If RESULT_IMAGE is not present,
     the value is returned on all images.  If the execution was
     successful and STAT is present, it is assigned the value zero.  If
     the execution failed, STAT gets assigned a nonzero value and, if
     present, ERRMSG gets assigned a value describing the occurred
     error.

_Standard_:
     Technical Specification (TS) 18508 or later

_Class_:
     Collective subroutine

_Syntax_:
     'CALL CO_MIN(A [, RESULT_IMAGE, STAT, ERRMSG])'

_Arguments_:
     A           shall be an integer, real or complex variable,
                 which has the same type and type parameters on
                 all images of the team.
     RESULT_IMAGE(optional) a scalar integer expression; if
                 present, it shall have the same the same value
                 on all images and refer to an image of the
                 current team.
     STAT        (optional) a scalar integer variable
     ERRMSG      (optional) a scalar character variable

_Example_:
          program test
            integer :: val
            val = this_image ()
            call co_sum (val, result_image=1)
            if (this_image() == 1) then
              write(*,*) "The sum is ", val ! prints (n**2 + n)/2, with n = num_images()
            end if
          end program test

_See also_:
     *note CO_MAX::, *note CO_MIN::, *note CO_REDUCE::, *note
     CO_BROADCAST::


File: gfortran.info,  Node: COMMAND_ARGUMENT_COUNT,  Next: COMPILER_OPTIONS,  Prev: CO_SUM,  Up: Intrinsic Procedures

9.68 'COMMAND_ARGUMENT_COUNT' -- Get number of command line arguments
=====================================================================

_Description_:
     'COMMAND_ARGUMENT_COUNT' returns the number of arguments passed on
     the command line when the containing program was invoked.

_Standard_:
     Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = COMMAND_ARGUMENT_COUNT()'

_Arguments_:
     None

_Return value_:
     The return value is an 'INTEGER' of default kind.

_Example_:
          program test_command_argument_count
              integer :: count
              count = command_argument_count()
              print *, count
          end program test_command_argument_count

_See also_:
     *note GET_COMMAND::, *note GET_COMMAND_ARGUMENT::


File: gfortran.info,  Node: COMPILER_OPTIONS,  Next: COMPILER_VERSION,  Prev: COMMAND_ARGUMENT_COUNT,  Up: Intrinsic Procedures

9.69 'COMPILER_OPTIONS' -- Options passed to the compiler
=========================================================

_Description_:
     'COMPILER_OPTIONS' returns a string with the options used for
     compiling.

_Standard_:
     Fortran 2008

_Class_:
     Inquiry function of the module 'ISO_FORTRAN_ENV'

_Syntax_:
     'STR = COMPILER_OPTIONS()'

_Arguments_:
     None.

_Return value_:
     The return value is a default-kind string with system-dependent
     length.  It contains the compiler flags used to compile the file,
     which called the 'COMPILER_OPTIONS' intrinsic.

_Example_:
             use iso_fortran_env
             print '(4a)', 'This file was compiled by ', &
                           compiler_version(), ' using the options ', &
                           compiler_options()
             end

_See also_:
     *note COMPILER_VERSION::, *note ISO_FORTRAN_ENV::


File: gfortran.info,  Node: COMPILER_VERSION,  Next: COMPLEX,  Prev: COMPILER_OPTIONS,  Up: Intrinsic Procedures

9.70 'COMPILER_VERSION' -- Compiler version string
==================================================

_Description_:
     'COMPILER_VERSION' returns a string with the name and the version
     of the compiler.

_Standard_:
     Fortran 2008

_Class_:
     Inquiry function of the module 'ISO_FORTRAN_ENV'

_Syntax_:
     'STR = COMPILER_VERSION()'

_Arguments_:
     None.

_Return value_:
     The return value is a default-kind string with system-dependent
     length.  It contains the name of the compiler and its version
     number.

_Example_:
             use iso_fortran_env
             print '(4a)', 'This file was compiled by ', &
                           compiler_version(), ' using the options ', &
                           compiler_options()
             end

_See also_:
     *note COMPILER_OPTIONS::, *note ISO_FORTRAN_ENV::


File: gfortran.info,  Node: COMPLEX,  Next: CONJG,  Prev: COMPILER_VERSION,  Up: Intrinsic Procedures

9.71 'COMPLEX' -- Complex conversion function
=============================================

_Description_:
     'COMPLEX(X, Y)' returns a complex number where X is converted to
     the real component and Y is converted to the imaginary component.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     'RESULT = COMPLEX(X, Y)'

_Arguments_:
     X           The type may be 'INTEGER' or 'REAL'.
     Y           The type may be 'INTEGER' or 'REAL'.

_Return value_:
     If X and Y are both of 'INTEGER' type, then the return value is of
     default 'COMPLEX' type.

     If X and Y are of 'REAL' type, or one is of 'REAL' type and one is
     of 'INTEGER' type, then the return value is of 'COMPLEX' type with
     a kind equal to that of the 'REAL' argument with the highest
     precision.

_Example_:
          program test_complex
              integer :: i = 42
              real :: x = 3.14
              print *, complex(i, x)
          end program test_complex

_See also_:
     *note CMPLX::


File: gfortran.info,  Node: CONJG,  Next: COS,  Prev: COMPLEX,  Up: Intrinsic Procedures

9.72 'CONJG' -- Complex conjugate function
==========================================

_Description_:
     'CONJG(Z)' returns the conjugate of Z.  If Z is '(x, y)' then the
     result is '(x, -y)'

_Standard_:
     Fortran 77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'Z = CONJG(Z)'

_Arguments_:
     Z           The type shall be 'COMPLEX'.

_Return value_:
     The return value is of type 'COMPLEX'.

_Example_:
          program test_conjg
              complex :: z = (2.0, 3.0)
              complex(8) :: dz = (2.71_8, -3.14_8)
              z= conjg(z)
              print *, z
              dz = dconjg(dz)
              print *, dz
          end program test_conjg

_Specific names_:
     Name           Argument       Return type    Standard
     'CONJG(Z)'     'COMPLEX Z'    'COMPLEX'      GNU extension
     'DCONJG(Z)'    'COMPLEX(8)    'COMPLEX(8)'   GNU extension
                    Z'


File: gfortran.info,  Node: COS,  Next: COSD,  Prev: CONJG,  Up: Intrinsic Procedures

9.73 'COS' -- Cosine function
=============================

_Description_:
     'COS(X)' computes the cosine of X.

_Standard_:
     Fortran 77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = COS(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value is of the same type and kind as X.  The real part
     of the result is in radians.  If X is of the type 'REAL', the
     return value lies in the range -1 \leq \cos (x) \leq 1.

_Example_:
          program test_cos
            real :: x = 0.0
            x = cos(x)
          end program test_cos

_Specific names_:
     Name           Argument       Return type    Standard
     'COS(X)'       'REAL(4) X'    'REAL(4)'      Fortran 77 and
                                                  later
     'DCOS(X)'      'REAL(8) X'    'REAL(8)'      Fortran 77 and
                                                  later
     'CCOS(X)'      'COMPLEX(4)    'COMPLEX(4)'   Fortran 77 and
                    X'                            later
     'ZCOS(X)'      'COMPLEX(8)    'COMPLEX(8)'   GNU extension
                    X'
     'CDCOS(X)'     'COMPLEX(8)    'COMPLEX(8)'   GNU extension
                    X'

_See also_:
     Inverse function: *note ACOS:: Degrees function: *note COSD::


File: gfortran.info,  Node: COSD,  Next: COSH,  Prev: COS,  Up: Intrinsic Procedures

9.74 'COSD' -- Cosine function, degrees
=======================================

_Description_:
     'COSD(X)' computes the cosine of X in degrees.

     This function is for compatibility only and should be avoided in
     favor of standard constructs wherever possible.

_Standard_:
     GNU Extension, enabled with '-fdec-math'.

_Class_:
     Elemental function

_Syntax_:
     'RESULT = COSD(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value is of the same type and kind as X.  The real part
     of the result is in degrees.  If X is of the type 'REAL', the
     return value lies in the range -1 \leq \cosd (x) \leq 1.

_Example_:
          program test_cosd
            real :: x = 0.0
            x = cosd(x)
          end program test_cosd

_Specific names_:
     Name           Argument       Return type    Standard
     'COSD(X)'      'REAL(4) X'    'REAL(4)'      GNU Extension
     'DCOSD(X)'     'REAL(8) X'    'REAL(8)'      GNU Extension
     'CCOSD(X)'     'COMPLEX(4)    'COMPLEX(4)'   GNU Extension
                    X'
     'ZCOSD(X)'     'COMPLEX(8)    'COMPLEX(8)'   GNU extension
                    X'
     'CDCOSD(X)'    'COMPLEX(8)    'COMPLEX(8)'   GNU extension
                    X'

_See also_:
     Inverse function: *note ACOSD:: Radians function: *note COS::


File: gfortran.info,  Node: COSH,  Next: COTAN,  Prev: COSD,  Up: Intrinsic Procedures

9.75 'COSH' -- Hyperbolic cosine function
=========================================

_Description_:
     'COSH(X)' computes the hyperbolic cosine of X.

_Standard_:
     Fortran 77 and later, for a complex argument Fortran 2008 or later

_Class_:
     Elemental function

_Syntax_:
     'X = COSH(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value has same type and kind as X.  If X is complex, the
     imaginary part of the result is in radians.  If X is 'REAL', the
     return value has a lower bound of one, \cosh (x) \geq 1.

_Example_:
          program test_cosh
            real(8) :: x = 1.0_8
            x = cosh(x)
          end program test_cosh

_Specific names_:
     Name           Argument       Return type    Standard
     'COSH(X)'      'REAL(4) X'    'REAL(4)'      Fortran 77 and
                                                  later
     'DCOSH(X)'     'REAL(8) X'    'REAL(8)'      Fortran 77 and
                                                  later

_See also_:
     Inverse function: *note ACOSH::


File: gfortran.info,  Node: COTAN,  Next: COTAND,  Prev: COSH,  Up: Intrinsic Procedures

9.76 'COTAN' -- Cotangent function
==================================

_Description_:
     'COTAN(X)' computes the cotangent of X.  Equivalent to 'COS(x)'
     divided by 'SIN(x)', or '1 / TAN(x)'.

     This function is for compatibility only and should be avoided in
     favor of standard constructs wherever possible.

_Standard_:
     GNU Extension, enabled with '-fdec-math'.

_Class_:
     Elemental function

_Syntax_:
     'RESULT = COTAN(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value has same type and kind as X, and its value is in
     radians.

_Example_:
          program test_cotan
            real(8) :: x = 0.165_8
            x = cotan(x)
          end program test_cotan

_Specific names_:
     Name           Argument       Return type    Standard
     'COTAN(X)'     'REAL(4) X'    'REAL(4)'      GNU Extension
     'DCOTAN(X)'    'REAL(8) X'    'REAL(8)'      GNU Extension

_See also_:
     Converse function: *note TAN:: Degrees function: *note COTAND::


File: gfortran.info,  Node: COTAND,  Next: COUNT,  Prev: COTAN,  Up: Intrinsic Procedures

9.77 'COTAND' -- Cotangent function, degrees
============================================

_Description_:
     'COTAND(X)' computes the cotangent of X in degrees.  Equivalent to
     'COSD(x)' divided by 'SIND(x)', or '1 / TAND(x)'.

_Standard_:
     GNU Extension, enabled with '-fdec-math'.

     This function is for compatibility only and should be avoided in
     favor of standard constructs wherever possible.

_Class_:
     Elemental function

_Syntax_:
     'RESULT = COTAND(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value has same type and kind as X, and its value is in
     degrees.

_Example_:
          program test_cotand
            real(8) :: x = 0.165_8
            x = cotand(x)
          end program test_cotand

_Specific names_:
     Name           Argument       Return type    Standard
     'COTAND(X)'    'REAL(4) X'    'REAL(4)'      GNU Extension
     'DCOTAND(X)'   'REAL(8) X'    'REAL(8)'      GNU Extension

_See also_:
     Converse function: *note TAND:: Radians function: *note COTAN::


File: gfortran.info,  Node: COUNT,  Next: CPU_TIME,  Prev: COTAND,  Up: Intrinsic Procedures

9.78 'COUNT' -- Count function
==============================

_Description_:

     Counts the number of '.TRUE.' elements in a logical MASK, or, if
     the DIM argument is supplied, counts the number of elements along
     each row of the array in the DIM direction.  If the array has zero
     size, or all of the elements of MASK are '.FALSE.', then the result
     is '0'.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = COUNT(MASK [, DIM, KIND])'

_Arguments_:
     MASK        The type shall be 'LOGICAL'.
     DIM         (Optional) The type shall be 'INTEGER'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER' and of kind KIND.  If KIND is
     absent, the return value is of default integer kind.  If DIM is
     present, the result is an array with a rank one less than the rank
     of ARRAY, and a size corresponding to the shape of ARRAY with the
     DIM dimension removed.

_Example_:
          program test_count
              integer, dimension(2,3) :: a, b
              logical, dimension(2,3) :: mask
              a = reshape( (/ 1, 2, 3, 4, 5, 6 /), (/ 2, 3 /))
              b = reshape( (/ 0, 7, 3, 4, 5, 8 /), (/ 2, 3 /))
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print *
              print '(3i3)', b(1,:)
              print '(3i3)', b(2,:)
              print *
              mask = a.ne.b
              print '(3l3)', mask(1,:)
              print '(3l3)', mask(2,:)
              print *
              print '(3i3)', count(mask)
              print *
              print '(3i3)', count(mask, 1)
              print *
              print '(3i3)', count(mask, 2)
          end program test_count


File: gfortran.info,  Node: CPU_TIME,  Next: CSHIFT,  Prev: COUNT,  Up: Intrinsic Procedures

9.79 'CPU_TIME' -- CPU elapsed time in seconds
==============================================

_Description_:
     Returns a 'REAL' value representing the elapsed CPU time in
     seconds.  This is useful for testing segments of code to determine
     execution time.

     If a time source is available, time will be reported with
     microsecond resolution.  If no time source is available, TIME is
     set to '-1.0'.

     Note that TIME may contain a, system dependent, arbitrary offset
     and may not start with '0.0'.  For 'CPU_TIME', the absolute value
     is meaningless, only differences between subsequent calls to this
     subroutine, as shown in the example below, should be used.

_Standard_:
     Fortran 95 and later

_Class_:
     Subroutine

_Syntax_:
     'CALL CPU_TIME(TIME)'

_Arguments_:
     TIME        The type shall be 'REAL' with 'INTENT(OUT)'.

_Return value_:
     None

_Example_:
          program test_cpu_time
              real :: start, finish
              call cpu_time(start)
                  ! put code to test here
              call cpu_time(finish)
              print '("Time = ",f6.3," seconds.")',finish-start
          end program test_cpu_time

_See also_:
     *note SYSTEM_CLOCK::, *note DATE_AND_TIME::


File: gfortran.info,  Node: CSHIFT,  Next: CTIME,  Prev: CPU_TIME,  Up: Intrinsic Procedures

9.80 'CSHIFT' -- Circular shift elements of an array
====================================================

_Description_:
     'CSHIFT(ARRAY, SHIFT [, DIM])' performs a circular shift on
     elements of ARRAY along the dimension of DIM.  If DIM is omitted it
     is taken to be '1'.  DIM is a scalar of type 'INTEGER' in the range
     of 1 \leq DIM \leq n) where n is the rank of ARRAY.  If the rank of
     ARRAY is one, then all elements of ARRAY are shifted by SHIFT
     places.  If rank is greater than one, then all complete rank one
     sections of ARRAY along the given dimension are shifted.  Elements
     shifted out one end of each rank one section are shifted back in
     the other end.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = CSHIFT(ARRAY, SHIFT [, DIM])'

_Arguments_:
     ARRAY       Shall be an array of any type.
     SHIFT       The type shall be 'INTEGER'.
     DIM         The type shall be 'INTEGER'.

_Return value_:
     Returns an array of same type and rank as the ARRAY argument.

_Example_:
          program test_cshift
              integer, dimension(3,3) :: a
              a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
              a = cshift(a, SHIFT=(/1, 2, -1/), DIM=2)
              print *
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
          end program test_cshift


File: gfortran.info,  Node: CTIME,  Next: DATE_AND_TIME,  Prev: CSHIFT,  Up: Intrinsic Procedures

9.81 'CTIME' -- Convert a time into a string
============================================

_Description_:
     'CTIME' converts a system time value, such as returned by *note
     TIME8::, to a string.  The output will be of the form 'Sat Aug 19
     18:13:14 1995'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL CTIME(TIME, RESULT)'.
     'RESULT = CTIME(TIME)'.

_Arguments_:
     TIME        The type shall be of type 'INTEGER'.
     RESULT      The type shall be of type 'CHARACTER' and of
                 default kind.  It is an 'INTENT(OUT)' argument.
                 If the length of this variable is too short for
                 the time and date string to fit completely, it
                 will be blank on procedure return.

_Return value_:
     The converted date and time as a string.

_Example_:
          program test_ctime
              integer(8) :: i
              character(len=30) :: date
              i = time8()

              ! Do something, main part of the program

              call ctime(i,date)
              print *, 'Program was started on ', date
          end program test_ctime

_See Also_:
     *note DATE_AND_TIME::, *note GMTIME::, *note LTIME::, *note TIME::,
     *note TIME8::


File: gfortran.info,  Node: DATE_AND_TIME,  Next: DBLE,  Prev: CTIME,  Up: Intrinsic Procedures

9.82 'DATE_AND_TIME' -- Date and time subroutine
================================================

_Description_:
     'DATE_AND_TIME(DATE, TIME, ZONE, VALUES)' gets the corresponding
     date and time information from the real-time system clock.  DATE is
     'INTENT(OUT)' and has form ccyymmdd.  TIME is 'INTENT(OUT)' and has
     form hhmmss.sss.  ZONE is 'INTENT(OUT)' and has form (+-)hhmm,
     representing the difference with respect to Coordinated Universal
     Time (UTC). Unavailable time and date parameters return blanks.

     VALUES is 'INTENT(OUT)' and provides the following:

                 'VALUE(1)':            The year
                 'VALUE(2)':            The month
                 'VALUE(3)':            The day of the month
                 'VALUE(4)':            Time difference with UTC in
                                        minutes
                 'VALUE(5)':            The hour of the day
                 'VALUE(6)':            The minutes of the hour
                 'VALUE(7)':            The seconds of the minute
                 'VALUE(8)':            The milliseconds of the
                                        second

_Standard_:
     Fortran 95 and later

_Class_:
     Subroutine

_Syntax_:
     'CALL DATE_AND_TIME([DATE, TIME, ZONE, VALUES])'

_Arguments_:
     DATE        (Optional) The type shall be 'CHARACTER(LEN=8)'
                 or larger, and of default kind.
     TIME        (Optional) The type shall be 'CHARACTER(LEN=10)'
                 or larger, and of default kind.
     ZONE        (Optional) The type shall be 'CHARACTER(LEN=5)'
                 or larger, and of default kind.
     VALUES      (Optional) The type shall be 'INTEGER(8)'.

_Return value_:
     None

_Example_:
          program test_time_and_date
              character(8)  :: date
              character(10) :: time
              character(5)  :: zone
              integer,dimension(8) :: values
              ! using keyword arguments
              call date_and_time(date,time,zone,values)
              call date_and_time(DATE=date,ZONE=zone)
              call date_and_time(TIME=time)
              call date_and_time(VALUES=values)
              print '(a,2x,a,2x,a)', date, time, zone
              print '(8i5)', values
          end program test_time_and_date

_See also_:
     *note CPU_TIME::, *note SYSTEM_CLOCK::


File: gfortran.info,  Node: DBLE,  Next: DCMPLX,  Prev: DATE_AND_TIME,  Up: Intrinsic Procedures

9.83 'DBLE' -- Double conversion function
=========================================

_Description_:
     'DBLE(A)' Converts A to double precision real type.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = DBLE(A)'

_Arguments_:
     A           The type shall be 'INTEGER', 'REAL', or
                 'COMPLEX'.

_Return value_:
     The return value is of type double precision real.

_Example_:
          program test_dble
              real    :: x = 2.18
              integer :: i = 5
              complex :: z = (2.3,1.14)
              print *, dble(x), dble(i), dble(z)
          end program test_dble

_See also_:
     *note REAL::


File: gfortran.info,  Node: DCMPLX,  Next: DIGITS,  Prev: DBLE,  Up: Intrinsic Procedures

9.84 'DCMPLX' -- Double complex conversion function
===================================================

_Description_:
     'DCMPLX(X [,Y])' returns a double complex number where X is
     converted to the real component.  If Y is present it is converted
     to the imaginary component.  If Y is not present then the imaginary
     component is set to 0.0.  If X is complex then Y must not be
     present.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     'RESULT = DCMPLX(X [, Y])'

_Arguments_:
     X           The type may be 'INTEGER', 'REAL', or 'COMPLEX'.
     Y           (Optional if X is not 'COMPLEX'.)  May be
                 'INTEGER' or 'REAL'.

_Return value_:
     The return value is of type 'COMPLEX(8)'

_Example_:
          program test_dcmplx
              integer :: i = 42
              real :: x = 3.14
              complex :: z
              z = cmplx(i, x)
              print *, dcmplx(i)
              print *, dcmplx(x)
              print *, dcmplx(z)
              print *, dcmplx(x,i)
          end program test_dcmplx


File: gfortran.info,  Node: DIGITS,  Next: DIM,  Prev: DCMPLX,  Up: Intrinsic Procedures

9.85 'DIGITS' -- Significant binary digits function
===================================================

_Description_:
     'DIGITS(X)' returns the number of significant binary digits of the
     internal model representation of X.  For example, on a system using
     a 32-bit floating point representation, a default real number would
     likely return 24.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = DIGITS(X)'

_Arguments_:
     X           The type may be 'INTEGER' or 'REAL'.

_Return value_:
     The return value is of type 'INTEGER'.

_Example_:
          program test_digits
              integer :: i = 12345
              real :: x = 3.143
              real(8) :: y = 2.33
              print *, digits(i)
              print *, digits(x)
              print *, digits(y)
          end program test_digits


File: gfortran.info,  Node: DIM,  Next: DOT_PRODUCT,  Prev: DIGITS,  Up: Intrinsic Procedures

9.86 'DIM' -- Positive difference
=================================

_Description_:
     'DIM(X,Y)' returns the difference 'X-Y' if the result is positive;
     otherwise returns zero.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = DIM(X, Y)'

_Arguments_:
     X           The type shall be 'INTEGER' or 'REAL'
     Y           The type shall be the same type and kind as X.

_Return value_:
     The return value is of type 'INTEGER' or 'REAL'.

_Example_:
          program test_dim
              integer :: i
              real(8) :: x
              i = dim(4, 15)
              x = dim(4.345_8, 2.111_8)
              print *, i
              print *, x
          end program test_dim

_Specific names_:
     Name           Argument       Return type    Standard
     'DIM(X,Y)'     'REAL(4) X,    'REAL(4)'      Fortran 77 and
                    Y'                            later
     'IDIM(X,Y)'    'INTEGER(4)    'INTEGER(4)'   Fortran 77 and
                    X, Y'                         later
     'DDIM(X,Y)'    'REAL(8) X,    'REAL(8)'      Fortran 77 and
                    Y'                            later


File: gfortran.info,  Node: DOT_PRODUCT,  Next: DPROD,  Prev: DIM,  Up: Intrinsic Procedures

9.87 'DOT_PRODUCT' -- Dot product function
==========================================

_Description_:
     'DOT_PRODUCT(VECTOR_A, VECTOR_B)' computes the dot product
     multiplication of two vectors VECTOR_A and VECTOR_B.  The two
     vectors may be either numeric or logical and must be arrays of rank
     one and of equal size.  If the vectors are 'INTEGER' or 'REAL', the
     result is 'SUM(VECTOR_A*VECTOR_B)'.  If the vectors are 'COMPLEX',
     the result is 'SUM(CONJG(VECTOR_A)*VECTOR_B)'.  If the vectors are
     'LOGICAL', the result is 'ANY(VECTOR_A .AND. VECTOR_B)'.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = DOT_PRODUCT(VECTOR_A, VECTOR_B)'

_Arguments_:
     VECTOR_A    The type shall be numeric or 'LOGICAL', rank 1.
     VECTOR_B    The type shall be numeric if VECTOR_A is of
                 numeric type or 'LOGICAL' if VECTOR_A is of type
                 'LOGICAL'.  VECTOR_B shall be a rank-one array.

_Return value_:
     If the arguments are numeric, the return value is a scalar of
     numeric type, 'INTEGER', 'REAL', or 'COMPLEX'.  If the arguments
     are 'LOGICAL', the return value is '.TRUE.' or '.FALSE.'.

_Example_:
          program test_dot_prod
              integer, dimension(3) :: a, b
              a = (/ 1, 2, 3 /)
              b = (/ 4, 5, 6 /)
              print '(3i3)', a
              print *
              print '(3i3)', b
              print *
              print *, dot_product(a,b)
          end program test_dot_prod


File: gfortran.info,  Node: DPROD,  Next: DREAL,  Prev: DOT_PRODUCT,  Up: Intrinsic Procedures

9.88 'DPROD' -- Double product function
=======================================

_Description_:
     'DPROD(X,Y)' returns the product 'X*Y'.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = DPROD(X, Y)'

_Arguments_:
     X           The type shall be 'REAL'.
     Y           The type shall be 'REAL'.

_Return value_:
     The return value is of type 'REAL(8)'.

_Example_:
          program test_dprod
              real :: x = 5.2
              real :: y = 2.3
              real(8) :: d
              d = dprod(x,y)
              print *, d
          end program test_dprod

_Specific names_:
     Name           Argument       Return type    Standard
     'DPROD(X,Y)'   'REAL(4) X,    'REAL(8)'      Fortran 77 and
                    Y'                            later


File: gfortran.info,  Node: DREAL,  Next: DSHIFTL,  Prev: DPROD,  Up: Intrinsic Procedures

9.89 'DREAL' -- Double real part function
=========================================

_Description_:
     'DREAL(Z)' returns the real part of complex variable Z.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     'RESULT = DREAL(A)'

_Arguments_:
     A           The type shall be 'COMPLEX(8)'.

_Return value_:
     The return value is of type 'REAL(8)'.

_Example_:
          program test_dreal
              complex(8) :: z = (1.3_8,7.2_8)
              print *, dreal(z)
          end program test_dreal

_See also_:
     *note AIMAG::


File: gfortran.info,  Node: DSHIFTL,  Next: DSHIFTR,  Prev: DREAL,  Up: Intrinsic Procedures

9.90 'DSHIFTL' -- Combined left shift
=====================================

_Description_:
     'DSHIFTL(I, J, SHIFT)' combines bits of I and J.  The rightmost
     SHIFT bits of the result are the leftmost SHIFT bits of J, and the
     remaining bits are the rightmost bits of I.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = DSHIFTL(I, J, SHIFT)'

_Arguments_:
     I           Shall be of type 'INTEGER' or a BOZ constant.
     J           Shall be of type 'INTEGER' or a BOZ constant.
                 If both I and J have integer type, then they
                 shall have the same kind type parameter.  I and
                 J shall not both be BOZ constants.
     SHIFT       Shall be of type 'INTEGER'.  It shall be
                 nonnegative.  If I is not a BOZ constant, then
                 SHIFT shall be less than or equal to
                 'BIT_SIZE(I)'; otherwise, SHIFT shall be less
                 than or equal to 'BIT_SIZE(J)'.

_Return value_:
     If either I or J is a BOZ constant, it is first converted as if by
     the intrinsic function 'INT' to an integer type with the kind type
     parameter of the other.

_See also_:
     *note DSHIFTR::


File: gfortran.info,  Node: DSHIFTR,  Next: DTIME,  Prev: DSHIFTL,  Up: Intrinsic Procedures

9.91 'DSHIFTR' -- Combined right shift
======================================

_Description_:
     'DSHIFTR(I, J, SHIFT)' combines bits of I and J.  The leftmost
     SHIFT bits of the result are the rightmost SHIFT bits of I, and the
     remaining bits are the leftmost bits of J.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = DSHIFTR(I, J, SHIFT)'

_Arguments_:
     I           Shall be of type 'INTEGER' or a BOZ constant.
     J           Shall be of type 'INTEGER' or a BOZ constant.
                 If both I and J have integer type, then they
                 shall have the same kind type parameter.  I and
                 J shall not both be BOZ constants.
     SHIFT       Shall be of type 'INTEGER'.  It shall be
                 nonnegative.  If I is not a BOZ constant, then
                 SHIFT shall be less than or equal to
                 'BIT_SIZE(I)'; otherwise, SHIFT shall be less
                 than or equal to 'BIT_SIZE(J)'.

_Return value_:
     If either I or J is a BOZ constant, it is first converted as if by
     the intrinsic function 'INT' to an integer type with the kind type
     parameter of the other.

_See also_:
     *note DSHIFTL::


File: gfortran.info,  Node: DTIME,  Next: EOSHIFT,  Prev: DSHIFTR,  Up: Intrinsic Procedures

9.92 'DTIME' -- Execution time subroutine (or function)
=======================================================

_Description_:
     'DTIME(VALUES, TIME)' initially returns the number of seconds of
     runtime since the start of the process's execution in TIME.  VALUES
     returns the user and system components of this time in 'VALUES(1)'
     and 'VALUES(2)' respectively.  TIME is equal to 'VALUES(1) +
     VALUES(2)'.

     Subsequent invocations of 'DTIME' return values accumulated since
     the previous invocation.

     On some systems, the underlying timings are represented using types
     with sufficiently small limits that overflows (wrap around) are
     possible, such as 32-bit types.  Therefore, the values returned by
     this intrinsic might be, or become, negative, or numerically less
     than previous values, during a single run of the compiled program.

     Please note, that this implementation is thread safe if used within
     OpenMP directives, i.e., its state will be consistent while called
     from multiple threads.  However, if 'DTIME' is called from multiple
     threads, the result is still the time since the last invocation.
     This may not give the intended results.  If possible, use
     'CPU_TIME' instead.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

     VALUES and TIME are 'INTENT(OUT)' and provide the following:

                 'VALUES(1)':           User time in seconds.
                 'VALUES(2)':           System time in seconds.
                 'TIME':                Run time since start in
                                        seconds.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL DTIME(VALUES, TIME)'.
     'TIME = DTIME(VALUES)', (not recommended).

_Arguments_:
     VALUES      The type shall be 'REAL(4), DIMENSION(2)'.
     TIME        The type shall be 'REAL(4)'.

_Return value_:
     Elapsed time in seconds since the last invocation or since the
     start of program execution if not called before.

_Example_:
          program test_dtime
              integer(8) :: i, j
              real, dimension(2) :: tarray
              real :: result
              call dtime(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
              do i=1,100000000    ! Just a delay
                  j = i * i - i
              end do
              call dtime(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
          end program test_dtime

_See also_:
     *note CPU_TIME::


File: gfortran.info,  Node: EOSHIFT,  Next: EPSILON,  Prev: DTIME,  Up: Intrinsic Procedures

9.93 'EOSHIFT' -- End-off shift elements of an array
====================================================

_Description_:
     'EOSHIFT(ARRAY, SHIFT[, BOUNDARY, DIM])' performs an end-off shift
     on elements of ARRAY along the dimension of DIM.  If DIM is omitted
     it is taken to be '1'.  DIM is a scalar of type 'INTEGER' in the
     range of 1 \leq DIM \leq n) where n is the rank of ARRAY.  If the
     rank of ARRAY is one, then all elements of ARRAY are shifted by
     SHIFT places.  If rank is greater than one, then all complete rank
     one sections of ARRAY along the given dimension are shifted.
     Elements shifted out one end of each rank one section are dropped.
     If BOUNDARY is present then the corresponding value of from
     BOUNDARY is copied back in the other end.  If BOUNDARY is not
     present then the following are copied in depending on the type of
     ARRAY.

     _Array      _Boundary Value_
     Type_
     Numeric     0 of the type and kind of ARRAY.
     Logical     '.FALSE.'.
     Character(LEN)LEN blanks.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = EOSHIFT(ARRAY, SHIFT [, BOUNDARY, DIM])'

_Arguments_:
     ARRAY       May be any type, not scalar.
     SHIFT       The type shall be 'INTEGER'.
     BOUNDARY    Same type as ARRAY.
     DIM         The type shall be 'INTEGER'.

_Return value_:
     Returns an array of same type and rank as the ARRAY argument.

_Example_:
          program test_eoshift
              integer, dimension(3,3) :: a
              a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
              a = EOSHIFT(a, SHIFT=(/1, 2, 1/), BOUNDARY=-5, DIM=2)
              print *
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
          end program test_eoshift


File: gfortran.info,  Node: EPSILON,  Next: ERF,  Prev: EOSHIFT,  Up: Intrinsic Procedures

9.94 'EPSILON' -- Epsilon function
==================================

_Description_:
     'EPSILON(X)' returns the smallest number E of the same kind as X
     such that 1 + E > 1.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = EPSILON(X)'

_Arguments_:
     X           The type shall be 'REAL'.

_Return value_:
     The return value is of same type as the argument.

_Example_:
          program test_epsilon
              real :: x = 3.143
              real(8) :: y = 2.33
              print *, EPSILON(x)
              print *, EPSILON(y)
          end program test_epsilon


File: gfortran.info,  Node: ERF,  Next: ERFC,  Prev: EPSILON,  Up: Intrinsic Procedures

9.95 'ERF' -- Error function
============================

_Description_:
     'ERF(X)' computes the error function of X.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ERF(X)'

_Arguments_:
     X           The type shall be 'REAL'.

_Return value_:
     The return value is of type 'REAL', of the same kind as X and lies
     in the range -1 \leq erf (x) \leq 1 .

_Example_:
          program test_erf
            real(8) :: x = 0.17_8
            x = erf(x)
          end program test_erf

_Specific names_:
     Name           Argument       Return type    Standard
     'DERF(X)'      'REAL(8) X'    'REAL(8)'      GNU extension


File: gfortran.info,  Node: ERFC,  Next: ERFC_SCALED,  Prev: ERF,  Up: Intrinsic Procedures

9.96 'ERFC' -- Error function
=============================

_Description_:
     'ERFC(X)' computes the complementary error function of X.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ERFC(X)'

_Arguments_:
     X           The type shall be 'REAL'.

_Return value_:
     The return value is of type 'REAL' and of the same kind as X.  It
     lies in the range 0 \leq erfc (x) \leq 2 .

_Example_:
          program test_erfc
            real(8) :: x = 0.17_8
            x = erfc(x)
          end program test_erfc

_Specific names_:
     Name           Argument       Return type    Standard
     'DERFC(X)'     'REAL(8) X'    'REAL(8)'      GNU extension


File: gfortran.info,  Node: ERFC_SCALED,  Next: ETIME,  Prev: ERFC,  Up: Intrinsic Procedures

9.97 'ERFC_SCALED' -- Error function
====================================

_Description_:
     'ERFC_SCALED(X)' computes the exponentially-scaled complementary
     error function of X.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ERFC_SCALED(X)'

_Arguments_:
     X           The type shall be 'REAL'.

_Return value_:
     The return value is of type 'REAL' and of the same kind as X.

_Example_:
          program test_erfc_scaled
            real(8) :: x = 0.17_8
            x = erfc_scaled(x)
          end program test_erfc_scaled


File: gfortran.info,  Node: ETIME,  Next: EVENT_QUERY,  Prev: ERFC_SCALED,  Up: Intrinsic Procedures

9.98 'ETIME' -- Execution time subroutine (or function)
=======================================================

_Description_:
     'ETIME(VALUES, TIME)' returns the number of seconds of runtime
     since the start of the process's execution in TIME.  VALUES returns
     the user and system components of this time in 'VALUES(1)' and
     'VALUES(2)' respectively.  TIME is equal to 'VALUES(1) +
     VALUES(2)'.

     On some systems, the underlying timings are represented using types
     with sufficiently small limits that overflows (wrap around) are
     possible, such as 32-bit types.  Therefore, the values returned by
     this intrinsic might be, or become, negative, or numerically less
     than previous values, during a single run of the compiled program.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

     VALUES and TIME are 'INTENT(OUT)' and provide the following:

                 'VALUES(1)':           User time in seconds.
                 'VALUES(2)':           System time in seconds.
                 'TIME':                Run time since start in seconds.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL ETIME(VALUES, TIME)'.
     'TIME = ETIME(VALUES)', (not recommended).

_Arguments_:
     VALUES      The type shall be 'REAL(4), DIMENSION(2)'.
     TIME        The type shall be 'REAL(4)'.

_Return value_:
     Elapsed time in seconds since the start of program execution.

_Example_:
          program test_etime
              integer(8) :: i, j
              real, dimension(2) :: tarray
              real :: result
              call ETIME(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
              do i=1,100000000    ! Just a delay
                  j = i * i - i
              end do
              call ETIME(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
          end program test_etime

_See also_:
     *note CPU_TIME::


File: gfortran.info,  Node: EVENT_QUERY,  Next: EXECUTE_COMMAND_LINE,  Prev: ETIME,  Up: Intrinsic Procedures

9.99 'EVENT_QUERY' -- Query whether a coarray event has occurred
================================================================

_Description_:
     'EVENT_QUERY' assignes the number of events to COUNT which have
     been posted to the EVENT variable and not yet been removed by
     calling 'EVENT WAIT'.  When STAT is present and the invocation was
     successful, it is assigned the value 0.  If it is present and the
     invocation has failed, it is assigned a positive value and COUNT is
     assigned the value -1.

_Standard_:
     TS 18508 or later

_Class_:
     subroutine

_Syntax_:
     'CALL EVENT_QUERY (EVENT, COUNT [, STAT])'

_Arguments_:
     EVENT       (intent(IN)) Scalar of type 'EVENT_TYPE',
                 defined in 'ISO_FORTRAN_ENV'; shall not be
                 coindexed.
     COUNT       (intent(out))Scalar integer with at least the
                 precision of default integer.
     STAT        (optional) Scalar default-kind integer variable.

_Example_:
          program atomic
            use iso_fortran_env
            implicit none
            type(event_type) :: event_value_has_been_set[*]
            integer :: cnt
            if (this_image() == 1) then
              call event_query (event_value_has_been_set, cnt)
              if (cnt > 0) write(*,*) "Value has been set"
            elseif (this_image() == 2) then
              event post (event_value_has_been_set[1])
            end if
          end program atomic


File: gfortran.info,  Node: EXECUTE_COMMAND_LINE,  Next: EXIT,  Prev: EVENT_QUERY,  Up: Intrinsic Procedures

9.100 'EXECUTE_COMMAND_LINE' -- Execute a shell command
=======================================================

_Description_:
     'EXECUTE_COMMAND_LINE' runs a shell command, synchronously or
     asynchronously.

     The 'COMMAND' argument is passed to the shell and executed (The
     shell is 'sh' on Unix systems, and 'cmd.exe' on Windows.).  If
     'WAIT' is present and has the value false, the execution of the
     command is asynchronous if the system supports it; otherwise, the
     command is executed synchronously using the C library's 'system'
     call.

     The three last arguments allow the user to get status information.
     After synchronous execution, 'EXITSTAT' contains the integer exit
     code of the command, as returned by 'system'.  'CMDSTAT' is set to
     zero if the command line was executed (whatever its exit status
     was).  'CMDMSG' is assigned an error message if an error has
     occurred.

     Note that the 'system' function need not be thread-safe.  It is the
     responsibility of the user to ensure that 'system' is not called
     concurrently.

     For asynchronous execution on supported targets, the POSIX
     'posix_spawn' or 'fork' functions are used.  Also, a signal handler
     for the 'SIGCHLD' signal is installed.

_Standard_:
     Fortran 2008 and later

_Class_:
     Subroutine

_Syntax_:
     'CALL EXECUTE_COMMAND_LINE(COMMAND [, WAIT, EXITSTAT, CMDSTAT,
     CMDMSG ])'

_Arguments_:
     COMMAND     Shall be a default 'CHARACTER' scalar.
     WAIT        (Optional) Shall be a default 'LOGICAL' scalar.
     EXITSTAT    (Optional) Shall be an 'INTEGER' of the default
                 kind.
     CMDSTAT     (Optional) Shall be an 'INTEGER' of the default
                 kind.
     CMDMSG      (Optional) Shall be an 'CHARACTER' scalar of the
                 default kind.

_Example_:
          program test_exec
            integer :: i

            call execute_command_line ("external_prog.exe", exitstat=i)
            print *, "Exit status of external_prog.exe was ", i

            call execute_command_line ("reindex_files.exe", wait=.false.)
            print *, "Now reindexing files in the background"

          end program test_exec

_Note_:

     Because this intrinsic is implemented in terms of the 'system'
     function call, its behavior with respect to signaling is processor
     dependent.  In particular, on POSIX-compliant systems, the SIGINT
     and SIGQUIT signals will be ignored, and the SIGCHLD will be
     blocked.  As such, if the parent process is terminated, the child
     process might not be terminated alongside.

_See also_:
     *note SYSTEM::


File: gfortran.info,  Node: EXIT,  Next: EXP,  Prev: EXECUTE_COMMAND_LINE,  Up: Intrinsic Procedures

9.101 'EXIT' -- Exit the program with status.
=============================================

_Description_:
     'EXIT' causes immediate termination of the program with status.  If
     status is omitted it returns the canonical _success_ for the
     system.  All Fortran I/O units are closed.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL EXIT([STATUS])'

_Arguments_:
     STATUS      Shall be an 'INTEGER' of the default kind.

_Return value_:
     'STATUS' is passed to the parent process on exit.

_Example_:
          program test_exit
            integer :: STATUS = 0
            print *, 'This program is going to exit.'
            call EXIT(STATUS)
          end program test_exit

_See also_:
     *note ABORT::, *note KILL::


File: gfortran.info,  Node: EXP,  Next: EXPONENT,  Prev: EXIT,  Up: Intrinsic Procedures

9.102 'EXP' -- Exponential function
===================================

_Description_:
     'EXP(X)' computes the base e exponential of X.

_Standard_:
     Fortran 77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = EXP(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value has same type and kind as X.

_Example_:
          program test_exp
            real :: x = 1.0
            x = exp(x)
          end program test_exp

_Specific names_:
     Name           Argument       Return type    Standard
     'EXP(X)'       'REAL(4) X'    'REAL(4)'      Fortran 77 and
                                                  later
     'DEXP(X)'      'REAL(8) X'    'REAL(8)'      Fortran 77 and
                                                  later
     'CEXP(X)'      'COMPLEX(4)    'COMPLEX(4)'   Fortran 77 and
                    X'                            later
     'ZEXP(X)'      'COMPLEX(8)    'COMPLEX(8)'   GNU extension
                    X'
     'CDEXP(X)'     'COMPLEX(8)    'COMPLEX(8)'   GNU extension
                    X'


File: gfortran.info,  Node: EXPONENT,  Next: EXTENDS_TYPE_OF,  Prev: EXP,  Up: Intrinsic Procedures

9.103 'EXPONENT' -- Exponent function
=====================================

_Description_:
     'EXPONENT(X)' returns the value of the exponent part of X.  If X is
     zero the value returned is zero.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = EXPONENT(X)'

_Arguments_:
     X           The type shall be 'REAL'.

_Return value_:
     The return value is of type default 'INTEGER'.

_Example_:
          program test_exponent
            real :: x = 1.0
            integer :: i
            i = exponent(x)
            print *, i
            print *, exponent(0.0)
          end program test_exponent


File: gfortran.info,  Node: EXTENDS_TYPE_OF,  Next: FDATE,  Prev: EXPONENT,  Up: Intrinsic Procedures

9.104 'EXTENDS_TYPE_OF' -- Query dynamic type for extension
===========================================================

_Description_:
     Query dynamic type for extension.

_Standard_:
     Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = EXTENDS_TYPE_OF(A, MOLD)'

_Arguments_:
     A           Shall be an object of extensible declared type
                 or unlimited polymorphic.
     MOLD        Shall be an object of extensible declared type
                 or unlimited polymorphic.

_Return value_:
     The return value is a scalar of type default logical.  It is true
     if and only if the dynamic type of A is an extension type of the
     dynamic type of MOLD.

_See also_:
     *note SAME_TYPE_AS::


File: gfortran.info,  Node: FDATE,  Next: FGET,  Prev: EXTENDS_TYPE_OF,  Up: Intrinsic Procedures

9.105 'FDATE' -- Get the current time as a string
=================================================

_Description_:
     'FDATE(DATE)' returns the current date (using the same format as
     *note CTIME::) in DATE.  It is equivalent to 'CALL CTIME(DATE,
     TIME())'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL FDATE(DATE)'.
     'DATE = FDATE()'.

_Arguments_:
     DATE        The type shall be of type 'CHARACTER' of the
                 default kind.  It is an 'INTENT(OUT)' argument.
                 If the length of this variable is too short for
                 the date and time string to fit completely, it
                 will be blank on procedure return.

_Return value_:
     The current date and time as a string.

_Example_:
          program test_fdate
              integer(8) :: i, j
              character(len=30) :: date
              call fdate(date)
              print *, 'Program started on ', date
              do i = 1, 100000000 ! Just a delay
                  j = i * i - i
              end do
              call fdate(date)
              print *, 'Program ended on ', date
          end program test_fdate

_See also_:
     *note DATE_AND_TIME::, *note CTIME::


File: gfortran.info,  Node: FGET,  Next: FGETC,  Prev: FDATE,  Up: Intrinsic Procedures

9.106 'FGET' -- Read a single character in stream mode from stdin
=================================================================

_Description_:
     Read a single character in stream mode from stdin by bypassing
     normal formatted output.  Stream I/O should not be mixed with
     normal record-oriented (formatted or unformatted) I/O on the same
     unit; the results are unpredictable.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

     Note that the 'FGET' intrinsic is provided for backwards
     compatibility with 'g77'.  GNU Fortran provides the Fortran 2003
     Stream facility.  Programmers should consider the use of new stream
     IO feature in new code for future portability.  See also *note
     Fortran 2003 status::.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL FGET(C [, STATUS])'
     'STATUS = FGET(C)'

_Arguments_:
     C           The type shall be 'CHARACTER' and of default
                 kind.
     STATUS      (Optional) status flag of type 'INTEGER'.
                 Returns 0 on success, -1 on end-of-file, and a
                 system specific positive error code otherwise.

_Example_:
          PROGRAM test_fget
            INTEGER, PARAMETER :: strlen = 100
            INTEGER :: status, i = 1
            CHARACTER(len=strlen) :: str = ""

            WRITE (*,*) 'Enter text:'
            DO
              CALL fget(str(i:i), status)
              if (status /= 0 .OR. i > strlen) exit
              i = i + 1
            END DO
            WRITE (*,*) TRIM(str)
          END PROGRAM

_See also_:
     *note FGETC::, *note FPUT::, *note FPUTC::


File: gfortran.info,  Node: FGETC,  Next: FINDLOC,  Prev: FGET,  Up: Intrinsic Procedures

9.107 'FGETC' -- Read a single character in stream mode
=======================================================

_Description_:
     Read a single character in stream mode by bypassing normal
     formatted output.  Stream I/O should not be mixed with normal
     record-oriented (formatted or unformatted) I/O on the same unit;
     the results are unpredictable.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

     Note that the 'FGET' intrinsic is provided for backwards
     compatibility with 'g77'.  GNU Fortran provides the Fortran 2003
     Stream facility.  Programmers should consider the use of new stream
     IO feature in new code for future portability.  See also *note
     Fortran 2003 status::.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL FGETC(UNIT, C [, STATUS])'
     'STATUS = FGETC(UNIT, C)'

_Arguments_:
     UNIT        The type shall be 'INTEGER'.
     C           The type shall be 'CHARACTER' and of default
                 kind.
     STATUS      (Optional) status flag of type 'INTEGER'.
                 Returns 0 on success, -1 on end-of-file and a
                 system specific positive error code otherwise.

_Example_:
          PROGRAM test_fgetc
            INTEGER :: fd = 42, status
            CHARACTER :: c

            OPEN(UNIT=fd, FILE="/etc/passwd", ACTION="READ", STATUS = "OLD")
            DO
              CALL fgetc(fd, c, status)
              IF (status /= 0) EXIT
              call fput(c)
            END DO
            CLOSE(UNIT=fd)
          END PROGRAM

_See also_:
     *note FGET::, *note FPUT::, *note FPUTC::


File: gfortran.info,  Node: FINDLOC,  Next: FLOOR,  Prev: FGETC,  Up: Intrinsic Procedures

9.108 'FINDLOC' -- Search an array for a value
==============================================

_Description_:
     Determines the location of the element in the array with the value
     given in the VALUE argument, or, if the DIM argument is supplied,
     determines the locations of the maximum element along each row of
     the array in the DIM direction.  If MASK is present, only the
     elements for which MASK is '.TRUE.' are considered.  If more than
     one element in the array has the value VALUE, the location returned
     is that of the first such element in array element order if the
     BACK is not present or if it is '.FALSE.'.  If BACK is true, the
     location returned is that of the last such element.  If the array
     has zero size, or all of the elements of MASK are '.FALSE.', then
     the result is an array of zeroes.  Similarly, if DIM is supplied
     and all of the elements of MASK along a given row are zero, the
     result value for that row is zero.

_Standard_:
     Fortran 2008 and later.

_Class_:
     Transformational function

_Syntax_:
     'RESULT = FINDLOC(ARRAY, VALUE, DIM [, MASK] [,KIND]
     [,BACK])'
     'RESULT = FINDLOC(ARRAY, VALUE, [, MASK] [,KIND]
     [,BACK])'

_Arguments_:
     ARRAY       Shall be an array of intrinsic type.
     VALUE       A scalar of intrinsic type which is in type
                 conformance with ARRAY.
     DIM         (Optional) Shall be a scalar of type 'INTEGER',
                 with a value between one and the rank of ARRAY,
                 inclusive.  It may not be an optional dummy
                 argument.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.
     BACK        (Optional) A scalar of type 'LOGICAL'.

_Return value_:
     If DIM is absent, the result is a rank-one array with a length
     equal to the rank of ARRAY.  If DIM is present, the result is an
     array with a rank one less than the rank of ARRAY, and a size
     corresponding to the size of ARRAY with the DIM dimension removed.
     If DIM is present and ARRAY has a rank of one, the result is a
     scalar.  If the optional argument KIND is present, the result is an
     integer of kind KIND, otherwise it is of default kind.

_See also_:
     *note MAXLOC::, *note MINLOC::


File: gfortran.info,  Node: FLOOR,  Next: FLUSH,  Prev: FINDLOC,  Up: Intrinsic Procedures

9.109 'FLOOR' -- Integer floor function
=======================================

_Description_:
     'FLOOR(A)' returns the greatest integer less than or equal to X.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = FLOOR(A [, KIND])'

_Arguments_:
     A           The type shall be 'REAL'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER(KIND)' if KIND is present and
     of default-kind 'INTEGER' otherwise.

_Example_:
          program test_floor
              real :: x = 63.29
              real :: y = -63.59
              print *, floor(x) ! returns 63
              print *, floor(y) ! returns -64
          end program test_floor

_See also_:
     *note CEILING::, *note NINT::


File: gfortran.info,  Node: FLUSH,  Next: FNUM,  Prev: FLOOR,  Up: Intrinsic Procedures

9.110 'FLUSH' -- Flush I/O unit(s)
==================================

_Description_:
     Flushes Fortran unit(s) currently open for output.  Without the
     optional argument, all units are flushed, otherwise just the unit
     specified.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL FLUSH(UNIT)'

_Arguments_:
     UNIT        (Optional) The type shall be 'INTEGER'.

_Note_:
     Beginning with the Fortran 2003 standard, there is a 'FLUSH'
     statement that should be preferred over the 'FLUSH' intrinsic.

     The 'FLUSH' intrinsic and the Fortran 2003 'FLUSH' statement have
     identical effect: they flush the runtime library's I/O buffer so
     that the data becomes visible to other processes.  This does not
     guarantee that the data is committed to disk.

     On POSIX systems, you can request that all data is transferred to
     the storage device by calling the 'fsync' function, with the POSIX
     file descriptor of the I/O unit as argument (retrieved with GNU
     intrinsic 'FNUM').  The following example shows how:

            ! Declare the interface for POSIX fsync function
            interface
              function fsync (fd) bind(c,name="fsync")
              use iso_c_binding, only: c_int
                integer(c_int), value :: fd
                integer(c_int) :: fsync
              end function fsync
            end interface

            ! Variable declaration
            integer :: ret

            ! Opening unit 10
            open (10,file="foo")

            ! ...
            ! Perform I/O on unit 10
            ! ...

            ! Flush and sync
            flush(10)
            ret = fsync(fnum(10))

            ! Handle possible error
            if (ret /= 0) stop "Error calling FSYNC"


File: gfortran.info,  Node: FNUM,  Next: FPUT,  Prev: FLUSH,  Up: Intrinsic Procedures

9.111 'FNUM' -- File number function
====================================

_Description_:
     'FNUM(UNIT)' returns the POSIX file descriptor number corresponding
     to the open Fortran I/O unit 'UNIT'.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = FNUM(UNIT)'

_Arguments_:
     UNIT        The type shall be 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER'

_Example_:
          program test_fnum
            integer :: i
            open (unit=10, status = "scratch")
            i = fnum(10)
            print *, i
            close (10)
          end program test_fnum


File: gfortran.info,  Node: FPUT,  Next: FPUTC,  Prev: FNUM,  Up: Intrinsic Procedures

9.112 'FPUT' -- Write a single character in stream mode to stdout
=================================================================

_Description_:
     Write a single character in stream mode to stdout by bypassing
     normal formatted output.  Stream I/O should not be mixed with
     normal record-oriented (formatted or unformatted) I/O on the same
     unit; the results are unpredictable.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

     Note that the 'FGET' intrinsic is provided for backwards
     compatibility with 'g77'.  GNU Fortran provides the Fortran 2003
     Stream facility.  Programmers should consider the use of new stream
     IO feature in new code for future portability.  See also *note
     Fortran 2003 status::.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL FPUT(C [, STATUS])'
     'STATUS = FPUT(C)'

_Arguments_:
     C           The type shall be 'CHARACTER' and of default
                 kind.
     STATUS      (Optional) status flag of type 'INTEGER'.
                 Returns 0 on success, -1 on end-of-file and a
                 system specific positive error code otherwise.

_Example_:
          PROGRAM test_fput
            CHARACTER(len=10) :: str = "gfortran"
            INTEGER :: i
            DO i = 1, len_trim(str)
              CALL fput(str(i:i))
            END DO
          END PROGRAM

_See also_:
     *note FPUTC::, *note FGET::, *note FGETC::


File: gfortran.info,  Node: FPUTC,  Next: FRACTION,  Prev: FPUT,  Up: Intrinsic Procedures

9.113 'FPUTC' -- Write a single character in stream mode
========================================================

_Description_:
     Write a single character in stream mode by bypassing normal
     formatted output.  Stream I/O should not be mixed with normal
     record-oriented (formatted or unformatted) I/O on the same unit;
     the results are unpredictable.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

     Note that the 'FGET' intrinsic is provided for backwards
     compatibility with 'g77'.  GNU Fortran provides the Fortran 2003
     Stream facility.  Programmers should consider the use of new stream
     IO feature in new code for future portability.  See also *note
     Fortran 2003 status::.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL FPUTC(UNIT, C [, STATUS])'
     'STATUS = FPUTC(UNIT, C)'

_Arguments_:
     UNIT        The type shall be 'INTEGER'.
     C           The type shall be 'CHARACTER' and of default
                 kind.
     STATUS      (Optional) status flag of type 'INTEGER'.
                 Returns 0 on success, -1 on end-of-file and a
                 system specific positive error code otherwise.

_Example_:
          PROGRAM test_fputc
            CHARACTER(len=10) :: str = "gfortran"
            INTEGER :: fd = 42, i

            OPEN(UNIT = fd, FILE = "out", ACTION = "WRITE", STATUS="NEW")
            DO i = 1, len_trim(str)
              CALL fputc(fd, str(i:i))
            END DO
            CLOSE(fd)
          END PROGRAM

_See also_:
     *note FPUT::, *note FGET::, *note FGETC::


File: gfortran.info,  Node: FRACTION,  Next: FREE,  Prev: FPUTC,  Up: Intrinsic Procedures

9.114 'FRACTION' -- Fractional part of the model representation
===============================================================

_Description_:
     'FRACTION(X)' returns the fractional part of the model
     representation of 'X'.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     'Y = FRACTION(X)'

_Arguments_:
     X           The type of the argument shall be a 'REAL'.

_Return value_:
     The return value is of the same type and kind as the argument.  The
     fractional part of the model representation of 'X' is returned; it
     is 'X * RADIX(X)**(-EXPONENT(X))'.

_Example_:
          program test_fraction
            real :: x
            x = 178.1387e-4
            print *, fraction(x), x * radix(x)**(-exponent(x))
          end program test_fraction


File: gfortran.info,  Node: FREE,  Next: FSEEK,  Prev: FRACTION,  Up: Intrinsic Procedures

9.115 'FREE' -- Frees memory
============================

_Description_:
     Frees memory previously allocated by 'MALLOC'.  The 'FREE'
     intrinsic is an extension intended to be used with Cray pointers,
     and is provided in GNU Fortran to allow user to compile legacy
     code.  For new code using Fortran 95 pointers, the memory
     de-allocation intrinsic is 'DEALLOCATE'.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL FREE(PTR)'

_Arguments_:
     PTR         The type shall be 'INTEGER'.  It represents the
                 location of the memory that should be
                 de-allocated.

_Return value_:
     None

_Example_:
     See 'MALLOC' for an example.

_See also_:
     *note MALLOC::


File: gfortran.info,  Node: FSEEK,  Next: FSTAT,  Prev: FREE,  Up: Intrinsic Procedures

9.116 'FSEEK' -- Low level file positioning subroutine
======================================================

_Description_:
     Moves UNIT to the specified OFFSET.  If WHENCE is set to 0, the
     OFFSET is taken as an absolute value 'SEEK_SET', if set to 1,
     OFFSET is taken to be relative to the current position 'SEEK_CUR',
     and if set to 2 relative to the end of the file 'SEEK_END'.  On
     error, STATUS is set to a nonzero value.  If STATUS the seek fails
     silently.

     This intrinsic routine is not fully backwards compatible with
     'g77'.  In 'g77', the 'FSEEK' takes a statement label instead of a
     STATUS variable.  If FSEEK is used in old code, change
            CALL FSEEK(UNIT, OFFSET, WHENCE, *label)
     to
            INTEGER :: status
            CALL FSEEK(UNIT, OFFSET, WHENCE, status)
            IF (status /= 0) GOTO label

     Please note that GNU Fortran provides the Fortran 2003 Stream
     facility.  Programmers should consider the use of new stream IO
     feature in new code for future portability.  See also *note Fortran
     2003 status::.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL FSEEK(UNIT, OFFSET, WHENCE[, STATUS])'

_Arguments_:
     UNIT        Shall be a scalar of type 'INTEGER'.
     OFFSET      Shall be a scalar of type 'INTEGER'.
     WHENCE      Shall be a scalar of type 'INTEGER'.  Its value
                 shall be either 0, 1 or 2.
     STATUS      (Optional) shall be a scalar of type
                 'INTEGER(4)'.

_Example_:
          PROGRAM test_fseek
            INTEGER, PARAMETER :: SEEK_SET = 0, SEEK_CUR = 1, SEEK_END = 2
            INTEGER :: fd, offset, ierr

            ierr   = 0
            offset = 5
            fd     = 10

            OPEN(UNIT=fd, FILE="fseek.test")
            CALL FSEEK(fd, offset, SEEK_SET, ierr)  ! move to OFFSET
            print *, FTELL(fd), ierr

            CALL FSEEK(fd, 0, SEEK_END, ierr)       ! move to end
            print *, FTELL(fd), ierr

            CALL FSEEK(fd, 0, SEEK_SET, ierr)       ! move to beginning
            print *, FTELL(fd), ierr

            CLOSE(UNIT=fd)
          END PROGRAM

_See also_:
     *note FTELL::


File: gfortran.info,  Node: FSTAT,  Next: FTELL,  Prev: FSEEK,  Up: Intrinsic Procedures

9.117 'FSTAT' -- Get file status
================================

_Description_:
     'FSTAT' is identical to *note STAT::, except that information about
     an already opened file is obtained.

     The elements in 'VALUES' are the same as described by *note STAT::.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL FSTAT(UNIT, VALUES [, STATUS])'
     'STATUS = FSTAT(UNIT, VALUES)'

_Arguments_:
     UNIT        An open I/O unit number of type 'INTEGER'.
     VALUES      The type shall be 'INTEGER(4), DIMENSION(13)'.
     STATUS      (Optional) status flag of type 'INTEGER(4)'.
                 Returns 0 on success and a system specific error
                 code otherwise.

_Example_:
     See *note STAT:: for an example.

_See also_:
     To stat a link: *note LSTAT::, to stat a file: *note STAT::


File: gfortran.info,  Node: FTELL,  Next: GAMMA,  Prev: FSTAT,  Up: Intrinsic Procedures

9.118 'FTELL' -- Current stream position
========================================

_Description_:
     Retrieves the current position within an open file.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL FTELL(UNIT, OFFSET)'
     'OFFSET = FTELL(UNIT)'

_Arguments_:
     OFFSET      Shall of type 'INTEGER'.
     UNIT        Shall of type 'INTEGER'.

_Return value_:
     In either syntax, OFFSET is set to the current offset of unit
     number UNIT, or to -1 if the unit is not currently open.

_Example_:
          PROGRAM test_ftell
            INTEGER :: i
            OPEN(10, FILE="temp.dat")
            CALL ftell(10,i)
            WRITE(*,*) i
          END PROGRAM

_See also_:
     *note FSEEK::


File: gfortran.info,  Node: GAMMA,  Next: GERROR,  Prev: FTELL,  Up: Intrinsic Procedures

9.119 'GAMMA' -- Gamma function
===============================

_Description_:
     'GAMMA(X)' computes Gamma (\Gamma) of X.  For positive, integer
     values of X the Gamma function simplifies to the factorial function
     \Gamma(x)=(x-1)!.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'X = GAMMA(X)'

_Arguments_:
     X           Shall be of type 'REAL' and neither zero nor a
                 negative integer.

_Return value_:
     The return value is of type 'REAL' of the same kind as X.

_Example_:
          program test_gamma
            real :: x = 1.0
            x = gamma(x) ! returns 1.0
          end program test_gamma

_Specific names_:
     Name           Argument       Return type    Standard
     'GAMMA(X)'     'REAL(4) X'    'REAL(4)'      GNU Extension
     'DGAMMA(X)'    'REAL(8) X'    'REAL(8)'      GNU Extension

_See also_:
     Logarithm of the Gamma function: *note LOG_GAMMA::


File: gfortran.info,  Node: GERROR,  Next: GETARG,  Prev: GAMMA,  Up: Intrinsic Procedures

9.120 'GERROR' -- Get last system error message
===============================================

_Description_:
     Returns the system error message corresponding to the last system
     error.  This resembles the functionality of 'strerror(3)' in C.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL GERROR(RESULT)'

_Arguments_:
     RESULT      Shall of type 'CHARACTER' and of default

_Example_:
          PROGRAM test_gerror
            CHARACTER(len=100) :: msg
            CALL gerror(msg)
            WRITE(*,*) msg
          END PROGRAM

_See also_:
     *note IERRNO::, *note PERROR::


File: gfortran.info,  Node: GETARG,  Next: GET_COMMAND,  Prev: GERROR,  Up: Intrinsic Procedures

9.121 'GETARG' -- Get command line arguments
============================================

_Description_:
     Retrieve the POS-th argument that was passed on the command line
     when the containing program was invoked.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  In new code, programmers should consider the use
     of the *note GET_COMMAND_ARGUMENT:: intrinsic defined by the
     Fortran 2003 standard.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL GETARG(POS, VALUE)'

_Arguments_:
     POS         Shall be of type 'INTEGER' and not wider than
                 the default integer kind; POS \geq 0
     VALUE       Shall be of type 'CHARACTER' and of default
                 kind.
     VALUE       Shall be of type 'CHARACTER'.

_Return value_:
     After 'GETARG' returns, the VALUE argument holds the POSth command
     line argument.  If VALUE cannot hold the argument, it is truncated
     to fit the length of VALUE.  If there are less than POS arguments
     specified at the command line, VALUE will be filled with blanks.
     If POS = 0, VALUE is set to the name of the program (on systems
     that support this feature).

_Example_:
          PROGRAM test_getarg
            INTEGER :: i
            CHARACTER(len=32) :: arg

            DO i = 1, iargc()
              CALL getarg(i, arg)
              WRITE (*,*) arg
            END DO
          END PROGRAM

_See also_:
     GNU Fortran 77 compatibility function: *note IARGC::

     Fortran 2003 functions and subroutines: *note GET_COMMAND::, *note
     GET_COMMAND_ARGUMENT::, *note COMMAND_ARGUMENT_COUNT::


File: gfortran.info,  Node: GET_COMMAND,  Next: GET_COMMAND_ARGUMENT,  Prev: GETARG,  Up: Intrinsic Procedures

9.122 'GET_COMMAND' -- Get the entire command line
==================================================

_Description_:
     Retrieve the entire command line that was used to invoke the
     program.

_Standard_:
     Fortran 2003 and later

_Class_:
     Subroutine

_Syntax_:
     'CALL GET_COMMAND([COMMAND, LENGTH, STATUS])'

_Arguments_:
     COMMAND     (Optional) shall be of type 'CHARACTER' and of
                 default kind.
     LENGTH      (Optional) Shall be of type 'INTEGER' and of
                 default kind.
     STATUS      (Optional) Shall be of type 'INTEGER' and of
                 default kind.

_Return value_:
     If COMMAND is present, stores the entire command line that was used
     to invoke the program in COMMAND.  If LENGTH is present, it is
     assigned the length of the command line.  If STATUS is present, it
     is assigned 0 upon success of the command, -1 if COMMAND is too
     short to store the command line, or a positive value in case of an
     error.

_Example_:
          PROGRAM test_get_command
            CHARACTER(len=255) :: cmd
            CALL get_command(cmd)
            WRITE (*,*) TRIM(cmd)
          END PROGRAM

_See also_:
     *note GET_COMMAND_ARGUMENT::, *note COMMAND_ARGUMENT_COUNT::


File: gfortran.info,  Node: GET_COMMAND_ARGUMENT,  Next: GETCWD,  Prev: GET_COMMAND,  Up: Intrinsic Procedures

9.123 'GET_COMMAND_ARGUMENT' -- Get command line arguments
==========================================================

_Description_:
     Retrieve the NUMBER-th argument that was passed on the command line
     when the containing program was invoked.

_Standard_:
     Fortran 2003 and later

_Class_:
     Subroutine

_Syntax_:
     'CALL GET_COMMAND_ARGUMENT(NUMBER [, VALUE, LENGTH, STATUS])'

_Arguments_:
     NUMBER      Shall be a scalar of type 'INTEGER' and of
                 default kind, NUMBER \geq 0
     VALUE       (Optional) Shall be a scalar of type 'CHARACTER'
                 and of default kind.
     LENGTH      (Optional) Shall be a scalar of type 'INTEGER'
                 and of default kind.
     STATUS      (Optional) Shall be a scalar of type 'INTEGER'
                 and of default kind.

_Return value_:
     After 'GET_COMMAND_ARGUMENT' returns, the VALUE argument holds the
     NUMBER-th command line argument.  If VALUE cannot hold the
     argument, it is truncated to fit the length of VALUE.  If there are
     less than NUMBER arguments specified at the command line, VALUE
     will be filled with blanks.  If NUMBER = 0, VALUE is set to the
     name of the program (on systems that support this feature).  The
     LENGTH argument contains the length of the NUMBER-th command line
     argument.  If the argument retrieval fails, STATUS is a positive
     number; if VALUE contains a truncated command line argument, STATUS
     is -1; and otherwise the STATUS is zero.

_Example_:
          PROGRAM test_get_command_argument
            INTEGER :: i
            CHARACTER(len=32) :: arg

            i = 0
            DO
              CALL get_command_argument(i, arg)
              IF (LEN_TRIM(arg) == 0) EXIT

              WRITE (*,*) TRIM(arg)
              i = i+1
            END DO
          END PROGRAM

_See also_:
     *note GET_COMMAND::, *note COMMAND_ARGUMENT_COUNT::


File: gfortran.info,  Node: GETCWD,  Next: GETENV,  Prev: GET_COMMAND_ARGUMENT,  Up: Intrinsic Procedures

9.124 'GETCWD' -- Get current working directory
===============================================

_Description_:
     Get current working directory.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL GETCWD(C [, STATUS])'
     'STATUS = GETCWD(C)'

_Arguments_:
     C           The type shall be 'CHARACTER' and of default
                 kind.
     STATUS      (Optional) status flag.  Returns 0 on success, a
                 system specific and nonzero error code
                 otherwise.

_Example_:
          PROGRAM test_getcwd
            CHARACTER(len=255) :: cwd
            CALL getcwd(cwd)
            WRITE(*,*) TRIM(cwd)
          END PROGRAM

_See also_:
     *note CHDIR::


File: gfortran.info,  Node: GETENV,  Next: GET_ENVIRONMENT_VARIABLE,  Prev: GETCWD,  Up: Intrinsic Procedures

9.125 'GETENV' -- Get an environmental variable
===============================================

_Description_:
     Get the VALUE of the environmental variable NAME.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  In new code, programmers should consider the use
     of the *note GET_ENVIRONMENT_VARIABLE:: intrinsic defined by the
     Fortran 2003 standard.

     Note that 'GETENV' need not be thread-safe.  It is the
     responsibility of the user to ensure that the environment is not
     being updated concurrently with a call to the 'GETENV' intrinsic.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL GETENV(NAME, VALUE)'

_Arguments_:
     NAME        Shall be of type 'CHARACTER' and of default
                 kind.
     VALUE       Shall be of type 'CHARACTER' and of default
                 kind.

_Return value_:
     Stores the value of NAME in VALUE.  If VALUE is not large enough to
     hold the data, it is truncated.  If NAME is not set, VALUE will be
     filled with blanks.

_Example_:
          PROGRAM test_getenv
            CHARACTER(len=255) :: homedir
            CALL getenv("HOME", homedir)
            WRITE (*,*) TRIM(homedir)
          END PROGRAM

_See also_:
     *note GET_ENVIRONMENT_VARIABLE::


File: gfortran.info,  Node: GET_ENVIRONMENT_VARIABLE,  Next: GETGID,  Prev: GETENV,  Up: Intrinsic Procedures

9.126 'GET_ENVIRONMENT_VARIABLE' -- Get an environmental variable
=================================================================

_Description_:
     Get the VALUE of the environmental variable NAME.

     Note that 'GET_ENVIRONMENT_VARIABLE' need not be thread-safe.  It
     is the responsibility of the user to ensure that the environment is
     not being updated concurrently with a call to the
     'GET_ENVIRONMENT_VARIABLE' intrinsic.

_Standard_:
     Fortran 2003 and later

_Class_:
     Subroutine

_Syntax_:
     'CALL GET_ENVIRONMENT_VARIABLE(NAME[, VALUE, LENGTH, STATUS,
     TRIM_NAME)'

_Arguments_:
     NAME        Shall be a scalar of type 'CHARACTER' and of
                 default kind.
     VALUE       (Optional) Shall be a scalar of type 'CHARACTER'
                 and of default kind.
     LENGTH      (Optional) Shall be a scalar of type 'INTEGER'
                 and of default kind.
     STATUS      (Optional) Shall be a scalar of type 'INTEGER'
                 and of default kind.
     TRIM_NAME   (Optional) Shall be a scalar of type 'LOGICAL'
                 and of default kind.

_Return value_:
     Stores the value of NAME in VALUE.  If VALUE is not large enough to
     hold the data, it is truncated.  If NAME is not set, VALUE will be
     filled with blanks.  Argument LENGTH contains the length needed for
     storing the environment variable NAME or zero if it is not present.
     STATUS is -1 if VALUE is present but too short for the environment
     variable; it is 1 if the environment variable does not exist and 2
     if the processor does not support environment variables; in all
     other cases STATUS is zero.  If TRIM_NAME is present with the value
     '.FALSE.', the trailing blanks in NAME are significant; otherwise
     they are not part of the environment variable name.

_Example_:
          PROGRAM test_getenv
            CHARACTER(len=255) :: homedir
            CALL get_environment_variable("HOME", homedir)
            WRITE (*,*) TRIM(homedir)
          END PROGRAM


File: gfortran.info,  Node: GETGID,  Next: GETLOG,  Prev: GET_ENVIRONMENT_VARIABLE,  Up: Intrinsic Procedures

9.127 'GETGID' -- Group ID function
===================================

_Description_:
     Returns the numerical group ID of the current process.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = GETGID()'

_Return value_:
     The return value of 'GETGID' is an 'INTEGER' of the default kind.

_Example_:
     See 'GETPID' for an example.

_See also_:
     *note GETPID::, *note GETUID::


File: gfortran.info,  Node: GETLOG,  Next: GETPID,  Prev: GETGID,  Up: Intrinsic Procedures

9.128 'GETLOG' -- Get login name
================================

_Description_:
     Gets the username under which the program is running.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL GETLOG(C)'

_Arguments_:
     C           Shall be of type 'CHARACTER' and of default
                 kind.

_Return value_:
     Stores the current user name in LOGIN.  (On systems where POSIX
     functions 'geteuid' and 'getpwuid' are not available, and the
     'getlogin' function is not implemented either, this will return a
     blank string.)

_Example_:
          PROGRAM TEST_GETLOG
            CHARACTER(32) :: login
            CALL GETLOG(login)
            WRITE(*,*) login
          END PROGRAM

_See also_:
     *note GETUID::


File: gfortran.info,  Node: GETPID,  Next: GETUID,  Prev: GETLOG,  Up: Intrinsic Procedures

9.129 'GETPID' -- Process ID function
=====================================

_Description_:
     Returns the numerical process identifier of the current process.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = GETPID()'

_Return value_:
     The return value of 'GETPID' is an 'INTEGER' of the default kind.

_Example_:
          program info
            print *, "The current process ID is ", getpid()
            print *, "Your numerical user ID is ", getuid()
            print *, "Your numerical group ID is ", getgid()
          end program info

_See also_:
     *note GETGID::, *note GETUID::


File: gfortran.info,  Node: GETUID,  Next: GMTIME,  Prev: GETPID,  Up: Intrinsic Procedures

9.130 'GETUID' -- User ID function
==================================

_Description_:
     Returns the numerical user ID of the current process.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = GETUID()'

_Return value_:
     The return value of 'GETUID' is an 'INTEGER' of the default kind.

_Example_:
     See 'GETPID' for an example.

_See also_:
     *note GETPID::, *note GETLOG::


File: gfortran.info,  Node: GMTIME,  Next: HOSTNM,  Prev: GETUID,  Up: Intrinsic Procedures

9.131 'GMTIME' -- Convert time to GMT info
==========================================

_Description_:
     Given a system time value TIME (as provided by the *note TIME::
     intrinsic), fills VALUES with values extracted from it appropriate
     to the UTC time zone (Universal Coordinated Time, also known in
     some countries as GMT, Greenwich Mean Time), using 'gmtime(3)'.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  In new code, programmers should consider the use
     of the *note DATE_AND_TIME:: intrinsic defined by the Fortran 95
     standard.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL GMTIME(TIME, VALUES)'

_Arguments_:
     TIME        An 'INTEGER' scalar expression corresponding to
                 a system time, with 'INTENT(IN)'.
     VALUES      A default 'INTEGER' array with 9 elements, with
                 'INTENT(OUT)'.

_Return value_:
     The elements of VALUES are assigned as follows:
       1. Seconds after the minute, range 0-59 or 0-61 to allow for leap
          seconds
       2. Minutes after the hour, range 0-59
       3. Hours past midnight, range 0-23
       4. Day of month, range 1-31
       5. Number of months since January, range 0-11
       6. Years since 1900
       7. Number of days since Sunday, range 0-6
       8. Days since January 1, range 0-365
       9. Daylight savings indicator: positive if daylight savings is in
          effect, zero if not, and negative if the information is not
          available.

_See also_:
     *note DATE_AND_TIME::, *note CTIME::, *note LTIME::, *note TIME::,
     *note TIME8::


File: gfortran.info,  Node: HOSTNM,  Next: HUGE,  Prev: GMTIME,  Up: Intrinsic Procedures

9.132 'HOSTNM' -- Get system host name
======================================

_Description_:
     Retrieves the host name of the system on which the program is
     running.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL HOSTNM(C [, STATUS])'
     'STATUS = HOSTNM(NAME)'

_Arguments_:
     C           Shall of type 'CHARACTER' and of default kind.
     STATUS      (Optional) status flag of type 'INTEGER'.
                 Returns 0 on success, or a system specific error
                 code otherwise.

_Return value_:
     In either syntax, NAME is set to the current hostname if it can be
     obtained, or to a blank string otherwise.


File: gfortran.info,  Node: HUGE,  Next: HYPOT,  Prev: HOSTNM,  Up: Intrinsic Procedures

9.133 'HUGE' -- Largest number of a kind
========================================

_Description_:
     'HUGE(X)' returns the largest number that is not an infinity in the
     model of the type of 'X'.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = HUGE(X)'

_Arguments_:
     X           Shall be of type 'REAL' or 'INTEGER'.

_Return value_:
     The return value is of the same type and kind as X

_Example_:
          program test_huge_tiny
            print *, huge(0), huge(0.0), huge(0.0d0)
            print *, tiny(0.0), tiny(0.0d0)
          end program test_huge_tiny


File: gfortran.info,  Node: HYPOT,  Next: IACHAR,  Prev: HUGE,  Up: Intrinsic Procedures

9.134 'HYPOT' -- Euclidean distance function
============================================

_Description_:
     'HYPOT(X,Y)' is the Euclidean distance function.  It is equal to
     \sqrt{X^2 + Y^2}, without undue underflow or overflow.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = HYPOT(X, Y)'

_Arguments_:
     X           The type shall be 'REAL'.
     Y           The type and kind type parameter shall be the
                 same as X.

_Return value_:
     The return value has the same type and kind type parameter as X.

_Example_:
          program test_hypot
            real(4) :: x = 1.e0_4, y = 0.5e0_4
            x = hypot(x,y)
          end program test_hypot


File: gfortran.info,  Node: IACHAR,  Next: IALL,  Prev: HYPOT,  Up: Intrinsic Procedures

9.135 'IACHAR' -- Code in ASCII collating sequence
==================================================

_Description_:
     'IACHAR(C)' returns the code for the ASCII character in the first
     character position of 'C'.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = IACHAR(C [, KIND])'

_Arguments_:
     C           Shall be a scalar 'CHARACTER', with 'INTENT(IN)'
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER' and of kind KIND.  If KIND is
     absent, the return value is of default integer kind.

_Example_:
          program test_iachar
            integer i
            i = iachar(' ')
          end program test_iachar

_Note_:
     See *note ICHAR:: for a discussion of converting between numerical
     values and formatted string representations.

_See also_:
     *note ACHAR::, *note CHAR::, *note ICHAR::


File: gfortran.info,  Node: IALL,  Next: IAND,  Prev: IACHAR,  Up: Intrinsic Procedures

9.136 'IALL' -- Bitwise AND of array elements
=============================================

_Description_:
     Reduces with bitwise AND the elements of ARRAY along dimension DIM
     if the corresponding element in MASK is 'TRUE'.

_Standard_:
     Fortran 2008 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = IALL(ARRAY[, MASK])'
     'RESULT = IALL(ARRAY, DIM[, MASK])'

_Arguments_:
     ARRAY       Shall be an array of type 'INTEGER'
     DIM         (Optional) shall be a scalar of type 'INTEGER'
                 with a value in the range from 1 to n, where n
                 equals the rank of ARRAY.
     MASK        (Optional) shall be of type 'LOGICAL' and either
                 be a scalar or an array of the same shape as
                 ARRAY.

_Return value_:
     The result is of the same type as ARRAY.

     If DIM is absent, a scalar with the bitwise ALL of all elements in
     ARRAY is returned.  Otherwise, an array of rank n-1, where n equals
     the rank of ARRAY, and a shape similar to that of ARRAY with
     dimension DIM dropped is returned.

_Example_:
          PROGRAM test_iall
            INTEGER(1) :: a(2)

            a(1) = b'00100100'
            a(2) = b'01101010'

            ! prints 00100000
            PRINT '(b8.8)', IALL(a)
          END PROGRAM

_See also_:
     *note IANY::, *note IPARITY::, *note IAND::


File: gfortran.info,  Node: IAND,  Next: IANY,  Prev: IALL,  Up: Intrinsic Procedures

9.137 'IAND' -- Bitwise logical and
===================================

_Description_:
     Bitwise logical 'AND'.

_Standard_:
     Fortran 95 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = IAND(I, J)'

_Arguments_:
     I           The type shall be 'INTEGER' or a
                 boz-literal-constant.
     J           The type shall be 'INTEGER' with the same kind
                 type parameter as I or a boz-literal-constant.
                 I and J shall not both be boz-literal-constants.

_Return value_:
     The return type is 'INTEGER' with the kind type parameter of the
     arguments.  A boz-literal-constant is converted to an 'INTEGER'
     with the kind type parameter of the other argument as-if a call to
     *note INT:: occurred.

_Example_:
          PROGRAM test_iand
            INTEGER :: a, b
            DATA a / Z'F' /, b / Z'3' /
            WRITE (*,*) IAND(a, b)
          END PROGRAM

_Specific names_:
     Name           Argument       Return type    Standard
     'IAND(A)'      'INTEGER A'    'INTEGER'      Fortran 95 and
                                                  later
     'BIAND(A)'     'INTEGER(1)    'INTEGER(1)'   GNU extension
                    A'
     'IIAND(A)'     'INTEGER(2)    'INTEGER(2)'   GNU extension
                    A'
     'JIAND(A)'     'INTEGER(4)    'INTEGER(4)'   GNU extension
                    A'
     'KIAND(A)'     'INTEGER(8)    'INTEGER(8)'   GNU extension
                    A'

_See also_:
     *note IOR::, *note IEOR::, *note IBITS::, *note IBSET::, *note
     IBCLR::, *note NOT::


File: gfortran.info,  Node: IANY,  Next: IARGC,  Prev: IAND,  Up: Intrinsic Procedures

9.138 'IANY' -- Bitwise OR of array elements
============================================

_Description_:
     Reduces with bitwise OR (inclusive or) the elements of ARRAY along
     dimension DIM if the corresponding element in MASK is 'TRUE'.

_Standard_:
     Fortran 2008 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = IANY(ARRAY[, MASK])'
     'RESULT = IANY(ARRAY, DIM[, MASK])'

_Arguments_:
     ARRAY       Shall be an array of type 'INTEGER'
     DIM         (Optional) shall be a scalar of type 'INTEGER'
                 with a value in the range from 1 to n, where n
                 equals the rank of ARRAY.
     MASK        (Optional) shall be of type 'LOGICAL' and either
                 be a scalar or an array of the same shape as
                 ARRAY.

_Return value_:
     The result is of the same type as ARRAY.

     If DIM is absent, a scalar with the bitwise OR of all elements in
     ARRAY is returned.  Otherwise, an array of rank n-1, where n equals
     the rank of ARRAY, and a shape similar to that of ARRAY with
     dimension DIM dropped is returned.

_Example_:
          PROGRAM test_iany
            INTEGER(1) :: a(2)

            a(1) = b'00100100'
            a(2) = b'01101010'

            ! prints 01101110
            PRINT '(b8.8)', IANY(a)
          END PROGRAM

_See also_:
     *note IPARITY::, *note IALL::, *note IOR::


File: gfortran.info,  Node: IARGC,  Next: IBCLR,  Prev: IANY,  Up: Intrinsic Procedures

9.139 'IARGC' -- Get the number of command line arguments
=========================================================

_Description_:
     'IARGC' returns the number of arguments passed on the command line
     when the containing program was invoked.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  In new code, programmers should consider the use
     of the *note COMMAND_ARGUMENT_COUNT:: intrinsic defined by the
     Fortran 2003 standard.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = IARGC()'

_Arguments_:
     None.

_Return value_:
     The number of command line arguments, type 'INTEGER(4)'.

_Example_:
     See *note GETARG::

_See also_:
     GNU Fortran 77 compatibility subroutine: *note GETARG::

     Fortran 2003 functions and subroutines: *note GET_COMMAND::, *note
     GET_COMMAND_ARGUMENT::, *note COMMAND_ARGUMENT_COUNT::


File: gfortran.info,  Node: IBCLR,  Next: IBITS,  Prev: IARGC,  Up: Intrinsic Procedures

9.140 'IBCLR' -- Clear bit
==========================

_Description_:
     'IBCLR' returns the value of I with the bit at position POS set to
     zero.

_Standard_:
     Fortran 95 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = IBCLR(I, POS)'

_Arguments_:
     I           The type shall be 'INTEGER'.
     POS         The type shall be 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER' and of the same kind as I.

_Specific names_:
     Name           Argument       Return type    Standard
     'IBCLR(A)'     'INTEGER A'    'INTEGER'      Fortran 95 and
                                                  later
     'BBCLR(A)'     'INTEGER(1)    'INTEGER(1)'   GNU extension
                    A'
     'IIBCLR(A)'    'INTEGER(2)    'INTEGER(2)'   GNU extension
                    A'
     'JIBCLR(A)'    'INTEGER(4)    'INTEGER(4)'   GNU extension
                    A'
     'KIBCLR(A)'    'INTEGER(8)    'INTEGER(8)'   GNU extension
                    A'

_See also_:
     *note IBITS::, *note IBSET::, *note IAND::, *note IOR::, *note
     IEOR::, *note MVBITS::


File: gfortran.info,  Node: IBITS,  Next: IBSET,  Prev: IBCLR,  Up: Intrinsic Procedures

9.141 'IBITS' -- Bit extraction
===============================

_Description_:
     'IBITS' extracts a field of length LEN from I, starting from bit
     position POS and extending left for LEN bits.  The result is
     right-justified and the remaining bits are zeroed.  The value of
     'POS+LEN' must be less than or equal to the value 'BIT_SIZE(I)'.

_Standard_:
     Fortran 95 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = IBITS(I, POS, LEN)'

_Arguments_:
     I           The type shall be 'INTEGER'.
     POS         The type shall be 'INTEGER'.
     LEN         The type shall be 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER' and of the same kind as I.

_Specific names_:
     Name           Argument       Return type    Standard
     'IBITS(A)'     'INTEGER A'    'INTEGER'      Fortran 95 and
                                                  later
     'BBITS(A)'     'INTEGER(1)    'INTEGER(1)'   GNU extension
                    A'
     'IIBITS(A)'    'INTEGER(2)    'INTEGER(2)'   GNU extension
                    A'
     'JIBITS(A)'    'INTEGER(4)    'INTEGER(4)'   GNU extension
                    A'
     'KIBITS(A)'    'INTEGER(8)    'INTEGER(8)'   GNU extension
                    A'

_See also_:
     *note BIT_SIZE::, *note IBCLR::, *note IBSET::, *note IAND::, *note
     IOR::, *note IEOR::


File: gfortran.info,  Node: IBSET,  Next: ICHAR,  Prev: IBITS,  Up: Intrinsic Procedures

9.142 'IBSET' -- Set bit
========================

_Description_:
     'IBSET' returns the value of I with the bit at position POS set to
     one.

_Standard_:
     Fortran 95 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = IBSET(I, POS)'

_Arguments_:
     I           The type shall be 'INTEGER'.
     POS         The type shall be 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER' and of the same kind as I.

_Specific names_:
     Name           Argument       Return type    Standard
     'IBSET(A)'     'INTEGER A'    'INTEGER'      Fortran 95 and
                                                  later
     'BBSET(A)'     'INTEGER(1)    'INTEGER(1)'   GNU extension
                    A'
     'IIBSET(A)'    'INTEGER(2)    'INTEGER(2)'   GNU extension
                    A'
     'JIBSET(A)'    'INTEGER(4)    'INTEGER(4)'   GNU extension
                    A'
     'KIBSET(A)'    'INTEGER(8)    'INTEGER(8)'   GNU extension
                    A'

_See also_:
     *note IBCLR::, *note IBITS::, *note IAND::, *note IOR::, *note
     IEOR::, *note MVBITS::


File: gfortran.info,  Node: ICHAR,  Next: IDATE,  Prev: IBSET,  Up: Intrinsic Procedures

9.143 'ICHAR' -- Character-to-integer conversion function
=========================================================

_Description_:
     'ICHAR(C)' returns the code for the character in the first
     character position of 'C' in the system's native character set.
     The correspondence between characters and their codes is not
     necessarily the same across different GNU Fortran implementations.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ICHAR(C [, KIND])'

_Arguments_:
     C           Shall be a scalar 'CHARACTER', with 'INTENT(IN)'
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER' and of kind KIND.  If KIND is
     absent, the return value is of default integer kind.

_Example_:
          program test_ichar
            integer i
            i = ichar(' ')
          end program test_ichar

_Specific names_:
     Name           Argument       Return type    Standard
     'ICHAR(C)'     'CHARACTER     'INTEGER(4)'   Fortran 77 and
                    C'                            later

_Note_:
     No intrinsic exists to convert between a numeric value and a
     formatted character string representation - for instance, given the
     'CHARACTER' value ''154'', obtaining an 'INTEGER' or 'REAL' value
     with the value 154, or vice versa.  Instead, this functionality is
     provided by internal-file I/O, as in the following example:
          program read_val
            integer value
            character(len=10) string, string2
            string = '154'

            ! Convert a string to a numeric value
            read (string,'(I10)') value
            print *, value

            ! Convert a value to a formatted string
            write (string2,'(I10)') value
            print *, string2
          end program read_val

_See also_:
     *note ACHAR::, *note CHAR::, *note IACHAR::


File: gfortran.info,  Node: IDATE,  Next: IEOR,  Prev: ICHAR,  Up: Intrinsic Procedures

9.144 'IDATE' -- Get current local time subroutine (day/month/year)
===================================================================

_Description_:
     'IDATE(VALUES)' Fills VALUES with the numerical values at the
     current local time.  The day (in the range 1-31), month (in the
     range 1-12), and year appear in elements 1, 2, and 3 of VALUES,
     respectively.  The year has four significant digits.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  In new code, programmers should consider the use
     of the *note DATE_AND_TIME:: intrinsic defined by the Fortran 95
     standard.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL IDATE(VALUES)'

_Arguments_:
     VALUES      The type shall be 'INTEGER, DIMENSION(3)' and
                 the kind shall be the default integer kind.

_Return value_:
     Does not return anything.

_Example_:
          program test_idate
            integer, dimension(3) :: tarray
            call idate(tarray)
            print *, tarray(1)
            print *, tarray(2)
            print *, tarray(3)
          end program test_idate

_See also_:
     *note DATE_AND_TIME::


File: gfortran.info,  Node: IEOR,  Next: IERRNO,  Prev: IDATE,  Up: Intrinsic Procedures

9.145 'IEOR' -- Bitwise logical exclusive or
============================================

_Description_:
     'IEOR' returns the bitwise Boolean exclusive-OR of I and J.

_Standard_:
     Fortran 95 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = IEOR(I, J)'

_Arguments_:
     I           The type shall be 'INTEGER' or a
                 boz-literal-constant.
     J           The type shall be 'INTEGER' with the same kind
                 type parameter as I or a boz-literal-constant.
                 I and J shall not both be boz-literal-constants.

_Return value_:
     The return type is 'INTEGER' with the kind type parameter of the
     arguments.  A boz-literal-constant is converted to an 'INTEGER'
     with the kind type parameter of the other argument as-if a call to
     *note INT:: occurred.

_Specific names_:
     Name           Argument       Return type    Standard
     'IEOR(A)'      'INTEGER A'    'INTEGER'      Fortran 95 and
                                                  later
     'BIEOR(A)'     'INTEGER(1)    'INTEGER(1)'   GNU extension
                    A'
     'IIEOR(A)'     'INTEGER(2)    'INTEGER(2)'   GNU extension
                    A'
     'JIEOR(A)'     'INTEGER(4)    'INTEGER(4)'   GNU extension
                    A'
     'KIEOR(A)'     'INTEGER(8)    'INTEGER(8)'   GNU extension
                    A'

_See also_:
     *note IOR::, *note IAND::, *note IBITS::, *note IBSET::, *note
     IBCLR::, *note NOT::


File: gfortran.info,  Node: IERRNO,  Next: IMAGE_INDEX,  Prev: IEOR,  Up: Intrinsic Procedures

9.146 'IERRNO' -- Get the last system error number
==================================================

_Description_:
     Returns the last system error number, as given by the C 'errno'
     variable.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = IERRNO()'

_Arguments_:
     None.

_Return value_:
     The return value is of type 'INTEGER' and of the default integer
     kind.

_See also_:
     *note PERROR::


File: gfortran.info,  Node: IMAGE_INDEX,  Next: INDEX intrinsic,  Prev: IERRNO,  Up: Intrinsic Procedures

9.147 'IMAGE_INDEX' -- Function that converts a cosubscript to an image index
=============================================================================

_Description_:
     Returns the image index belonging to a cosubscript.

_Standard_:
     Fortran 2008 and later

_Class_:
     Inquiry function.

_Syntax_:
     'RESULT = IMAGE_INDEX(COARRAY, SUB)'

_Arguments_: None.
     COARRAY     Coarray of any type.
     SUB         default integer rank-1 array of a size equal to
                 the corank of COARRAY.

_Return value_:
     Scalar default integer with the value of the image index which
     corresponds to the cosubscripts.  For invalid cosubscripts the
     result is zero.

_Example_:
          INTEGER :: array[2,-1:4,8,*]
          ! Writes  28 (or 0 if there are fewer than 28 images)
          WRITE (*,*) IMAGE_INDEX (array, [2,0,3,1])

_See also_:
     *note THIS_IMAGE::, *note NUM_IMAGES::


File: gfortran.info,  Node: INDEX intrinsic,  Next: INT,  Prev: IMAGE_INDEX,  Up: Intrinsic Procedures

9.148 'INDEX' -- Position of a substring within a string
========================================================

_Description_:
     Returns the position of the start of the first occurrence of string
     SUBSTRING as a substring in STRING, counting from one.  If
     SUBSTRING is not present in STRING, zero is returned.  If the BACK
     argument is present and true, the return value is the start of the
     last occurrence rather than the first.

_Standard_:
     Fortran 77 and later, with KIND argument Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = INDEX(STRING, SUBSTRING [, BACK [, KIND]])'

_Arguments_:
     STRING      Shall be a scalar 'CHARACTER', with 'INTENT(IN)'
     SUBSTRING   Shall be a scalar 'CHARACTER', with 'INTENT(IN)'
     BACK        (Optional) Shall be a scalar 'LOGICAL', with
                 'INTENT(IN)'
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER' and of kind KIND.  If KIND is
     absent, the return value is of default integer kind.

_Specific names_:
     Name           Argument       Return type    Standard
     'INDEX(STRING, 'CHARACTER'    'INTEGER(4)'   Fortran 77 and
     SUBSTRING)'                                  later

_See also_:
     *note SCAN::, *note VERIFY::


File: gfortran.info,  Node: INT,  Next: INT2,  Prev: INDEX intrinsic,  Up: Intrinsic Procedures

9.149 'INT' -- Convert to integer type
======================================

_Description_:
     Convert to integer type

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = INT(A [, KIND))'

_Arguments_:
     A           Shall be of type 'INTEGER', 'REAL', or
                 'COMPLEX'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     These functions return a 'INTEGER' variable or array under the
     following rules:

     (A)
          If A is of type 'INTEGER', 'INT(A) = A'
     (B)
          If A is of type 'REAL' and |A| < 1, 'INT(A)' equals '0'.  If
          |A| \geq 1, then 'INT(A)' is the integer whose magnitude is
          the largest integer that does not exceed the magnitude of A
          and whose sign is the same as the sign of A.
     (C)
          If A is of type 'COMPLEX', rule B is applied to the real part
          of A.

_Example_:
          program test_int
            integer :: i = 42
            complex :: z = (-3.7, 1.0)
            print *, int(i)
            print *, int(z), int(z,8)
          end program

_Specific names_:
     Name           Argument       Return type    Standard
     'INT(A)'       'REAL(4) A'    'INTEGER'      Fortran 77 and
                                                  later
     'IFIX(A)'      'REAL(4) A'    'INTEGER'      Fortran 77 and
                                                  later
     'IDINT(A)'     'REAL(8) A'    'INTEGER'      Fortran 77 and
                                                  later


File: gfortran.info,  Node: INT2,  Next: INT8,  Prev: INT,  Up: Intrinsic Procedures

9.150 'INT2' -- Convert to 16-bit integer type
==============================================

_Description_:
     Convert to a 'KIND=2' integer type.  This is equivalent to the
     standard 'INT' intrinsic with an optional argument of 'KIND=2', and
     is only included for backwards compatibility.

     The 'SHORT' intrinsic is equivalent to 'INT2'.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     'RESULT = INT2(A)'

_Arguments_:
     A           Shall be of type 'INTEGER', 'REAL', or
                 'COMPLEX'.

_Return value_:
     The return value is a 'INTEGER(2)' variable.

_See also_:
     *note INT::, *note INT8::, *note LONG::


File: gfortran.info,  Node: INT8,  Next: IOR,  Prev: INT2,  Up: Intrinsic Procedures

9.151 'INT8' -- Convert to 64-bit integer type
==============================================

_Description_:
     Convert to a 'KIND=8' integer type.  This is equivalent to the
     standard 'INT' intrinsic with an optional argument of 'KIND=8', and
     is only included for backwards compatibility.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     'RESULT = INT8(A)'

_Arguments_:
     A           Shall be of type 'INTEGER', 'REAL', or
                 'COMPLEX'.

_Return value_:
     The return value is a 'INTEGER(8)' variable.

_See also_:
     *note INT::, *note INT2::, *note LONG::


File: gfortran.info,  Node: IOR,  Next: IPARITY,  Prev: INT8,  Up: Intrinsic Procedures

9.152 'IOR' -- Bitwise logical or
=================================

_Description_:
     'IOR' returns the bitwise Boolean inclusive-OR of I and J.

_Standard_:
     Fortran 95 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = IOR(I, J)'

_Arguments_:
     I           The type shall be 'INTEGER' or a
                 boz-literal-constant.
     J           The type shall be 'INTEGER' with the same kind
                 type parameter as I or a boz-literal-constant.
                 I and J shall not both be boz-literal-constants.

_Return value_:
     The return type is 'INTEGER' with the kind type parameter of the
     arguments.  A boz-literal-constant is converted to an 'INTEGER'
     with the kind type parameter of the other argument as-if a call to
     *note INT:: occurred.

_Specific names_:
     Name           Argument       Return type    Standard
     'IOR(A)'       'INTEGER A'    'INTEGER'      Fortran 95 and
                                                  later
     'BIOR(A)'      'INTEGER(1)    'INTEGER(1)'   GNU extension
                    A'
     'IIOR(A)'      'INTEGER(2)    'INTEGER(2)'   GNU extension
                    A'
     'JIOR(A)'      'INTEGER(4)    'INTEGER(4)'   GNU extension
                    A'
     'KIOR(A)'      'INTEGER(8)    'INTEGER(8)'   GNU extension
                    A'

_See also_:
     *note IEOR::, *note IAND::, *note IBITS::, *note IBSET::, *note
     IBCLR::, *note NOT::


File: gfortran.info,  Node: IPARITY,  Next: IRAND,  Prev: IOR,  Up: Intrinsic Procedures

9.153 'IPARITY' -- Bitwise XOR of array elements
================================================

_Description_:
     Reduces with bitwise XOR (exclusive or) the elements of ARRAY along
     dimension DIM if the corresponding element in MASK is 'TRUE'.

_Standard_:
     Fortran 2008 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = IPARITY(ARRAY[, MASK])'
     'RESULT = IPARITY(ARRAY, DIM[, MASK])'

_Arguments_:
     ARRAY       Shall be an array of type 'INTEGER'
     DIM         (Optional) shall be a scalar of type 'INTEGER'
                 with a value in the range from 1 to n, where n
                 equals the rank of ARRAY.
     MASK        (Optional) shall be of type 'LOGICAL' and either
                 be a scalar or an array of the same shape as
                 ARRAY.

_Return value_:
     The result is of the same type as ARRAY.

     If DIM is absent, a scalar with the bitwise XOR of all elements in
     ARRAY is returned.  Otherwise, an array of rank n-1, where n equals
     the rank of ARRAY, and a shape similar to that of ARRAY with
     dimension DIM dropped is returned.

_Example_:
          PROGRAM test_iparity
            INTEGER(1) :: a(2)

            a(1) = b'00100100'
            a(2) = b'01101010'

            ! prints 01001110
            PRINT '(b8.8)', IPARITY(a)
          END PROGRAM

_See also_:
     *note IANY::, *note IALL::, *note IEOR::, *note PARITY::


File: gfortran.info,  Node: IRAND,  Next: IS_CONTIGUOUS,  Prev: IPARITY,  Up: Intrinsic Procedures

9.154 'IRAND' -- Integer pseudo-random number
=============================================

_Description_:
     'IRAND(FLAG)' returns a pseudo-random number from a uniform
     distribution between 0 and a system-dependent limit (which is in
     most cases 2147483647).  If FLAG is 0, the next number in the
     current sequence is returned; if FLAG is 1, the generator is
     restarted by 'CALL SRAND(0)'; if FLAG has any other value, it is
     used as a new seed with 'SRAND'.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  It implements a simple modulo generator as
     provided by 'g77'.  For new code, one should consider the use of
     *note RANDOM_NUMBER:: as it implements a superior algorithm.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = IRAND(I)'

_Arguments_:
     I           Shall be a scalar 'INTEGER' of kind 4.

_Return value_:
     The return value is of 'INTEGER(kind=4)' type.

_Example_:
          program test_irand
            integer,parameter :: seed = 86456

            call srand(seed)
            print *, irand(), irand(), irand(), irand()
            print *, irand(seed), irand(), irand(), irand()
          end program test_irand


File: gfortran.info,  Node: IS_CONTIGUOUS,  Next: IS_IOSTAT_END,  Prev: IRAND,  Up: Intrinsic Procedures

9.155 'IS_CONTIGUOUS' -- Test whether an array is contiguous
============================================================

_Description_:
     'IS_CONTIGUOUS' tests whether an array is contiguous.

_Standard_:
     Fortran 2008 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = IS_CONTIGUOUS(ARRAY)'

_Arguments_:
     ARRAY       Shall be an array of any type.

_Return value_:
     Returns a 'LOGICAL' of the default kind, which '.TRUE.' if ARRAY is
     contiguous and false otherwise.

_Example_:
          program test
            integer :: a(10)
            a = [1,2,3,4,5,6,7,8,9,10]
            call sub (a)      ! every element, is contiguous
            call sub (a(::2)) ! every other element, is noncontiguous
          contains
            subroutine sub (x)
              integer :: x(:)
              if (is_contiguous (x)) then
                write (*,*) 'X is contiguous'
              else
                write (*,*) 'X is not contiguous'
              end if
            end subroutine sub
          end program test


File: gfortran.info,  Node: IS_IOSTAT_END,  Next: IS_IOSTAT_EOR,  Prev: IS_CONTIGUOUS,  Up: Intrinsic Procedures

9.156 'IS_IOSTAT_END' -- Test for end-of-file value
===================================================

_Description_:
     'IS_IOSTAT_END' tests whether an variable has the value of the I/O
     status "end of file".  The function is equivalent to comparing the
     variable with the 'IOSTAT_END' parameter of the intrinsic module
     'ISO_FORTRAN_ENV'.

_Standard_:
     Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = IS_IOSTAT_END(I)'

_Arguments_:
     I           Shall be of the type 'INTEGER'.

_Return value_:
     Returns a 'LOGICAL' of the default kind, which '.TRUE.' if I has
     the value which indicates an end of file condition for 'IOSTAT='
     specifiers, and is '.FALSE.' otherwise.

_Example_:
          PROGRAM iostat
            IMPLICIT NONE
            INTEGER :: stat, i
            OPEN(88, FILE='test.dat')
            READ(88, *, IOSTAT=stat) i
            IF(IS_IOSTAT_END(stat)) STOP 'END OF FILE'
          END PROGRAM


File: gfortran.info,  Node: IS_IOSTAT_EOR,  Next: ISATTY,  Prev: IS_IOSTAT_END,  Up: Intrinsic Procedures

9.157 'IS_IOSTAT_EOR' -- Test for end-of-record value
=====================================================

_Description_:
     'IS_IOSTAT_EOR' tests whether an variable has the value of the I/O
     status "end of record".  The function is equivalent to comparing
     the variable with the 'IOSTAT_EOR' parameter of the intrinsic
     module 'ISO_FORTRAN_ENV'.

_Standard_:
     Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = IS_IOSTAT_EOR(I)'

_Arguments_:
     I           Shall be of the type 'INTEGER'.

_Return value_:
     Returns a 'LOGICAL' of the default kind, which '.TRUE.' if I has
     the value which indicates an end of file condition for 'IOSTAT='
     specifiers, and is '.FALSE.' otherwise.

_Example_:
          PROGRAM iostat
            IMPLICIT NONE
            INTEGER :: stat, i(50)
            OPEN(88, FILE='test.dat', FORM='UNFORMATTED')
            READ(88, IOSTAT=stat) i
            IF(IS_IOSTAT_EOR(stat)) STOP 'END OF RECORD'
          END PROGRAM


File: gfortran.info,  Node: ISATTY,  Next: ISHFT,  Prev: IS_IOSTAT_EOR,  Up: Intrinsic Procedures

9.158 'ISATTY' -- Whether a unit is a terminal device.
======================================================

_Description_:
     Determine whether a unit is connected to a terminal device.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = ISATTY(UNIT)'

_Arguments_:
     UNIT        Shall be a scalar 'INTEGER'.

_Return value_:
     Returns '.TRUE.' if the UNIT is connected to a terminal device,
     '.FALSE.' otherwise.

_Example_:
          PROGRAM test_isatty
            INTEGER(kind=1) :: unit
            DO unit = 1, 10
              write(*,*) isatty(unit=unit)
            END DO
          END PROGRAM
_See also_:
     *note TTYNAM::


File: gfortran.info,  Node: ISHFT,  Next: ISHFTC,  Prev: ISATTY,  Up: Intrinsic Procedures

9.159 'ISHFT' -- Shift bits
===========================

_Description_:
     'ISHFT' returns a value corresponding to I with all of the bits
     shifted SHIFT places.  A value of SHIFT greater than zero
     corresponds to a left shift, a value of zero corresponds to no
     shift, and a value less than zero corresponds to a right shift.  If
     the absolute value of SHIFT is greater than 'BIT_SIZE(I)', the
     value is undefined.  Bits shifted out from the left end or right
     end are lost; zeros are shifted in from the opposite end.

_Standard_:
     Fortran 95 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ISHFT(I, SHIFT)'

_Arguments_:
     I           The type shall be 'INTEGER'.
     SHIFT       The type shall be 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER' and of the same kind as I.

_Specific names_:
     Name           Argument       Return type    Standard
     'ISHFT(A)'     'INTEGER A'    'INTEGER'      Fortran 95 and
                                                  later
     'BSHFT(A)'     'INTEGER(1)    'INTEGER(1)'   GNU extension
                    A'
     'IISHFT(A)'    'INTEGER(2)    'INTEGER(2)'   GNU extension
                    A'
     'JISHFT(A)'    'INTEGER(4)    'INTEGER(4)'   GNU extension
                    A'
     'KISHFT(A)'    'INTEGER(8)    'INTEGER(8)'   GNU extension
                    A'

_See also_:
     *note ISHFTC::


File: gfortran.info,  Node: ISHFTC,  Next: ISNAN,  Prev: ISHFT,  Up: Intrinsic Procedures

9.160 'ISHFTC' -- Shift bits circularly
=======================================

_Description_:
     'ISHFTC' returns a value corresponding to I with the rightmost SIZE
     bits shifted circularly SHIFT places; that is, bits shifted out one
     end are shifted into the opposite end.  A value of SHIFT greater
     than zero corresponds to a left shift, a value of zero corresponds
     to no shift, and a value less than zero corresponds to a right
     shift.  The absolute value of SHIFT must be less than SIZE.  If the
     SIZE argument is omitted, it is taken to be equivalent to
     'BIT_SIZE(I)'.

_Standard_:
     Fortran 95 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = ISHFTC(I, SHIFT [, SIZE])'

_Arguments_:
     I           The type shall be 'INTEGER'.
     SHIFT       The type shall be 'INTEGER'.
     SIZE        (Optional) The type shall be 'INTEGER'; the
                 value must be greater than zero and less than or
                 equal to 'BIT_SIZE(I)'.

_Return value_:
     The return value is of type 'INTEGER' and of the same kind as I.

_Specific names_:
     Name           Argument       Return type    Standard
     'ISHFTC(A)'    'INTEGER A'    'INTEGER'      Fortran 95 and
                                                  later
     'BSHFTC(A)'    'INTEGER(1)    'INTEGER(1)'   GNU extension
                    A'
     'IISHFTC(A)'   'INTEGER(2)    'INTEGER(2)'   GNU extension
                    A'
     'JISHFTC(A)'   'INTEGER(4)    'INTEGER(4)'   GNU extension
                    A'
     'KISHFTC(A)'   'INTEGER(8)    'INTEGER(8)'   GNU extension
                    A'

_See also_:
     *note ISHFT::


File: gfortran.info,  Node: ISNAN,  Next: ITIME,  Prev: ISHFTC,  Up: Intrinsic Procedures

9.161 'ISNAN' -- Test for a NaN
===============================

_Description_:
     'ISNAN' tests whether a floating-point value is an IEEE
     Not-a-Number (NaN).
_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     'ISNAN(X)'

_Arguments_:
     X           Variable of the type 'REAL'.
                 

_Return value_:
     Returns a default-kind 'LOGICAL'.  The returned value is 'TRUE' if
     X is a NaN and 'FALSE' otherwise.

_Example_:
          program test_nan
            implicit none
            real :: x
            x = -1.0
            x = sqrt(x)
            if (isnan(x)) stop '"x" is a NaN'
          end program test_nan


File: gfortran.info,  Node: ITIME,  Next: KILL,  Prev: ISNAN,  Up: Intrinsic Procedures

9.162 'ITIME' -- Get current local time subroutine (hour/minutes/seconds)
=========================================================================

_Description_:
     'ITIME(VALUES)' Fills VALUES with the numerical values at the
     current local time.  The hour (in the range 1-24), minute (in the
     range 1-60), and seconds (in the range 1-60) appear in elements 1,
     2, and 3 of VALUES, respectively.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  In new code, programmers should consider the use
     of the *note DATE_AND_TIME:: intrinsic defined by the Fortran 95
     standard.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL ITIME(VALUES)'

_Arguments_:
     VALUES      The type shall be 'INTEGER, DIMENSION(3)' and
                 the kind shall be the default integer kind.

_Return value_:
     Does not return anything.

_Example_:
          program test_itime
            integer, dimension(3) :: tarray
            call itime(tarray)
            print *, tarray(1)
            print *, tarray(2)
            print *, tarray(3)
          end program test_itime

_See also_:
     *note DATE_AND_TIME::


File: gfortran.info,  Node: KILL,  Next: KIND,  Prev: ITIME,  Up: Intrinsic Procedures

9.163 'KILL' -- Send a signal to a process
==========================================

_Description_:
_Standard_:
     Sends the signal specified by SIG to the process PID.  See
     'kill(2)'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Class_:
     Subroutine, function

_Syntax_:
     'CALL KILL(PID, SIG [, STATUS])'
     'STATUS = KILL(PID, SIG)'

_Arguments_:
     PID         Shall be a scalar 'INTEGER' with 'INTENT(IN)'.
     SIG         Shall be a scalar 'INTEGER' with 'INTENT(IN)'.
     STATUS      [Subroutine](Optional) Shall be a scalar
                 'INTEGER'.  Returns 0 on success; otherwise a
                 system-specific error code is returned.
     STATUS      [Function] The kind type parameter is that of
                 'pid'.  Returns 0 on success; otherwise a
                 system-specific error code is returned.

_See also_:
     *note ABORT::, *note EXIT::


File: gfortran.info,  Node: KIND,  Next: LBOUND,  Prev: KILL,  Up: Intrinsic Procedures

9.164 'KIND' -- Kind of an entity
=================================

_Description_:
     'KIND(X)' returns the kind value of the entity X.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     'K = KIND(X)'

_Arguments_:
     X           Shall be of type 'LOGICAL', 'INTEGER', 'REAL',
                 'COMPLEX' or 'CHARACTER'.

_Return value_:
     The return value is a scalar of type 'INTEGER' and of the default
     integer kind.

_Example_:
          program test_kind
            integer,parameter :: kc = kind(' ')
            integer,parameter :: kl = kind(.true.)

            print *, "The default character kind is ", kc
            print *, "The default logical kind is ", kl
          end program test_kind


File: gfortran.info,  Node: LBOUND,  Next: LCOBOUND,  Prev: KIND,  Up: Intrinsic Procedures

9.165 'LBOUND' -- Lower dimension bounds of an array
====================================================

_Description_:
     Returns the lower bounds of an array, or a single lower bound along
     the DIM dimension.
_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = LBOUND(ARRAY [, DIM [, KIND]])'

_Arguments_:
     ARRAY       Shall be an array, of any type.
     DIM         (Optional) Shall be a scalar 'INTEGER'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER' and of kind KIND.  If KIND is
     absent, the return value is of default integer kind.  If DIM is
     absent, the result is an array of the lower bounds of ARRAY.  If
     DIM is present, the result is a scalar corresponding to the lower
     bound of the array along that dimension.  If ARRAY is an expression
     rather than a whole array or array structure component, or if it
     has a zero extent along the relevant dimension, the lower bound is
     taken to be 1.

_See also_:
     *note UBOUND::, *note LCOBOUND::


File: gfortran.info,  Node: LCOBOUND,  Next: LEADZ,  Prev: LBOUND,  Up: Intrinsic Procedures

9.166 'LCOBOUND' -- Lower codimension bounds of an array
========================================================

_Description_:
     Returns the lower bounds of a coarray, or a single lower cobound
     along the DIM codimension.
_Standard_:
     Fortran 2008 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = LCOBOUND(COARRAY [, DIM [, KIND]])'

_Arguments_:
     ARRAY       Shall be an coarray, of any type.
     DIM         (Optional) Shall be a scalar 'INTEGER'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER' and of kind KIND.  If KIND is
     absent, the return value is of default integer kind.  If DIM is
     absent, the result is an array of the lower cobounds of COARRAY.
     If DIM is present, the result is a scalar corresponding to the
     lower cobound of the array along that codimension.

_See also_:
     *note UCOBOUND::, *note LBOUND::


File: gfortran.info,  Node: LEADZ,  Next: LEN,  Prev: LCOBOUND,  Up: Intrinsic Procedures

9.167 'LEADZ' -- Number of leading zero bits of an integer
==========================================================

_Description_:
     'LEADZ' returns the number of leading zero bits of an integer.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = LEADZ(I)'

_Arguments_:
     I           Shall be of type 'INTEGER'.

_Return value_:
     The type of the return value is the default 'INTEGER'.  If all the
     bits of 'I' are zero, the result value is 'BIT_SIZE(I)'.

_Example_:
          PROGRAM test_leadz
            WRITE (*,*) BIT_SIZE(1)  ! prints 32
            WRITE (*,*) LEADZ(1)     ! prints 31
          END PROGRAM

_See also_:
     *note BIT_SIZE::, *note TRAILZ::, *note POPCNT::, *note POPPAR::


File: gfortran.info,  Node: LEN,  Next: LEN_TRIM,  Prev: LEADZ,  Up: Intrinsic Procedures

9.168 'LEN' -- Length of a character entity
===========================================

_Description_:
     Returns the length of a character string.  If STRING is an array,
     the length of an element of STRING is returned.  Note that STRING
     need not be defined when this intrinsic is invoked, since only the
     length, not the content, of STRING is needed.

_Standard_:
     Fortran 77 and later, with KIND argument Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     'L = LEN(STRING [, KIND])'

_Arguments_:
     STRING      Shall be a scalar or array of type 'CHARACTER',
                 with 'INTENT(IN)'
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER' and of kind KIND.  If KIND is
     absent, the return value is of default integer kind.

_Specific names_:
     Name           Argument       Return type    Standard
     'LEN(STRING)'  'CHARACTER'    'INTEGER'      Fortran 77 and
                                                  later

_See also_:
     *note LEN_TRIM::, *note ADJUSTL::, *note ADJUSTR::


File: gfortran.info,  Node: LEN_TRIM,  Next: LGE,  Prev: LEN,  Up: Intrinsic Procedures

9.169 'LEN_TRIM' -- Length of a character entity without trailing blank characters
==================================================================================

_Description_:
     Returns the length of a character string, ignoring any trailing
     blanks.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = LEN_TRIM(STRING [, KIND])'

_Arguments_:
     STRING      Shall be a scalar of type 'CHARACTER', with
                 'INTENT(IN)'
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER' and of kind KIND.  If KIND is
     absent, the return value is of default integer kind.

_See also_:
     *note LEN::, *note ADJUSTL::, *note ADJUSTR::


File: gfortran.info,  Node: LGE,  Next: LGT,  Prev: LEN_TRIM,  Up: Intrinsic Procedures

9.170 'LGE' -- Lexical greater than or equal
============================================

_Description_:
     Determines whether one string is lexically greater than or equal to
     another string, where the two strings are interpreted as containing
     ASCII character codes.  If the String A and String B are not the
     same length, the shorter is compared as if spaces were appended to
     it to form a value that has the same length as the longer.

     In general, the lexical comparison intrinsics 'LGE', 'LGT', 'LLE',
     and 'LLT' differ from the corresponding intrinsic operators '.GE.',
     '.GT.', '.LE.', and '.LT.', in that the latter use the processor's
     character ordering (which is not ASCII on some targets), whereas
     the former always use the ASCII ordering.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = LGE(STRING_A, STRING_B)'

_Arguments_:
     STRING_A    Shall be of default 'CHARACTER' type.
     STRING_B    Shall be of default 'CHARACTER' type.

_Return value_:
     Returns '.TRUE.' if 'STRING_A >= STRING_B', and '.FALSE.'
     otherwise, based on the ASCII ordering.

_Specific names_:
     Name           Argument       Return type    Standard
     'LGE(STRING_A, 'CHARACTER'    'LOGICAL'      Fortran 77 and
     STRING_B)'                                   later

_See also_:
     *note LGT::, *note LLE::, *note LLT::


File: gfortran.info,  Node: LGT,  Next: LINK,  Prev: LGE,  Up: Intrinsic Procedures

9.171 'LGT' -- Lexical greater than
===================================

_Description_:
     Determines whether one string is lexically greater than another
     string, where the two strings are interpreted as containing ASCII
     character codes.  If the String A and String B are not the same
     length, the shorter is compared as if spaces were appended to it to
     form a value that has the same length as the longer.

     In general, the lexical comparison intrinsics 'LGE', 'LGT', 'LLE',
     and 'LLT' differ from the corresponding intrinsic operators '.GE.',
     '.GT.', '.LE.', and '.LT.', in that the latter use the processor's
     character ordering (which is not ASCII on some targets), whereas
     the former always use the ASCII ordering.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = LGT(STRING_A, STRING_B)'

_Arguments_:
     STRING_A    Shall be of default 'CHARACTER' type.
     STRING_B    Shall be of default 'CHARACTER' type.

_Return value_:
     Returns '.TRUE.' if 'STRING_A > STRING_B', and '.FALSE.' otherwise,
     based on the ASCII ordering.

_Specific names_:
     Name           Argument       Return type    Standard
     'LGT(STRING_A, 'CHARACTER'    'LOGICAL'      Fortran 77 and
     STRING_B)'                                   later

_See also_:
     *note LGE::, *note LLE::, *note LLT::


File: gfortran.info,  Node: LINK,  Next: LLE,  Prev: LGT,  Up: Intrinsic Procedures

9.172 'LINK' -- Create a hard link
==================================

_Description_:
     Makes a (hard) link from file PATH1 to PATH2.  A null character
     ('CHAR(0)') can be used to mark the end of the names in PATH1 and
     PATH2; otherwise, trailing blanks in the file names are ignored.
     If the STATUS argument is supplied, it contains 0 on success or a
     nonzero error code upon return; see 'link(2)'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL LINK(PATH1, PATH2 [, STATUS])'
     'STATUS = LINK(PATH1, PATH2)'

_Arguments_:
     PATH1       Shall be of default 'CHARACTER' type.
     PATH2       Shall be of default 'CHARACTER' type.
     STATUS      (Optional) Shall be of default 'INTEGER' type.

_See also_:
     *note SYMLNK::, *note UNLINK::


File: gfortran.info,  Node: LLE,  Next: LLT,  Prev: LINK,  Up: Intrinsic Procedures

9.173 'LLE' -- Lexical less than or equal
=========================================

_Description_:
     Determines whether one string is lexically less than or equal to
     another string, where the two strings are interpreted as containing
     ASCII character codes.  If the String A and String B are not the
     same length, the shorter is compared as if spaces were appended to
     it to form a value that has the same length as the longer.

     In general, the lexical comparison intrinsics 'LGE', 'LGT', 'LLE',
     and 'LLT' differ from the corresponding intrinsic operators '.GE.',
     '.GT.', '.LE.', and '.LT.', in that the latter use the processor's
     character ordering (which is not ASCII on some targets), whereas
     the former always use the ASCII ordering.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = LLE(STRING_A, STRING_B)'

_Arguments_:
     STRING_A    Shall be of default 'CHARACTER' type.
     STRING_B    Shall be of default 'CHARACTER' type.

_Return value_:
     Returns '.TRUE.' if 'STRING_A <= STRING_B', and '.FALSE.'
     otherwise, based on the ASCII ordering.

_Specific names_:
     Name           Argument       Return type    Standard
     'LLE(STRING_A, 'CHARACTER'    'LOGICAL'      Fortran 77 and
     STRING_B)'                                   later

_See also_:
     *note LGE::, *note LGT::, *note LLT::


File: gfortran.info,  Node: LLT,  Next: LNBLNK,  Prev: LLE,  Up: Intrinsic Procedures

9.174 'LLT' -- Lexical less than
================================

_Description_:
     Determines whether one string is lexically less than another
     string, where the two strings are interpreted as containing ASCII
     character codes.  If the String A and String B are not the same
     length, the shorter is compared as if spaces were appended to it to
     form a value that has the same length as the longer.

     In general, the lexical comparison intrinsics 'LGE', 'LGT', 'LLE',
     and 'LLT' differ from the corresponding intrinsic operators '.GE.',
     '.GT.', '.LE.', and '.LT.', in that the latter use the processor's
     character ordering (which is not ASCII on some targets), whereas
     the former always use the ASCII ordering.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = LLT(STRING_A, STRING_B)'

_Arguments_:
     STRING_A    Shall be of default 'CHARACTER' type.
     STRING_B    Shall be of default 'CHARACTER' type.

_Return value_:
     Returns '.TRUE.' if 'STRING_A < STRING_B', and '.FALSE.' otherwise,
     based on the ASCII ordering.

_Specific names_:
     Name           Argument       Return type    Standard
     'LLT(STRING_A, 'CHARACTER'    'LOGICAL'      Fortran 77 and
     STRING_B)'                                   later

_See also_:
     *note LGE::, *note LGT::, *note LLE::


File: gfortran.info,  Node: LNBLNK,  Next: LOC,  Prev: LLT,  Up: Intrinsic Procedures

9.175 'LNBLNK' -- Index of the last non-blank character in a string
===================================================================

_Description_:
     Returns the length of a character string, ignoring any trailing
     blanks.  This is identical to the standard 'LEN_TRIM' intrinsic,
     and is only included for backwards compatibility.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     'RESULT = LNBLNK(STRING)'

_Arguments_:
     STRING      Shall be a scalar of type 'CHARACTER', with
                 'INTENT(IN)'

_Return value_:
     The return value is of 'INTEGER(kind=4)' type.

_See also_:
     *note INDEX intrinsic::, *note LEN_TRIM::


File: gfortran.info,  Node: LOC,  Next: LOG,  Prev: LNBLNK,  Up: Intrinsic Procedures

9.176 'LOC' -- Returns the address of a variable
================================================

_Description_:
     'LOC(X)' returns the address of X as an integer.

_Standard_:
     GNU extension

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = LOC(X)'

_Arguments_:
     X           Variable of any type.

_Return value_:
     The return value is of type 'INTEGER', with a 'KIND' corresponding
     to the size (in bytes) of a memory address on the target machine.

_Example_:
          program test_loc
            integer :: i
            real :: r
            i = loc(r)
            print *, i
          end program test_loc


File: gfortran.info,  Node: LOG,  Next: LOG10,  Prev: LOC,  Up: Intrinsic Procedures

9.177 'LOG' -- Natural logarithm function
=========================================

_Description_:
     'LOG(X)' computes the natural logarithm of X, i.e.  the logarithm
     to the base e.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = LOG(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value is of type 'REAL' or 'COMPLEX'.  The kind type
     parameter is the same as X.  If X is 'COMPLEX', the imaginary part
     \omega is in the range -\pi < \omega \leq \pi.

_Example_:
          program test_log
            real(8) :: x = 2.7182818284590451_8
            complex :: z = (1.0, 2.0)
            x = log(x)    ! will yield (approximately) 1
            z = log(z)
          end program test_log

_Specific names_:
     Name           Argument       Return type    Standard
     'ALOG(X)'      'REAL(4) X'    'REAL(4)'      f95, gnu
     'DLOG(X)'      'REAL(8) X'    'REAL(8)'      f95, gnu
     'CLOG(X)'      'COMPLEX(4)    'COMPLEX(4)'   f95, gnu
                    X'
     'ZLOG(X)'      'COMPLEX(8)    'COMPLEX(8)'   f95, gnu
                    X'
     'CDLOG(X)'     'COMPLEX(8)    'COMPLEX(8)'   f95, gnu
                    X'


File: gfortran.info,  Node: LOG10,  Next: LOG_GAMMA,  Prev: LOG,  Up: Intrinsic Procedures

9.178 'LOG10' -- Base 10 logarithm function
===========================================

_Description_:
     'LOG10(X)' computes the base 10 logarithm of X.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = LOG10(X)'

_Arguments_:
     X           The type shall be 'REAL'.

_Return value_:
     The return value is of type 'REAL' or 'COMPLEX'.  The kind type
     parameter is the same as X.

_Example_:
          program test_log10
            real(8) :: x = 10.0_8
            x = log10(x)
          end program test_log10

_Specific names_:
     Name           Argument       Return type    Standard
     'ALOG10(X)'    'REAL(4) X'    'REAL(4)'      Fortran 95 and
                                                  later
     'DLOG10(X)'    'REAL(8) X'    'REAL(8)'      Fortran 95 and
                                                  later


File: gfortran.info,  Node: LOG_GAMMA,  Next: LOGICAL,  Prev: LOG10,  Up: Intrinsic Procedures

9.179 'LOG_GAMMA' -- Logarithm of the Gamma function
====================================================

_Description_:
     'LOG_GAMMA(X)' computes the natural logarithm of the absolute value
     of the Gamma (\Gamma) function.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'X = LOG_GAMMA(X)'

_Arguments_:
     X           Shall be of type 'REAL' and neither zero nor a
                 negative integer.

_Return value_:
     The return value is of type 'REAL' of the same kind as X.

_Example_:
          program test_log_gamma
            real :: x = 1.0
            x = lgamma(x) ! returns 0.0
          end program test_log_gamma

_Specific names_:
     Name           Argument       Return type    Standard
     'LGAMMA(X)'    'REAL(4) X'    'REAL(4)'      GNU Extension
     'ALGAMA(X)'    'REAL(4) X'    'REAL(4)'      GNU Extension
     'DLGAMA(X)'    'REAL(8) X'    'REAL(8)'      GNU Extension

_See also_:
     Gamma function: *note GAMMA::


File: gfortran.info,  Node: LOGICAL,  Next: LONG,  Prev: LOG_GAMMA,  Up: Intrinsic Procedures

9.180 'LOGICAL' -- Convert to logical type
==========================================

_Description_:
     Converts one kind of 'LOGICAL' variable to another.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = LOGICAL(L [, KIND])'

_Arguments_:
     L           The type shall be 'LOGICAL'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is a 'LOGICAL' value equal to L, with a kind
     corresponding to KIND, or of the default logical kind if KIND is
     not given.

_See also_:
     *note INT::, *note REAL::, *note CMPLX::


File: gfortran.info,  Node: LONG,  Next: LSHIFT,  Prev: LOGICAL,  Up: Intrinsic Procedures

9.181 'LONG' -- Convert to integer type
=======================================

_Description_:
     Convert to a 'KIND=4' integer type, which is the same size as a C
     'long' integer.  This is equivalent to the standard 'INT' intrinsic
     with an optional argument of 'KIND=4', and is only included for
     backwards compatibility.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     'RESULT = LONG(A)'

_Arguments_:
     A           Shall be of type 'INTEGER', 'REAL', or
                 'COMPLEX'.

_Return value_:
     The return value is a 'INTEGER(4)' variable.

_See also_:
     *note INT::, *note INT2::, *note INT8::


File: gfortran.info,  Node: LSHIFT,  Next: LSTAT,  Prev: LONG,  Up: Intrinsic Procedures

9.182 'LSHIFT' -- Left shift bits
=================================

_Description_:
     'LSHIFT' returns a value corresponding to I with all of the bits
     shifted left by SHIFT places.  SHIFT shall be nonnegative and less
     than or equal to 'BIT_SIZE(I)', otherwise the result value is
     undefined.  Bits shifted out from the left end are lost; zeros are
     shifted in from the opposite end.

     This function has been superseded by the 'ISHFT' intrinsic, which
     is standard in Fortran 95 and later, and the 'SHIFTL' intrinsic,
     which is standard in Fortran 2008 and later.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     'RESULT = LSHIFT(I, SHIFT)'

_Arguments_:
     I           The type shall be 'INTEGER'.
     SHIFT       The type shall be 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER' and of the same kind as I.

_See also_:
     *note ISHFT::, *note ISHFTC::, *note RSHIFT::, *note SHIFTA::,
     *note SHIFTL::, *note SHIFTR::


File: gfortran.info,  Node: LSTAT,  Next: LTIME,  Prev: LSHIFT,  Up: Intrinsic Procedures

9.183 'LSTAT' -- Get file status
================================

_Description_:
     'LSTAT' is identical to *note STAT::, except that if path is a
     symbolic link, then the link itself is statted, not the file that
     it refers to.

     The elements in 'VALUES' are the same as described by *note STAT::.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL LSTAT(NAME, VALUES [, STATUS])'
     'STATUS = LSTAT(NAME, VALUES)'

_Arguments_:
     NAME        The type shall be 'CHARACTER' of the default
                 kind, a valid path within the file system.
     VALUES      The type shall be 'INTEGER(4), DIMENSION(13)'.
     STATUS      (Optional) status flag of type 'INTEGER(4)'.
                 Returns 0 on success and a system specific error
                 code otherwise.

_Example_:
     See *note STAT:: for an example.

_See also_:
     To stat an open file: *note FSTAT::, to stat a file: *note STAT::


File: gfortran.info,  Node: LTIME,  Next: MALLOC,  Prev: LSTAT,  Up: Intrinsic Procedures

9.184 'LTIME' -- Convert time to local time info
================================================

_Description_:
     Given a system time value TIME (as provided by the *note TIME::
     intrinsic), fills VALUES with values extracted from it appropriate
     to the local time zone using 'localtime(3)'.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  In new code, programmers should consider the use
     of the *note DATE_AND_TIME:: intrinsic defined by the Fortran 95
     standard.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL LTIME(TIME, VALUES)'

_Arguments_:
     TIME        An 'INTEGER' scalar expression corresponding to
                 a system time, with 'INTENT(IN)'.
     VALUES      A default 'INTEGER' array with 9 elements, with
                 'INTENT(OUT)'.

_Return value_:
     The elements of VALUES are assigned as follows:
       1. Seconds after the minute, range 0-59 or 0-61 to allow for leap
          seconds
       2. Minutes after the hour, range 0-59
       3. Hours past midnight, range 0-23
       4. Day of month, range 1-31
       5. Number of months since January, range 0-11
       6. Years since 1900
       7. Number of days since Sunday, range 0-6
       8. Days since January 1, range 0-365
       9. Daylight savings indicator: positive if daylight savings is in
          effect, zero if not, and negative if the information is not
          available.

_See also_:
     *note DATE_AND_TIME::, *note CTIME::, *note GMTIME::, *note TIME::,
     *note TIME8::


File: gfortran.info,  Node: MALLOC,  Next: MASKL,  Prev: LTIME,  Up: Intrinsic Procedures

9.185 'MALLOC' -- Allocate dynamic memory
=========================================

_Description_:
     'MALLOC(SIZE)' allocates SIZE bytes of dynamic memory and returns
     the address of the allocated memory.  The 'MALLOC' intrinsic is an
     extension intended to be used with Cray pointers, and is provided
     in GNU Fortran to allow the user to compile legacy code.  For new
     code using Fortran 95 pointers, the memory allocation intrinsic is
     'ALLOCATE'.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'PTR = MALLOC(SIZE)'

_Arguments_:
     SIZE        The type shall be 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER(K)', with K such that
     variables of type 'INTEGER(K)' have the same size as C pointers
     ('sizeof(void *)').

_Example_:
     The following example demonstrates the use of 'MALLOC' and 'FREE'
     with Cray pointers.

          program test_malloc
            implicit none
            integer i
            real*8 x(*), z
            pointer(ptr_x,x)

            ptr_x = malloc(20*8)
            do i = 1, 20
              x(i) = sqrt(1.0d0 / i)
            end do
            z = 0
            do i = 1, 20
              z = z + x(i)
              print *, z
            end do
            call free(ptr_x)
          end program test_malloc

_See also_:
     *note FREE::


File: gfortran.info,  Node: MASKL,  Next: MASKR,  Prev: MALLOC,  Up: Intrinsic Procedures

9.186 'MASKL' -- Left justified mask
====================================

_Description_:
     'MASKL(I[, KIND])' has its leftmost I bits set to 1, and the
     remaining bits set to 0.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = MASKL(I[, KIND])'

_Arguments_:
     I           Shall be of type 'INTEGER'.
     KIND        Shall be a scalar constant expression of type
                 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER'.  If KIND is present, it
     specifies the kind value of the return type; otherwise, it is of
     the default integer kind.

_See also_:
     *note MASKR::


File: gfortran.info,  Node: MASKR,  Next: MATMUL,  Prev: MASKL,  Up: Intrinsic Procedures

9.187 'MASKR' -- Right justified mask
=====================================

_Description_:
     'MASKL(I[, KIND])' has its rightmost I bits set to 1, and the
     remaining bits set to 0.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = MASKR(I[, KIND])'

_Arguments_:
     I           Shall be of type 'INTEGER'.
     KIND        Shall be a scalar constant expression of type
                 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER'.  If KIND is present, it
     specifies the kind value of the return type; otherwise, it is of
     the default integer kind.

_See also_:
     *note MASKL::


File: gfortran.info,  Node: MATMUL,  Next: MAX,  Prev: MASKR,  Up: Intrinsic Procedures

9.188 'MATMUL' -- matrix multiplication
=======================================

_Description_:
     Performs a matrix multiplication on numeric or logical arguments.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = MATMUL(MATRIX_A, MATRIX_B)'

_Arguments_:
     MATRIX_A    An array of 'INTEGER', 'REAL', 'COMPLEX', or
                 'LOGICAL' type, with a rank of one or two.
     MATRIX_B    An array of 'INTEGER', 'REAL', or 'COMPLEX' type
                 if MATRIX_A is of a numeric type; otherwise, an
                 array of 'LOGICAL' type.  The rank shall be one
                 or two, and the first (or only) dimension of
                 MATRIX_B shall be equal to the last (or only)
                 dimension of MATRIX_A.  MATRIX_A and MATRIX_B
                 shall not both be rank one arrays.

_Return value_:
     The matrix product of MATRIX_A and MATRIX_B.  The type and kind of
     the result follow the usual type and kind promotion rules, as for
     the '*' or '.AND.' operators.

_See also_:


File: gfortran.info,  Node: MAX,  Next: MAXEXPONENT,  Prev: MATMUL,  Up: Intrinsic Procedures

9.189 'MAX' -- Maximum value of an argument list
================================================

_Description_:
     Returns the argument with the largest (most positive) value.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = MAX(A1, A2 [, A3 [, ...]])'

_Arguments_:
     A1          The type shall be 'INTEGER' or 'REAL'.
     A2, A3,     An expression of the same type and kind as A1.
     ...         (As a GNU extension, arguments of different
                 kinds are permitted.)

_Return value_:
     The return value corresponds to the maximum value among the
     arguments, and has the same type and kind as the first argument.

_Specific names_:
     Name           Argument       Return type    Standard
     'MAX0(A1)'     'INTEGER(4)    'INTEGER(4)'   Fortran 77 and
                    A1'                           later
     'AMAX0(A1)'    'INTEGER(4)    'REAL(MAX(X))' Fortran 77 and
                    A1'                           later
     'MAX1(A1)'     'REAL A1'      'INT(MAX(X))'  Fortran 77 and
                                                  later
     'AMAX1(A1)'    'REAL(4) A1'   'REAL(4)'      Fortran 77 and
                                                  later
     'DMAX1(A1)'    'REAL(8) A1'   'REAL(8)'      Fortran 77 and
                                                  later

_See also_:
     *note MAXLOC:: *note MAXVAL::, *note MIN::


File: gfortran.info,  Node: MAXEXPONENT,  Next: MAXLOC,  Prev: MAX,  Up: Intrinsic Procedures

9.190 'MAXEXPONENT' -- Maximum exponent of a real kind
======================================================

_Description_:
     'MAXEXPONENT(X)' returns the maximum exponent in the model of the
     type of 'X'.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = MAXEXPONENT(X)'

_Arguments_:
     X           Shall be of type 'REAL'.

_Return value_:
     The return value is of type 'INTEGER' and of the default integer
     kind.

_Example_:
          program exponents
            real(kind=4) :: x
            real(kind=8) :: y

            print *, minexponent(x), maxexponent(x)
            print *, minexponent(y), maxexponent(y)
          end program exponents


File: gfortran.info,  Node: MAXLOC,  Next: MAXVAL,  Prev: MAXEXPONENT,  Up: Intrinsic Procedures

9.191 'MAXLOC' -- Location of the maximum value within an array
===============================================================

_Description_:
     Determines the location of the element in the array with the
     maximum value, or, if the DIM argument is supplied, determines the
     locations of the maximum element along each row of the array in the
     DIM direction.  If MASK is present, only the elements for which
     MASK is '.TRUE.' are considered.  If more than one element in the
     array has the maximum value, the location returned is that of the
     first such element in array element order if the BACK is not
     present, or is false; if BACK is true, the location returned is
     that of the last such element.  If the array has zero size, or all
     of the elements of MASK are '.FALSE.', then the result is an array
     of zeroes.  Similarly, if DIM is supplied and all of the elements
     of MASK along a given row are zero, the result value for that row
     is zero.

_Standard_:
     Fortran 95 and later; ARRAY of 'CHARACTER' and the KIND argument
     are available in Fortran 2003 and later.  The BACK argument is
     available in Fortran 2008 and later.

_Class_:
     Transformational function

_Syntax_:
     'RESULT = MAXLOC(ARRAY, DIM [, MASK] [,KIND] [,BACK])'
     'RESULT = MAXLOC(ARRAY [, MASK] [,KIND] [,BACK])'

_Arguments_:
     ARRAY       Shall be an array of type 'INTEGER' or 'REAL'.
     DIM         (Optional) Shall be a scalar of type 'INTEGER',
                 with a value between one and the rank of ARRAY,
                 inclusive.  It may not be an optional dummy
                 argument.
     MASK        Shall be an array of type 'LOGICAL', and
                 conformable with ARRAY.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.
     BACK        (Optional) A scalar of type 'LOGICAL'.

_Return value_:
     If DIM is absent, the result is a rank-one array with a length
     equal to the rank of ARRAY.  If DIM is present, the result is an
     array with a rank one less than the rank of ARRAY, and a size
     corresponding to the size of ARRAY with the DIM dimension removed.
     If DIM is present and ARRAY has a rank of one, the result is a
     scalar.  If the optional argument KIND is present, the result is an
     integer of kind KIND, otherwise it is of default kind.

_See also_:
     *note FINDLOC::, *note MAX::, *note MAXVAL::


File: gfortran.info,  Node: MAXVAL,  Next: MCLOCK,  Prev: MAXLOC,  Up: Intrinsic Procedures

9.192 'MAXVAL' -- Maximum value of an array
===========================================

_Description_:
     Determines the maximum value of the elements in an array value, or,
     if the DIM argument is supplied, determines the maximum value along
     each row of the array in the DIM direction.  If MASK is present,
     only the elements for which MASK is '.TRUE.' are considered.  If
     the array has zero size, or all of the elements of MASK are
     '.FALSE.', then the result is '-HUGE(ARRAY)' if ARRAY is numeric,
     or a string of nulls if ARRAY is of character type.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = MAXVAL(ARRAY, DIM [, MASK])'
     'RESULT = MAXVAL(ARRAY [, MASK])'

_Arguments_:
     ARRAY       Shall be an array of type 'INTEGER' or 'REAL'.
     DIM         (Optional) Shall be a scalar of type 'INTEGER',
                 with a value between one and the rank of ARRAY,
                 inclusive.  It may not be an optional dummy
                 argument.
     MASK        Shall be an array of type 'LOGICAL', and
                 conformable with ARRAY.

_Return value_:
     If DIM is absent, or if ARRAY has a rank of one, the result is a
     scalar.  If DIM is present, the result is an array with a rank one
     less than the rank of ARRAY, and a size corresponding to the size
     of ARRAY with the DIM dimension removed.  In all cases, the result
     is of the same type and kind as ARRAY.

_See also_:
     *note MAX::, *note MAXLOC::


File: gfortran.info,  Node: MCLOCK,  Next: MCLOCK8,  Prev: MAXVAL,  Up: Intrinsic Procedures

9.193 'MCLOCK' -- Time function
===============================

_Description_:
     Returns the number of clock ticks since the start of the process,
     based on the function 'clock(3)' in the C standard library.

     This intrinsic is not fully portable, such as to systems with
     32-bit 'INTEGER' types but supporting times wider than 32 bits.
     Therefore, the values returned by this intrinsic might be, or
     become, negative, or numerically less than previous values, during
     a single run of the compiled program.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = MCLOCK()'

_Return value_:
     The return value is a scalar of type 'INTEGER(4)', equal to the
     number of clock ticks since the start of the process, or '-1' if
     the system does not support 'clock(3)'.

_See also_:
     *note CTIME::, *note GMTIME::, *note LTIME::, *note MCLOCK::, *note
     TIME::


File: gfortran.info,  Node: MCLOCK8,  Next: MERGE,  Prev: MCLOCK,  Up: Intrinsic Procedures

9.194 'MCLOCK8' -- Time function (64-bit)
=========================================

_Description_:
     Returns the number of clock ticks since the start of the process,
     based on the function 'clock(3)' in the C standard library.

     _Warning:_ this intrinsic does not increase the range of the timing
     values over that returned by 'clock(3)'.  On a system with a 32-bit
     'clock(3)', 'MCLOCK8' will return a 32-bit value, even though it is
     converted to a 64-bit 'INTEGER(8)' value.  That means overflows of
     the 32-bit value can still occur.  Therefore, the values returned
     by this intrinsic might be or become negative or numerically less
     than previous values during a single run of the compiled program.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = MCLOCK8()'

_Return value_:
     The return value is a scalar of type 'INTEGER(8)', equal to the
     number of clock ticks since the start of the process, or '-1' if
     the system does not support 'clock(3)'.

_See also_:
     *note CTIME::, *note GMTIME::, *note LTIME::, *note MCLOCK::, *note
     TIME8::


File: gfortran.info,  Node: MERGE,  Next: MERGE_BITS,  Prev: MCLOCK8,  Up: Intrinsic Procedures

9.195 'MERGE' -- Merge variables
================================

_Description_:
     Select values from two arrays according to a logical mask.  The
     result is equal to TSOURCE if MASK is '.TRUE.', or equal to FSOURCE
     if it is '.FALSE.'.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = MERGE(TSOURCE, FSOURCE, MASK)'

_Arguments_:
     TSOURCE     May be of any type.
     FSOURCE     Shall be of the same type and type parameters as
                 TSOURCE.
     MASK        Shall be of type 'LOGICAL'.

_Return value_:
     The result is of the same type and type parameters as TSOURCE.


File: gfortran.info,  Node: MERGE_BITS,  Next: MIN,  Prev: MERGE,  Up: Intrinsic Procedures

9.196 'MERGE_BITS' -- Merge of bits under mask
==============================================

_Description_:
     'MERGE_BITS(I, J, MASK)' merges the bits of I and J as determined
     by the mask.  The i-th bit of the result is equal to the i-th bit
     of I if the i-th bit of MASK is 1; it is equal to the i-th bit of J
     otherwise.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = MERGE_BITS(I, J, MASK)'

_Arguments_:
     I           Shall be of type 'INTEGER' or a
                 boz-literal-constant.
     J           Shall be of type 'INTEGER' with the same kind
                 type parameter as I or a boz-literal-constant.
                 I and J shall not both be boz-literal-constants.
     MASK        Shall be of type 'INTEGER' or a
                 boz-literal-constant and of the same kind as I.

_Return value_:
     The result is of the same type and kind as I.


File: gfortran.info,  Node: MIN,  Next: MINEXPONENT,  Prev: MERGE_BITS,  Up: Intrinsic Procedures

9.197 'MIN' -- Minimum value of an argument list
================================================

_Description_:
     Returns the argument with the smallest (most negative) value.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = MIN(A1, A2 [, A3, ...])'

_Arguments_:
     A1          The type shall be 'INTEGER' or 'REAL'.
     A2, A3,     An expression of the same type and kind as A1.
     ...         (As a GNU extension, arguments of different
                 kinds are permitted.)

_Return value_:
     The return value corresponds to the maximum value among the
     arguments, and has the same type and kind as the first argument.

_Specific names_:
     Name           Argument       Return type    Standard
     'MIN0(A1)'     'INTEGER(4)    'INTEGER(4)'   Fortran 77 and
                    A1'                           later
     'AMIN0(A1)'    'INTEGER(4)    'REAL(4)'      Fortran 77 and
                    A1'                           later
     'MIN1(A1)'     'REAL A1'      'INTEGER(4)'   Fortran 77 and
                                                  later
     'AMIN1(A1)'    'REAL(4) A1'   'REAL(4)'      Fortran 77 and
                                                  later
     'DMIN1(A1)'    'REAL(8) A1'   'REAL(8)'      Fortran 77 and
                                                  later

_See also_:
     *note MAX::, *note MINLOC::, *note MINVAL::


File: gfortran.info,  Node: MINEXPONENT,  Next: MINLOC,  Prev: MIN,  Up: Intrinsic Procedures

9.198 'MINEXPONENT' -- Minimum exponent of a real kind
======================================================

_Description_:
     'MINEXPONENT(X)' returns the minimum exponent in the model of the
     type of 'X'.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = MINEXPONENT(X)'

_Arguments_:
     X           Shall be of type 'REAL'.

_Return value_:
     The return value is of type 'INTEGER' and of the default integer
     kind.

_Example_:
     See 'MAXEXPONENT' for an example.


File: gfortran.info,  Node: MINLOC,  Next: MINVAL,  Prev: MINEXPONENT,  Up: Intrinsic Procedures

9.199 'MINLOC' -- Location of the minimum value within an array
===============================================================

_Description_:
     Determines the location of the element in the array with the
     minimum value, or, if the DIM argument is supplied, determines the
     locations of the minimum element along each row of the array in the
     DIM direction.  If MASK is present, only the elements for which
     MASK is '.TRUE.' are considered.  If more than one element in the
     array has the minimum value, the location returned is that of the
     first such element in array element order if the BACK is not
     present, or is false; if BACK is true, the location returned is
     that of the last such element.  If the array has zero size, or all
     of the elements of MASK are '.FALSE.', then the result is an array
     of zeroes.  Similarly, if DIM is supplied and all of the elements
     of MASK along a given row are zero, the result value for that row
     is zero.

_Standard_:
     Fortran 95 and later; ARRAY of 'CHARACTER' and the KIND argument
     are available in Fortran 2003 and later.  The BACK argument is
     available in Fortran 2008 and later.

_Class_:
     Transformational function

_Syntax_:
     'RESULT = MINLOC(ARRAY, DIM [, MASK] [,KIND] [,BACK])'
     'RESULT = MINLOC(ARRAY [, MASK], [,KIND] [,BACK])'

_Arguments_:
     ARRAY       Shall be an array of type 'INTEGER', 'REAL' or
                 'CHARACTER'.
     DIM         (Optional) Shall be a scalar of type 'INTEGER',
                 with a value between one and the rank of ARRAY,
                 inclusive.  It may not be an optional dummy
                 argument.
     MASK        Shall be an array of type 'LOGICAL', and
                 conformable with ARRAY.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.
     BACK        (Optional) A scalar of type 'LOGICAL'.

_Return value_:
     If DIM is absent, the result is a rank-one array with a length
     equal to the rank of ARRAY.  If DIM is present, the result is an
     array with a rank one less than the rank of ARRAY, and a size
     corresponding to the size of ARRAY with the DIM dimension removed.
     If DIM is present and ARRAY has a rank of one, the result is a
     scalar.  If the optional argument KIND is present, the result is an
     integer of kind KIND, otherwise it is of default kind.

_See also_:
     *note FINDLOC::, *note MIN::, *note MINVAL::


File: gfortran.info,  Node: MINVAL,  Next: MOD,  Prev: MINLOC,  Up: Intrinsic Procedures

9.200 'MINVAL' -- Minimum value of an array
===========================================

_Description_:
     Determines the minimum value of the elements in an array value, or,
     if the DIM argument is supplied, determines the minimum value along
     each row of the array in the DIM direction.  If MASK is present,
     only the elements for which MASK is '.TRUE.' are considered.  If
     the array has zero size, or all of the elements of MASK are
     '.FALSE.', then the result is 'HUGE(ARRAY)' if ARRAY is numeric, or
     a string of 'CHAR(255)' characters if ARRAY is of character type.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = MINVAL(ARRAY, DIM [, MASK])'
     'RESULT = MINVAL(ARRAY [, MASK])'

_Arguments_:
     ARRAY       Shall be an array of type 'INTEGER' or 'REAL'.
     DIM         (Optional) Shall be a scalar of type 'INTEGER',
                 with a value between one and the rank of ARRAY,
                 inclusive.  It may not be an optional dummy
                 argument.
     MASK        Shall be an array of type 'LOGICAL', and
                 conformable with ARRAY.

_Return value_:
     If DIM is absent, or if ARRAY has a rank of one, the result is a
     scalar.  If DIM is present, the result is an array with a rank one
     less than the rank of ARRAY, and a size corresponding to the size
     of ARRAY with the DIM dimension removed.  In all cases, the result
     is of the same type and kind as ARRAY.

_See also_:
     *note MIN::, *note MINLOC::


File: gfortran.info,  Node: MOD,  Next: MODULO,  Prev: MINVAL,  Up: Intrinsic Procedures

9.201 'MOD' -- Remainder function
=================================

_Description_:
     'MOD(A,P)' computes the remainder of the division of A by P.

_Standard_:
     Fortran 77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = MOD(A, P)'

_Arguments_:
     A           Shall be a scalar of type 'INTEGER' or 'REAL'.
     P           Shall be a scalar of the same type and kind as A
                 and not equal to zero.

_Return value_:
     The return value is the result of 'A - (INT(A/P) * P)'.  The type
     and kind of the return value is the same as that of the arguments.
     The returned value has the same sign as A and a magnitude less than
     the magnitude of P.

_Example_:
          program test_mod
            print *, mod(17,3)
            print *, mod(17.5,5.5)
            print *, mod(17.5d0,5.5)
            print *, mod(17.5,5.5d0)

            print *, mod(-17,3)
            print *, mod(-17.5,5.5)
            print *, mod(-17.5d0,5.5)
            print *, mod(-17.5,5.5d0)

            print *, mod(17,-3)
            print *, mod(17.5,-5.5)
            print *, mod(17.5d0,-5.5)
            print *, mod(17.5,-5.5d0)
          end program test_mod

_Specific names_:
     Name           Arguments      Return type    Standard
     'MOD(A,P)'     'INTEGER       'INTEGER'      Fortran 95 and
                    A,P'                          later
     'AMOD(A,P)'    'REAL(4)       'REAL(4)'      Fortran 95 and
                    A,P'                          later
     'DMOD(A,P)'    'REAL(8)       'REAL(8)'      Fortran 95 and
                    A,P'                          later
     'BMOD(A,P)'    'INTEGER(1)    'INTEGER(1)'   GNU extension
                    A,P'
     'IMOD(A,P)'    'INTEGER(2)    'INTEGER(2)'   GNU extension
                    A,P'
     'JMOD(A,P)'    'INTEGER(4)    'INTEGER(4)'   GNU extension
                    A,P'
     'KMOD(A,P)'    'INTEGER(8)    'INTEGER(8)'   GNU extension
                    A,P'

_See also_:
     *note MODULO::


File: gfortran.info,  Node: MODULO,  Next: MOVE_ALLOC,  Prev: MOD,  Up: Intrinsic Procedures

9.202 'MODULO' -- Modulo function
=================================

_Description_:
     'MODULO(A,P)' computes the A modulo P.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = MODULO(A, P)'

_Arguments_:
     A           Shall be a scalar of type 'INTEGER' or 'REAL'.
     P           Shall be a scalar of the same type and kind as
                 A.  It shall not be zero.

_Return value_:
     The type and kind of the result are those of the arguments.
     If A and P are of type 'INTEGER':
          'MODULO(A,P)' has the value R such that 'A=Q*P+R', where Q is
          an integer and R is between 0 (inclusive) and P (exclusive).
     If A and P are of type 'REAL':
          'MODULO(A,P)' has the value of 'A - FLOOR (A / P) * P'.
     The returned value has the same sign as P and a magnitude less than
     the magnitude of P.

_Example_:
          program test_modulo
            print *, modulo(17,3)
            print *, modulo(17.5,5.5)

            print *, modulo(-17,3)
            print *, modulo(-17.5,5.5)

            print *, modulo(17,-3)
            print *, modulo(17.5,-5.5)
          end program

_See also_:
     *note MOD::


File: gfortran.info,  Node: MOVE_ALLOC,  Next: MVBITS,  Prev: MODULO,  Up: Intrinsic Procedures

9.203 'MOVE_ALLOC' -- Move allocation from one object to another
================================================================

_Description_:
     'MOVE_ALLOC(FROM, TO)' moves the allocation from FROM to TO.  FROM
     will become deallocated in the process.

_Standard_:
     Fortran 2003 and later

_Class_:
     Pure subroutine

_Syntax_:
     'CALL MOVE_ALLOC(FROM, TO)'

_Arguments_:
     FROM        'ALLOCATABLE', 'INTENT(INOUT)', may be of any
                 type and kind.
     TO          'ALLOCATABLE', 'INTENT(OUT)', shall be of the
                 same type, kind and rank as FROM.

_Return value_:
     None

_Example_:
          program test_move_alloc
              integer, allocatable :: a(:), b(:)

              allocate(a(3))
              a = [ 1, 2, 3 ]
              call move_alloc(a, b)
              print *, allocated(a), allocated(b)
              print *, b
          end program test_move_alloc


File: gfortran.info,  Node: MVBITS,  Next: NEAREST,  Prev: MOVE_ALLOC,  Up: Intrinsic Procedures

9.204 'MVBITS' -- Move bits from one integer to another
=======================================================

_Description_:
     Moves LEN bits from positions FROMPOS through 'FROMPOS+LEN-1' of
     FROM to positions TOPOS through 'TOPOS+LEN-1' of TO.  The portion
     of argument TO not affected by the movement of bits is unchanged.
     The values of 'FROMPOS+LEN-1' and 'TOPOS+LEN-1' must be less than
     'BIT_SIZE(FROM)'.

_Standard_:
     Fortran 95 and later, has overloads that are GNU extensions

_Class_:
     Elemental subroutine

_Syntax_:
     'CALL MVBITS(FROM, FROMPOS, LEN, TO, TOPOS)'

_Arguments_:
     FROM        The type shall be 'INTEGER'.
     FROMPOS     The type shall be 'INTEGER'.
     LEN         The type shall be 'INTEGER'.
     TO          The type shall be 'INTEGER', of the same kind as
                 FROM.
     TOPOS       The type shall be 'INTEGER'.

_Specific names_:
     Name           Argument       Return type    Standard
     'MVBITS(A)'    'INTEGER A'    'INTEGER'      Fortran 95 and
                                                  later
     'BMVBITS(A)'   'INTEGER(1)    'INTEGER(1)'   GNU extension
                    A'
     'IMVBITS(A)'   'INTEGER(2)    'INTEGER(2)'   GNU extension
                    A'
     'JMVBITS(A)'   'INTEGER(4)    'INTEGER(4)'   GNU extension
                    A'
     'KMVBITS(A)'   'INTEGER(8)    'INTEGER(8)'   GNU extension
                    A'

_See also_:
     *note IBCLR::, *note IBSET::, *note IBITS::, *note IAND::, *note
     IOR::, *note IEOR::


File: gfortran.info,  Node: NEAREST,  Next: NEW_LINE,  Prev: MVBITS,  Up: Intrinsic Procedures

9.205 'NEAREST' -- Nearest representable number
===============================================

_Description_:
     'NEAREST(X, S)' returns the processor-representable number nearest
     to 'X' in the direction indicated by the sign of 'S'.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = NEAREST(X, S)'

_Arguments_:
     X           Shall be of type 'REAL'.
     S           Shall be of type 'REAL' and not equal to zero.

_Return value_:
     The return value is of the same type as 'X'.  If 'S' is positive,
     'NEAREST' returns the processor-representable number greater than
     'X' and nearest to it.  If 'S' is negative, 'NEAREST' returns the
     processor-representable number smaller than 'X' and nearest to it.

_Example_:
          program test_nearest
            real :: x, y
            x = nearest(42.0, 1.0)
            y = nearest(42.0, -1.0)
            write (*,"(3(G20.15))") x, y, x - y
          end program test_nearest


File: gfortran.info,  Node: NEW_LINE,  Next: NINT,  Prev: NEAREST,  Up: Intrinsic Procedures

9.206 'NEW_LINE' -- New line character
======================================

_Description_:
     'NEW_LINE(C)' returns the new-line character.

_Standard_:
     Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = NEW_LINE(C)'

_Arguments_:
     C           The argument shall be a scalar or array of the
                 type 'CHARACTER'.

_Return value_:
     Returns a CHARACTER scalar of length one with the new-line
     character of the same kind as parameter C.

_Example_:
          program newline
            implicit none
            write(*,'(A)') 'This is record 1.'//NEW_LINE('A')//'This is record 2.'
          end program newline


File: gfortran.info,  Node: NINT,  Next: NORM2,  Prev: NEW_LINE,  Up: Intrinsic Procedures

9.207 'NINT' -- Nearest whole number
====================================

_Description_:
     'NINT(A)' rounds its argument to the nearest whole number.

_Standard_:
     Fortran 77 and later, with KIND argument Fortran 90 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = NINT(A [, KIND])'

_Arguments_:
     A           The type of the argument shall be 'REAL'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     Returns A with the fractional portion of its magnitude eliminated
     by rounding to the nearest whole number and with its sign
     preserved, converted to an 'INTEGER' of the default kind.

_Example_:
          program test_nint
            real(4) x4
            real(8) x8
            x4 = 1.234E0_4
            x8 = 4.321_8
            print *, nint(x4), idnint(x8)
          end program test_nint

_Specific names_:
     Name           Argument       Return Type    Standard
     'NINT(A)'      'REAL(4) A'    'INTEGER'      Fortran 95 and
                                                  later
     'IDNINT(A)'    'REAL(8) A'    'INTEGER'      Fortran 95 and
                                                  later

_See also_:
     *note CEILING::, *note FLOOR::


File: gfortran.info,  Node: NORM2,  Next: NOT,  Prev: NINT,  Up: Intrinsic Procedures

9.208 'NORM2' -- Euclidean vector norms
=======================================

_Description_:
     Calculates the Euclidean vector norm (L_2 norm) of of ARRAY along
     dimension DIM.

_Standard_:
     Fortran 2008 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = NORM2(ARRAY[, DIM])'

_Arguments_:
     ARRAY       Shall be an array of type 'REAL'
     DIM         (Optional) shall be a scalar of type 'INTEGER'
                 with a value in the range from 1 to n, where n
                 equals the rank of ARRAY.

_Return value_:
     The result is of the same type as ARRAY.

     If DIM is absent, a scalar with the square root of the sum of all
     elements in ARRAY squared is returned.  Otherwise, an array of rank
     n-1, where n equals the rank of ARRAY, and a shape similar to that
     of ARRAY with dimension DIM dropped is returned.

_Example_:
          PROGRAM test_sum
            REAL :: x(5) = [ real :: 1, 2, 3, 4, 5 ]
            print *, NORM2(x)  ! = sqrt(55.) ~ 7.416
          END PROGRAM


File: gfortran.info,  Node: NOT,  Next: NULL,  Prev: NORM2,  Up: Intrinsic Procedures

9.209 'NOT' -- Logical negation
===============================

_Description_:
     'NOT' returns the bitwise Boolean inverse of I.

_Standard_:
     Fortran 95 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     'RESULT = NOT(I)'

_Arguments_:
     I           The type shall be 'INTEGER'.

_Return value_:
     The return type is 'INTEGER', of the same kind as the argument.

_Specific names_:
     Name           Argument       Return type    Standard
     'NOT(A)'       'INTEGER A'    'INTEGER'      Fortran 95 and
                                                  later
     'BNOT(A)'      'INTEGER(1)    'INTEGER(1)'   GNU extension
                    A'
     'INOT(A)'      'INTEGER(2)    'INTEGER(2)'   GNU extension
                    A'
     'JNOT(A)'      'INTEGER(4)    'INTEGER(4)'   GNU extension
                    A'
     'KNOT(A)'      'INTEGER(8)    'INTEGER(8)'   GNU extension
                    A'

_See also_:
     *note IAND::, *note IEOR::, *note IOR::, *note IBITS::, *note
     IBSET::, *note IBCLR::


File: gfortran.info,  Node: NULL,  Next: NUM_IMAGES,  Prev: NOT,  Up: Intrinsic Procedures

9.210 'NULL' -- Function that returns an disassociated pointer
==============================================================

_Description_:
     Returns a disassociated pointer.

     If MOLD is present, a disassociated pointer of the same type is
     returned, otherwise the type is determined by context.

     In Fortran 95, MOLD is optional.  Please note that Fortran 2003
     includes cases where it is required.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'PTR => NULL([MOLD])'

_Arguments_:
     MOLD        (Optional) shall be a pointer of any association
                 status and of any type.

_Return value_:
     A disassociated pointer.

_Example_:
          REAL, POINTER, DIMENSION(:) :: VEC => NULL ()

_See also_:
     *note ASSOCIATED::


File: gfortran.info,  Node: NUM_IMAGES,  Next: OR,  Prev: NULL,  Up: Intrinsic Procedures

9.211 'NUM_IMAGES' -- Function that returns the number of images
================================================================

_Description_:
     Returns the number of images.

_Standard_:
     Fortran 2008 and later.  With DISTANCE or FAILED argument,
     Technical Specification (TS) 18508 or later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = NUM_IMAGES(DISTANCE, FAILED)'

_Arguments_:
     DISTANCE    (optional, intent(in)) Nonnegative scalar
                 integer
     FAILED      (optional, intent(in)) Scalar logical expression

_Return value_:
     Scalar default-kind integer.  If DISTANCE is not present or has
     value 0, the number of images in the current team is returned.  For
     values smaller or equal distance to the initial team, it returns
     the number of images index on the ancestor team which has a
     distance of DISTANCE from the invoking team.  If DISTANCE is larger
     than the distance to the initial team, the number of images of the
     initial team is returned.  If FAILED is not present the total
     number of images is returned; if it has the value '.TRUE.', the
     number of failed images is returned, otherwise, the number of
     images which do have not the failed status.

_Example_:
          INTEGER :: value[*]
          INTEGER :: i
          value = THIS_IMAGE()
          SYNC ALL
          IF (THIS_IMAGE() == 1) THEN
            DO i = 1, NUM_IMAGES()
              WRITE(*,'(2(a,i0))') 'value[', i, '] is ', value[i]
            END DO
          END IF

_See also_:
     *note THIS_IMAGE::, *note IMAGE_INDEX::


File: gfortran.info,  Node: OR,  Next: PACK,  Prev: NUM_IMAGES,  Up: Intrinsic Procedures

9.212 'OR' -- Bitwise logical OR
================================

_Description_:
     Bitwise logical 'OR'.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  For integer arguments, programmers should consider
     the use of the *note IOR:: intrinsic defined by the Fortran
     standard.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = OR(I, J)'

_Arguments_:
     I           The type shall be either a scalar 'INTEGER' type
                 or a scalar 'LOGICAL' type or a
                 boz-literal-constant.
     J           The type shall be the same as the type of I or a
                 boz-literal-constant.  I and J shall not both be
                 boz-literal-constants.  If either I and J is a
                 boz-literal-constant, then the other argument
                 must be a scalar 'INTEGER'.

_Return value_:
     The return type is either a scalar 'INTEGER' or a scalar 'LOGICAL'.
     If the kind type parameters differ, then the smaller kind type is
     implicitly converted to larger kind, and the return has the larger
     kind.  A boz-literal-constant is converted to an 'INTEGER' with the
     kind type parameter of the other argument as-if a call to *note
     INT:: occurred.

_Example_:
          PROGRAM test_or
            LOGICAL :: T = .TRUE., F = .FALSE.
            INTEGER :: a, b
            DATA a / Z'F' /, b / Z'3' /

            WRITE (*,*) OR(T, T), OR(T, F), OR(F, T), OR(F, F)
            WRITE (*,*) OR(a, b)
          END PROGRAM

_See also_:
     Fortran 95 elemental function: *note IOR::


File: gfortran.info,  Node: PACK,  Next: PARITY,  Prev: OR,  Up: Intrinsic Procedures

9.213 'PACK' -- Pack an array into an array of rank one
=======================================================

_Description_:
     Stores the elements of ARRAY in an array of rank one.

     The beginning of the resulting array is made up of elements whose
     MASK equals 'TRUE'.  Afterwards, positions are filled with elements
     taken from VECTOR.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = PACK(ARRAY, MASK[,VECTOR])'

_Arguments_:
     ARRAY       Shall be an array of any type.
     MASK        Shall be an array of type 'LOGICAL' and of the
                 same size as ARRAY.  Alternatively, it may be a
                 'LOGICAL' scalar.
     VECTOR      (Optional) shall be an array of the same type as
                 ARRAY and of rank one.  If present, the number
                 of elements in VECTOR shall be equal to or
                 greater than the number of true elements in
                 MASK.  If MASK is scalar, the number of elements
                 in VECTOR shall be equal to or greater than the
                 number of elements in ARRAY.

_Return value_:
     The result is an array of rank one and the same type as that of
     ARRAY.  If VECTOR is present, the result size is that of VECTOR,
     the number of 'TRUE' values in MASK otherwise.

_Example_:
     Gathering nonzero elements from an array:
          PROGRAM test_pack_1
            INTEGER :: m(6)
            m = (/ 1, 0, 0, 0, 5, 0 /)
            WRITE(*, FMT="(6(I0, ' '))") pack(m, m /= 0)  ! "1 5"
          END PROGRAM

     Gathering nonzero elements from an array and appending elements
     from VECTOR:
          PROGRAM test_pack_2
            INTEGER :: m(4)
            m = (/ 1, 0, 0, 2 /)
            WRITE(*, FMT="(4(I0, ' '))") pack(m, m /= 0, (/ 0, 0, 3, 4 /))  ! "1 2 3 4"
          END PROGRAM

_See also_:
     *note UNPACK::


File: gfortran.info,  Node: PARITY,  Next: PERROR,  Prev: PACK,  Up: Intrinsic Procedures

9.214 'PARITY' -- Reduction with exclusive OR
=============================================

_Description_:
     Calculates the parity, i.e.  the reduction using '.XOR.', of MASK
     along dimension DIM.

_Standard_:
     Fortran 2008 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = PARITY(MASK[, DIM])'

_Arguments_:
     LOGICAL     Shall be an array of type 'LOGICAL'
     DIM         (Optional) shall be a scalar of type 'INTEGER'
                 with a value in the range from 1 to n, where n
                 equals the rank of MASK.

_Return value_:
     The result is of the same type as MASK.

     If DIM is absent, a scalar with the parity of all elements in MASK
     is returned, i.e.  true if an odd number of elements is '.true.'
     and false otherwise.  If DIM is present, an array of rank n-1,
     where n equals the rank of ARRAY, and a shape similar to that of
     MASK with dimension DIM dropped is returned.

_Example_:
          PROGRAM test_sum
            LOGICAL :: x(2) = [ .true., .false. ]
            print *, PARITY(x) ! prints "T" (true).
          END PROGRAM


File: gfortran.info,  Node: PERROR,  Next: POPCNT,  Prev: PARITY,  Up: Intrinsic Procedures

9.215 'PERROR' -- Print system error message
============================================

_Description_:
     Prints (on the C 'stderr' stream) a newline-terminated error
     message corresponding to the last system error.  This is prefixed
     by STRING, a colon and a space.  See 'perror(3)'.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL PERROR(STRING)'

_Arguments_:
     STRING      A scalar of type 'CHARACTER' and of the default
                 kind.

_See also_:
     *note IERRNO::


File: gfortran.info,  Node: POPCNT,  Next: POPPAR,  Prev: PERROR,  Up: Intrinsic Procedures

9.216 'POPCNT' -- Number of bits set
====================================

_Description_:
     'POPCNT(I)' returns the number of bits set ('1' bits) in the binary
     representation of 'I'.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = POPCNT(I)'

_Arguments_:
     I           Shall be of type 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER' and of the default integer
     kind.

_See also_:
     *note POPPAR::, *note LEADZ::, *note TRAILZ::

_Example_:
          program test_population
            print *, popcnt(127),       poppar(127)
            print *, popcnt(huge(0_4)), poppar(huge(0_4))
            print *, popcnt(huge(0_8)), poppar(huge(0_8))
          end program test_population


File: gfortran.info,  Node: POPPAR,  Next: PRECISION,  Prev: POPCNT,  Up: Intrinsic Procedures

9.217 'POPPAR' -- Parity of the number of bits set
==================================================

_Description_:
     'POPPAR(I)' returns parity of the integer 'I', i.e.  the parity of
     the number of bits set ('1' bits) in the binary representation of
     'I'.  It is equal to 0 if 'I' has an even number of bits set, and 1
     for an odd number of '1' bits.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = POPPAR(I)'

_Arguments_:
     I           Shall be of type 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER' and of the default integer
     kind.

_See also_:
     *note POPCNT::, *note LEADZ::, *note TRAILZ::

_Example_:
          program test_population
            print *, popcnt(127),       poppar(127)
            print *, popcnt(huge(0_4)), poppar(huge(0_4))
            print *, popcnt(huge(0_8)), poppar(huge(0_8))
          end program test_population


File: gfortran.info,  Node: PRECISION,  Next: PRESENT,  Prev: POPPAR,  Up: Intrinsic Procedures

9.218 'PRECISION' -- Decimal precision of a real kind
=====================================================

_Description_:
     'PRECISION(X)' returns the decimal precision in the model of the
     type of 'X'.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = PRECISION(X)'

_Arguments_:
     X           Shall be of type 'REAL' or 'COMPLEX'.

_Return value_:
     The return value is of type 'INTEGER' and of the default integer
     kind.

_See also_:
     *note SELECTED_REAL_KIND::, *note RANGE::

_Example_:
          program prec_and_range
            real(kind=4) :: x(2)
            complex(kind=8) :: y

            print *, precision(x), range(x)
            print *, precision(y), range(y)
          end program prec_and_range


File: gfortran.info,  Node: PRESENT,  Next: PRODUCT,  Prev: PRECISION,  Up: Intrinsic Procedures

9.219 'PRESENT' -- Determine whether an optional dummy argument is specified
============================================================================

_Description_:
     Determines whether an optional dummy argument is present.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = PRESENT(A)'

_Arguments_:
     A           May be of any type and may be a pointer, scalar
                 or array value, or a dummy procedure.  It shall
                 be the name of an optional dummy argument
                 accessible within the current subroutine or
                 function.

_Return value_:
     Returns either 'TRUE' if the optional argument A is present, or
     'FALSE' otherwise.

_Example_:
          PROGRAM test_present
            WRITE(*,*) f(), f(42)      ! "F T"
          CONTAINS
            LOGICAL FUNCTION f(x)
              INTEGER, INTENT(IN), OPTIONAL :: x
              f = PRESENT(x)
            END FUNCTION
          END PROGRAM


File: gfortran.info,  Node: PRODUCT,  Next: RADIX,  Prev: PRESENT,  Up: Intrinsic Procedures

9.220 'PRODUCT' -- Product of array elements
============================================

_Description_:
     Multiplies the elements of ARRAY along dimension DIM if the
     corresponding element in MASK is 'TRUE'.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = PRODUCT(ARRAY[, MASK])'
     'RESULT = PRODUCT(ARRAY, DIM[, MASK])'

_Arguments_:
     ARRAY       Shall be an array of type 'INTEGER', 'REAL' or
                 'COMPLEX'.
     DIM         (Optional) shall be a scalar of type 'INTEGER'
                 with a value in the range from 1 to n, where n
                 equals the rank of ARRAY.
     MASK        (Optional) shall be of type 'LOGICAL' and either
                 be a scalar or an array of the same shape as
                 ARRAY.

_Return value_:
     The result is of the same type as ARRAY.

     If DIM is absent, a scalar with the product of all elements in
     ARRAY is returned.  Otherwise, an array of rank n-1, where n equals
     the rank of ARRAY, and a shape similar to that of ARRAY with
     dimension DIM dropped is returned.

_Example_:
          PROGRAM test_product
            INTEGER :: x(5) = (/ 1, 2, 3, 4 ,5 /)
            print *, PRODUCT(x)                    ! all elements, product = 120
            print *, PRODUCT(x, MASK=MOD(x, 2)==1) ! odd elements, product = 15
          END PROGRAM

_See also_:
     *note SUM::


File: gfortran.info,  Node: RADIX,  Next: RAN,  Prev: PRODUCT,  Up: Intrinsic Procedures

9.221 'RADIX' -- Base of a model number
=======================================

_Description_:
     'RADIX(X)' returns the base of the model representing the entity X.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = RADIX(X)'

_Arguments_:
     X           Shall be of type 'INTEGER' or 'REAL'

_Return value_:
     The return value is a scalar of type 'INTEGER' and of the default
     integer kind.

_See also_:
     *note SELECTED_REAL_KIND::

_Example_:
          program test_radix
            print *, "The radix for the default integer kind is", radix(0)
            print *, "The radix for the default real kind is", radix(0.0)
          end program test_radix


File: gfortran.info,  Node: RAN,  Next: RAND,  Prev: RADIX,  Up: Intrinsic Procedures

9.222 'RAN' -- Real pseudo-random number
========================================

_Description_:
     For compatibility with HP FORTRAN 77/iX, the 'RAN' intrinsic is
     provided as an alias for 'RAND'.  See *note RAND:: for complete
     documentation.

_Standard_:
     GNU extension

_Class_:
     Function

_See also_:
     *note RAND::, *note RANDOM_NUMBER::


File: gfortran.info,  Node: RAND,  Next: RANDOM_INIT,  Prev: RAN,  Up: Intrinsic Procedures

9.223 'RAND' -- Real pseudo-random number
=========================================

_Description_:
     'RAND(FLAG)' returns a pseudo-random number from a uniform
     distribution between 0 and 1.  If FLAG is 0, the next number in the
     current sequence is returned; if FLAG is 1, the generator is
     restarted by 'CALL SRAND(0)'; if FLAG has any other value, it is
     used as a new seed with 'SRAND'.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  It implements a simple modulo generator as
     provided by 'g77'.  For new code, one should consider the use of
     *note RANDOM_NUMBER:: as it implements a superior algorithm.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = RAND(I)'

_Arguments_:
     I           Shall be a scalar 'INTEGER' of kind 4.

_Return value_:
     The return value is of 'REAL' type and the default kind.

_Example_:
          program test_rand
            integer,parameter :: seed = 86456

            call srand(seed)
            print *, rand(), rand(), rand(), rand()
            print *, rand(seed), rand(), rand(), rand()
          end program test_rand

_See also_:
     *note SRAND::, *note RANDOM_NUMBER::


File: gfortran.info,  Node: RANDOM_INIT,  Next: RANDOM_NUMBER,  Prev: RAND,  Up: Intrinsic Procedures

9.224 'RANDOM_INIT' -- Initialize a pseudo-random number generator
==================================================================

_Description_:
     Initializes the state of the pseudorandom number generator used by
     'RANDOM_NUMBER'.

_Standard_:
     Fortran 2018

_Class_:
     Subroutine

_Syntax_:
     'CALL RANDOM_INIT(REPEATABLE, IMAGE_DISTINCT)'

_Arguments_:
     REPEATABLE     Shall be a scalar with a 'LOGICAL' type, and it is
                    'INTENT(IN)'.  If it is '.true.', the seed is set to
                    a processor-dependent value that is the same each
                    time 'RANDOM_INIT' is called from the same image.
                    The term "same image" means a single instance of
                    program execution.  The sequence of random numbers
                    is different for repeated execution of the program.
                    If it is '.false.', the seed is set to a
                    processor-dependent value.
     IMAGE_DISTINCT Shall be a scalar with a 'LOGICAL' type, and it is
                    'INTENT(IN)'.  If it is '.true.', the seed is set to
                    a processor-dependent value that is distinct from th
                    seed set by a call to 'RANDOM_INIT' in another
                    image.  If it is '.false.', the seed is set value
                    that does depend which image called 'RANDOM_INIT'.

_Example_:
          program test_random_seed
            implicit none
            real x(3), y(3)
            call random_init(.true., .true.)
            call random_number(x)
            call random_init(.true., .true.)
            call random_number(y)
            ! x and y are the same sequence
            if (any(x /= y)) call abort
          end program test_random_seed

_See also_:
     *note RANDOM_NUMBER::, *note RANDOM_SEED::


File: gfortran.info,  Node: RANDOM_NUMBER,  Next: RANDOM_SEED,  Prev: RANDOM_INIT,  Up: Intrinsic Procedures

9.225 'RANDOM_NUMBER' -- Pseudo-random number
=============================================

_Description_:
     Returns a single pseudorandom number or an array of pseudorandom
     numbers from the uniform distribution over the range 0 \leq x < 1.

     The runtime-library implements the xorshift1024* random number
     generator (RNG). This generator has a period of 2^{1024} - 1, and
     when using multiple threads up to 2^{512} threads can each generate
     2^{512} random numbers before any aliasing occurs.

     Note that in a multi-threaded program (e.g.  using OpenMP
     directives), each thread will have its own random number state.
     For details of the seeding procedure, see the documentation for the
     'RANDOM_SEED' intrinsic.

_Standard_:
     Fortran 95 and later

_Class_:
     Subroutine

_Syntax_:
     'RANDOM_NUMBER(HARVEST)'

_Arguments_:
     HARVEST     Shall be a scalar or an array of type 'REAL'.

_Example_:
          program test_random_number
            REAL :: r(5,5)
            CALL RANDOM_NUMBER(r)
          end program

_See also_:
     *note RANDOM_SEED::, *note RANDOM_INIT::


File: gfortran.info,  Node: RANDOM_SEED,  Next: RANGE,  Prev: RANDOM_NUMBER,  Up: Intrinsic Procedures

9.226 'RANDOM_SEED' -- Initialize a pseudo-random number sequence
=================================================================

_Description_:
     Restarts or queries the state of the pseudorandom number generator
     used by 'RANDOM_NUMBER'.

     If 'RANDOM_SEED' is called without arguments, it is seeded with
     random data retrieved from the operating system.

     As an extension to the Fortran standard, the GFortran
     'RANDOM_NUMBER' supports multiple threads.  Each thread in a
     multi-threaded program has its own seed.  When 'RANDOM_SEED' is
     called either without arguments or with the PUT argument, the given
     seed is copied into a master seed as well as the seed of the
     current thread.  When a new thread uses 'RANDOM_NUMBER' for the
     first time, the seed is copied from the master seed, and forwarded
     N * 2^{512} steps to guarantee that the random stream does not
     alias any other stream in the system, where N is the number of
     threads that have used 'RANDOM_NUMBER' so far during the program
     execution.

_Standard_:
     Fortran 95 and later

_Class_:
     Subroutine

_Syntax_:
     'CALL RANDOM_SEED([SIZE, PUT, GET])'

_Arguments_:
     SIZE        (Optional) Shall be a scalar and of type default
                 'INTEGER', with 'INTENT(OUT)'.  It specifies the
                 minimum size of the arrays used with the PUT and
                 GET arguments.
     PUT         (Optional) Shall be an array of type default
                 'INTEGER' and rank one.  It is 'INTENT(IN)' and
                 the size of the array must be larger than or
                 equal to the number returned by the SIZE
                 argument.
     GET         (Optional) Shall be an array of type default
                 'INTEGER' and rank one.  It is 'INTENT(OUT)' and
                 the size of the array must be larger than or
                 equal to the number returned by the SIZE
                 argument.

_Example_:
          program test_random_seed
            implicit none
            integer, allocatable :: seed(:)
            integer :: n

            call random_seed(size = n)
            allocate(seed(n))
            call random_seed(get=seed)
            write (*, *) seed
          end program test_random_seed

_See also_:
     *note RANDOM_NUMBER::, *note RANDOM_INIT::


File: gfortran.info,  Node: RANGE,  Next: RANK,  Prev: RANDOM_SEED,  Up: Intrinsic Procedures

9.227 'RANGE' -- Decimal exponent range
=======================================

_Description_:
     'RANGE(X)' returns the decimal exponent range in the model of the
     type of 'X'.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = RANGE(X)'

_Arguments_:
     X           Shall be of type 'INTEGER', 'REAL' or 'COMPLEX'.

_Return value_:
     The return value is of type 'INTEGER' and of the default integer
     kind.

_See also_:
     *note SELECTED_REAL_KIND::, *note PRECISION::

_Example_:
     See 'PRECISION' for an example.


File: gfortran.info,  Node: RANK,  Next: REAL,  Prev: RANGE,  Up: Intrinsic Procedures

9.228 'RANK' -- Rank of a data object
=====================================

_Description_:
     'RANK(A)' returns the rank of a scalar or array data object.

_Standard_:
     Technical Specification (TS) 29113

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = RANK(A)'

_Arguments_:
     A           can be of any type

_Return value_:
     The return value is of type 'INTEGER' and of the default integer
     kind.  For arrays, their rank is returned; for scalars zero is
     returned.

_Example_:
          program test_rank
            integer :: a
            real, allocatable :: b(:,:)

            print *, rank(a), rank(b) ! Prints:  0  2
          end program test_rank


File: gfortran.info,  Node: REAL,  Next: RENAME,  Prev: RANK,  Up: Intrinsic Procedures

9.229 'REAL' -- Convert to real type
====================================

_Description_:
     'REAL(A [, KIND])' converts its argument A to a real type.  The
     'REALPART' function is provided for compatibility with 'g77', and
     its use is strongly discouraged.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = REAL(A [, KIND])'
     'RESULT = REALPART(Z)'

_Arguments_:
     A           Shall be 'INTEGER', 'REAL', or 'COMPLEX'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     These functions return a 'REAL' variable or array under the
     following rules:

     (A)
          'REAL(A)' is converted to a default real type if A is an
          integer or real variable.
     (B)
          'REAL(A)' is converted to a real type with the kind type
          parameter of A if A is a complex variable.
     (C)
          'REAL(A, KIND)' is converted to a real type with kind type
          parameter KIND if A is a complex, integer, or real variable.

_Example_:
          program test_real
            complex :: x = (1.0, 2.0)
            print *, real(x), real(x,8), realpart(x)
          end program test_real

_Specific names_:
     Name           Argument       Return type    Standard
     'FLOAT(A)'     'INTEGER(4)'   'REAL(4)'      Fortran 77 and
                                                  later
     'DFLOAT(A)'    'INTEGER(4)'   'REAL(8)'      GNU extension
     'FLOATI(A)'    'INTEGER(2)'   'REAL(4)'      GNU extension
     'FLOATJ(A)'    'INTEGER(4)'   'REAL(4)'      GNU extension
     'FLOATK(A)'    'INTEGER(8)'   'REAL(4)'      GNU extension
     'SNGL(A)'      'INTEGER(8)'   'REAL(4)'      Fortran 77 and
                                                  later

_See also_:
     *note DBLE::


File: gfortran.info,  Node: RENAME,  Next: REPEAT,  Prev: REAL,  Up: Intrinsic Procedures

9.230 'RENAME' -- Rename a file
===============================

_Description_:
     Renames a file from file PATH1 to PATH2.  A null character
     ('CHAR(0)') can be used to mark the end of the names in PATH1 and
     PATH2; otherwise, trailing blanks in the file names are ignored.
     If the STATUS argument is supplied, it contains 0 on success or a
     nonzero error code upon return; see 'rename(2)'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL RENAME(PATH1, PATH2 [, STATUS])'
     'STATUS = RENAME(PATH1, PATH2)'

_Arguments_:
     PATH1       Shall be of default 'CHARACTER' type.
     PATH2       Shall be of default 'CHARACTER' type.
     STATUS      (Optional) Shall be of default 'INTEGER' type.

_See also_:
     *note LINK::


File: gfortran.info,  Node: REPEAT,  Next: RESHAPE,  Prev: RENAME,  Up: Intrinsic Procedures

9.231 'REPEAT' -- Repeated string concatenation
===============================================

_Description_:
     Concatenates NCOPIES copies of a string.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = REPEAT(STRING, NCOPIES)'

_Arguments_:
     STRING      Shall be scalar and of type 'CHARACTER'.
     NCOPIES     Shall be scalar and of type 'INTEGER'.

_Return value_:
     A new scalar of type 'CHARACTER' built up from NCOPIES copies of
     STRING.

_Example_:
          program test_repeat
            write(*,*) repeat("x", 5)   ! "xxxxx"
          end program


File: gfortran.info,  Node: RESHAPE,  Next: RRSPACING,  Prev: REPEAT,  Up: Intrinsic Procedures

9.232 'RESHAPE' -- Function to reshape an array
===============================================

_Description_:
     Reshapes SOURCE to correspond to SHAPE.  If necessary, the new
     array may be padded with elements from PAD or permuted as defined
     by ORDER.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = RESHAPE(SOURCE, SHAPE[, PAD, ORDER])'

_Arguments_:
     SOURCE      Shall be an array of any type.
     SHAPE       Shall be of type 'INTEGER' and an array of rank
                 one.  Its values must be positive or zero.
     PAD         (Optional) shall be an array of the same type as
                 SOURCE.
     ORDER       (Optional) shall be of type 'INTEGER' and an
                 array of the same shape as SHAPE.  Its values
                 shall be a permutation of the numbers from 1 to
                 n, where n is the size of SHAPE.  If ORDER is
                 absent, the natural ordering shall be assumed.

_Return value_:
     The result is an array of shape SHAPE with the same type as SOURCE.

_Example_:
          PROGRAM test_reshape
            INTEGER, DIMENSION(4) :: x
            WRITE(*,*) SHAPE(x)                       ! prints "4"
            WRITE(*,*) SHAPE(RESHAPE(x, (/2, 2/)))    ! prints "2 2"
          END PROGRAM

_See also_:
     *note SHAPE::


File: gfortran.info,  Node: RRSPACING,  Next: RSHIFT,  Prev: RESHAPE,  Up: Intrinsic Procedures

9.233 'RRSPACING' -- Reciprocal of the relative spacing
=======================================================

_Description_:
     'RRSPACING(X)' returns the reciprocal of the relative spacing of
     model numbers near X.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = RRSPACING(X)'

_Arguments_:
     X           Shall be of type 'REAL'.

_Return value_:
     The return value is of the same type and kind as X.  The value
     returned is equal to 'ABS(FRACTION(X)) *
     FLOAT(RADIX(X))**DIGITS(X)'.

_See also_:
     *note SPACING::


File: gfortran.info,  Node: RSHIFT,  Next: SAME_TYPE_AS,  Prev: RRSPACING,  Up: Intrinsic Procedures

9.234 'RSHIFT' -- Right shift bits
==================================

_Description_:
     'RSHIFT' returns a value corresponding to I with all of the bits
     shifted right by SHIFT places.  SHIFT shall be nonnegative and less
     than or equal to 'BIT_SIZE(I)', otherwise the result value is
     undefined.  Bits shifted out from the right end are lost.  The fill
     is arithmetic: the bits shifted in from the left end are equal to
     the leftmost bit, which in two's complement representation is the
     sign bit.

     This function has been superseded by the 'SHIFTA' intrinsic, which
     is standard in Fortran 2008 and later.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     'RESULT = RSHIFT(I, SHIFT)'

_Arguments_:
     I           The type shall be 'INTEGER'.
     SHIFT       The type shall be 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER' and of the same kind as I.

_See also_:
     *note ISHFT::, *note ISHFTC::, *note LSHIFT::, *note SHIFTA::,
     *note SHIFTR::, *note SHIFTL::


File: gfortran.info,  Node: SAME_TYPE_AS,  Next: SCALE,  Prev: RSHIFT,  Up: Intrinsic Procedures

9.235 'SAME_TYPE_AS' -- Query dynamic types for equality
========================================================

_Description_:
     Query dynamic types for equality.

_Standard_:
     Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = SAME_TYPE_AS(A, B)'

_Arguments_:
     A           Shall be an object of extensible declared type
                 or unlimited polymorphic.
     B           Shall be an object of extensible declared type
                 or unlimited polymorphic.

_Return value_:
     The return value is a scalar of type default logical.  It is true
     if and only if the dynamic type of A is the same as the dynamic
     type of B.

_See also_:
     *note EXTENDS_TYPE_OF::


File: gfortran.info,  Node: SCALE,  Next: SCAN,  Prev: SAME_TYPE_AS,  Up: Intrinsic Procedures

9.236 'SCALE' -- Scale a real value
===================================

_Description_:
     'SCALE(X,I)' returns 'X * RADIX(X)**I'.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = SCALE(X, I)'

_Arguments_:
     X           The type of the argument shall be a 'REAL'.
     I           The type of the argument shall be a 'INTEGER'.

_Return value_:
     The return value is of the same type and kind as X.  Its value is
     'X * RADIX(X)**I'.

_Example_:
          program test_scale
            real :: x = 178.1387e-4
            integer :: i = 5
            print *, scale(x,i), x*radix(x)**i
          end program test_scale


File: gfortran.info,  Node: SCAN,  Next: SECNDS,  Prev: SCALE,  Up: Intrinsic Procedures

9.237 'SCAN' -- Scan a string for the presence of a set of characters
=====================================================================

_Description_:
     Scans a STRING for any of the characters in a SET of characters.

     If BACK is either absent or equals 'FALSE', this function returns
     the position of the leftmost character of STRING that is in SET.
     If BACK equals 'TRUE', the rightmost position is returned.  If no
     character of SET is found in STRING, the result is zero.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = SCAN(STRING, SET[, BACK [, KIND]])'

_Arguments_:
     STRING      Shall be of type 'CHARACTER'.
     SET         Shall be of type 'CHARACTER'.
     BACK        (Optional) shall be of type 'LOGICAL'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER' and of kind KIND.  If KIND is
     absent, the return value is of default integer kind.

_Example_:
          PROGRAM test_scan
            WRITE(*,*) SCAN("FORTRAN", "AO")          ! 2, found 'O'
            WRITE(*,*) SCAN("FORTRAN", "AO", .TRUE.)  ! 6, found 'A'
            WRITE(*,*) SCAN("FORTRAN", "C++")         ! 0, found none
          END PROGRAM

_See also_:
     *note INDEX intrinsic::, *note VERIFY::


File: gfortran.info,  Node: SECNDS,  Next: SECOND,  Prev: SCAN,  Up: Intrinsic Procedures

9.238 'SECNDS' -- Time function
===============================

_Description_:
     'SECNDS(X)' gets the time in seconds from the real-time system
     clock.  X is a reference time, also in seconds.  If this is zero,
     the time in seconds from midnight is returned.  This function is
     non-standard and its use is discouraged.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = SECNDS (X)'

_Arguments_:
     T           Shall be of type 'REAL(4)'.
     X           Shall be of type 'REAL(4)'.

_Return value_:
     None

_Example_:
          program test_secnds
              integer :: i
              real(4) :: t1, t2
              print *, secnds (0.0)   ! seconds since midnight
              t1 = secnds (0.0)       ! reference time
              do i = 1, 10000000      ! do something
              end do
              t2 = secnds (t1)        ! elapsed time
              print *, "Something took ", t2, " seconds."
          end program test_secnds


File: gfortran.info,  Node: SECOND,  Next: SELECTED_CHAR_KIND,  Prev: SECNDS,  Up: Intrinsic Procedures

9.239 'SECOND' -- CPU time function
===================================

_Description_:
     Returns a 'REAL(4)' value representing the elapsed CPU time in
     seconds.  This provides the same functionality as the standard
     'CPU_TIME' intrinsic, and is only included for backwards
     compatibility.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL SECOND(TIME)'
     'TIME = SECOND()'

_Arguments_:
     TIME        Shall be of type 'REAL(4)'.

_Return value_:
     In either syntax, TIME is set to the process's current runtime in
     seconds.

_See also_:
     *note CPU_TIME::


File: gfortran.info,  Node: SELECTED_CHAR_KIND,  Next: SELECTED_INT_KIND,  Prev: SECOND,  Up: Intrinsic Procedures

9.240 'SELECTED_CHAR_KIND' -- Choose character kind
===================================================

_Description_:

     'SELECTED_CHAR_KIND(NAME)' returns the kind value for the character
     set named NAME, if a character set with such a name is supported,
     or -1 otherwise.  Currently, supported character sets include
     "ASCII" and "DEFAULT", which are equivalent, and "ISO_10646"
     (Universal Character Set, UCS-4) which is commonly known as
     Unicode.

_Standard_:
     Fortran 2003 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = SELECTED_CHAR_KIND(NAME)'

_Arguments_:
     NAME        Shall be a scalar and of the default character
                 type.

_Example_:
          program character_kind
            use iso_fortran_env
            implicit none
            integer, parameter :: ascii = selected_char_kind ("ascii")
            integer, parameter :: ucs4  = selected_char_kind ('ISO_10646')

            character(kind=ascii, len=26) :: alphabet
            character(kind=ucs4,  len=30) :: hello_world

            alphabet = ascii_"abcdefghijklmnopqrstuvwxyz"
            hello_world = ucs4_'Hello World and Ni Hao -- ' &
                          // char (int (z'4F60'), ucs4)     &
                          // char (int (z'597D'), ucs4)

            write (*,*) alphabet

            open (output_unit, encoding='UTF-8')
            write (*,*) trim (hello_world)
          end program character_kind


File: gfortran.info,  Node: SELECTED_INT_KIND,  Next: SELECTED_REAL_KIND,  Prev: SELECTED_CHAR_KIND,  Up: Intrinsic Procedures

9.241 'SELECTED_INT_KIND' -- Choose integer kind
================================================

_Description_:
     'SELECTED_INT_KIND(R)' return the kind value of the smallest
     integer type that can represent all values ranging from -10^R
     (exclusive) to 10^R (exclusive).  If there is no integer kind that
     accommodates this range, 'SELECTED_INT_KIND' returns -1.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = SELECTED_INT_KIND(R)'

_Arguments_:
     R           Shall be a scalar and of type 'INTEGER'.

_Example_:
          program large_integers
            integer,parameter :: k5 = selected_int_kind(5)
            integer,parameter :: k15 = selected_int_kind(15)
            integer(kind=k5) :: i5
            integer(kind=k15) :: i15

            print *, huge(i5), huge(i15)

            ! The following inequalities are always true
            print *, huge(i5) >= 10_k5**5-1
            print *, huge(i15) >= 10_k15**15-1
          end program large_integers


File: gfortran.info,  Node: SELECTED_REAL_KIND,  Next: SET_EXPONENT,  Prev: SELECTED_INT_KIND,  Up: Intrinsic Procedures

9.242 'SELECTED_REAL_KIND' -- Choose real kind
==============================================

_Description_:
     'SELECTED_REAL_KIND(P,R)' returns the kind value of a real data
     type with decimal precision of at least 'P' digits, exponent range
     of at least 'R', and with a radix of 'RADIX'.

_Standard_:
     Fortran 95 and later, with 'RADIX' Fortran 2008 or later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = SELECTED_REAL_KIND([P, R, RADIX])'

_Arguments_:
     P           (Optional) shall be a scalar and of type
                 'INTEGER'.
     R           (Optional) shall be a scalar and of type
                 'INTEGER'.
     RADIX       (Optional) shall be a scalar and of type
                 'INTEGER'.
     Before Fortran 2008, at least one of the arguments R or P shall be
     present; since Fortran 2008, they are assumed to be zero if absent.

_Return value_:

     'SELECTED_REAL_KIND' returns the value of the kind type parameter
     of a real data type with decimal precision of at least 'P' digits,
     a decimal exponent range of at least 'R', and with the requested
     'RADIX'.  If the 'RADIX' parameter is absent, real kinds with any
     radix can be returned.  If more than one real data type meet the
     criteria, the kind of the data type with the smallest decimal
     precision is returned.  If no real data type matches the criteria,
     the result is
     -1 if the processor does not support a real data type with a
          precision greater than or equal to 'P', but the 'R' and
          'RADIX' requirements can be fulfilled
     -2 if the processor does not support a real type with an exponent
          range greater than or equal to 'R', but 'P' and 'RADIX' are
          fulfillable
     -3 if 'RADIX' but not 'P' and 'R' requirements
          are fulfillable
     -4 if 'RADIX' and either 'P' or 'R' requirements
          are fulfillable
     -5 if there is no real type with the given 'RADIX'

_See also_:
     *note PRECISION::, *note RANGE::, *note RADIX::

_Example_:
          program real_kinds
            integer,parameter :: p6 = selected_real_kind(6)
            integer,parameter :: p10r100 = selected_real_kind(10,100)
            integer,parameter :: r400 = selected_real_kind(r=400)
            real(kind=p6) :: x
            real(kind=p10r100) :: y
            real(kind=r400) :: z

            print *, precision(x), range(x)
            print *, precision(y), range(y)
            print *, precision(z), range(z)
          end program real_kinds


File: gfortran.info,  Node: SET_EXPONENT,  Next: SHAPE,  Prev: SELECTED_REAL_KIND,  Up: Intrinsic Procedures

9.243 'SET_EXPONENT' -- Set the exponent of the model
=====================================================

_Description_:
     'SET_EXPONENT(X, I)' returns the real number whose fractional part
     is that that of X and whose exponent part is I.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = SET_EXPONENT(X, I)'

_Arguments_:
     X           Shall be of type 'REAL'.
     I           Shall be of type 'INTEGER'.

_Return value_:
     The return value is of the same type and kind as X.  The real
     number whose fractional part is that that of X and whose exponent
     part if I is returned; it is 'FRACTION(X) * RADIX(X)**I'.

_Example_:
          PROGRAM test_setexp
            REAL :: x = 178.1387e-4
            INTEGER :: i = 17
            PRINT *, SET_EXPONENT(x, i), FRACTION(x) * RADIX(x)**i
          END PROGRAM


File: gfortran.info,  Node: SHAPE,  Next: SHIFTA,  Prev: SET_EXPONENT,  Up: Intrinsic Procedures

9.244 'SHAPE' -- Determine the shape of an array
================================================

_Description_:
     Determines the shape of an array.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = SHAPE(SOURCE [, KIND])'

_Arguments_:
     SOURCE      Shall be an array or scalar of any type.  If
                 SOURCE is a pointer it must be associated and
                 allocatable arrays must be allocated.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     An 'INTEGER' array of rank one with as many elements as SOURCE has
     dimensions.  The elements of the resulting array correspond to the
     extend of SOURCE along the respective dimensions.  If SOURCE is a
     scalar, the result is the rank one array of size zero.  If KIND is
     absent, the return value has the default integer kind otherwise the
     specified kind.

_Example_:
          PROGRAM test_shape
            INTEGER, DIMENSION(-1:1, -1:2) :: A
            WRITE(*,*) SHAPE(A)             ! (/ 3, 4 /)
            WRITE(*,*) SIZE(SHAPE(42))      ! (/ /)
          END PROGRAM

_See also_:
     *note RESHAPE::, *note SIZE::


File: gfortran.info,  Node: SHIFTA,  Next: SHIFTL,  Prev: SHAPE,  Up: Intrinsic Procedures

9.245 'SHIFTA' -- Right shift with fill
=======================================

_Description_:
     'SHIFTA' returns a value corresponding to I with all of the bits
     shifted right by SHIFT places.  SHIFT that be nonnegative and less
     than or equal to 'BIT_SIZE(I)', otherwise the result value is
     undefined.  Bits shifted out from the right end are lost.  The fill
     is arithmetic: the bits shifted in from the left end are equal to
     the leftmost bit, which in two's complement representation is the
     sign bit.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = SHIFTA(I, SHIFT)'

_Arguments_:
     I           The type shall be 'INTEGER'.
     SHIFT       The type shall be 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER' and of the same kind as I.

_See also_:
     *note SHIFTL::, *note SHIFTR::


File: gfortran.info,  Node: SHIFTL,  Next: SHIFTR,  Prev: SHIFTA,  Up: Intrinsic Procedures

9.246 'SHIFTL' -- Left shift
============================

_Description_:
     'SHIFTL' returns a value corresponding to I with all of the bits
     shifted left by SHIFT places.  SHIFT shall be nonnegative and less
     than or equal to 'BIT_SIZE(I)', otherwise the result value is
     undefined.  Bits shifted out from the left end are lost, and bits
     shifted in from the right end are set to 0.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = SHIFTL(I, SHIFT)'

_Arguments_:
     I           The type shall be 'INTEGER'.
     SHIFT       The type shall be 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER' and of the same kind as I.

_See also_:
     *note SHIFTA::, *note SHIFTR::


File: gfortran.info,  Node: SHIFTR,  Next: SIGN,  Prev: SHIFTL,  Up: Intrinsic Procedures

9.247 'SHIFTR' -- Right shift
=============================

_Description_:
     'SHIFTR' returns a value corresponding to I with all of the bits
     shifted right by SHIFT places.  SHIFT shall be nonnegative and less
     than or equal to 'BIT_SIZE(I)', otherwise the result value is
     undefined.  Bits shifted out from the right end are lost, and bits
     shifted in from the left end are set to 0.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = SHIFTR(I, SHIFT)'

_Arguments_:
     I           The type shall be 'INTEGER'.
     SHIFT       The type shall be 'INTEGER'.

_Return value_:
     The return value is of type 'INTEGER' and of the same kind as I.

_See also_:
     *note SHIFTA::, *note SHIFTL::


File: gfortran.info,  Node: SIGN,  Next: SIGNAL,  Prev: SHIFTR,  Up: Intrinsic Procedures

9.248 'SIGN' -- Sign copying function
=====================================

_Description_:
     'SIGN(A,B)' returns the value of A with the sign of B.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = SIGN(A, B)'

_Arguments_:
     A           Shall be of type 'INTEGER' or 'REAL'
     B           Shall be of the same type and kind as A

_Return value_:
     The kind of the return value is that of A and B.  If B\ge 0 then
     the result is 'ABS(A)', else it is '-ABS(A)'.

_Example_:
          program test_sign
            print *, sign(-12,1)
            print *, sign(-12,0)
            print *, sign(-12,-1)

            print *, sign(-12.,1.)
            print *, sign(-12.,0.)
            print *, sign(-12.,-1.)
          end program test_sign

_Specific names_:
     Name           Arguments      Return type    Standard
     'SIGN(A,B)'    'REAL(4) A,    'REAL(4)'      f77, gnu
                    B'
     'ISIGN(A,B)'   'INTEGER(4)    'INTEGER(4)'   f77, gnu
                    A, B'
     'DSIGN(A,B)'   'REAL(8) A,    'REAL(8)'      f77, gnu
                    B'


File: gfortran.info,  Node: SIGNAL,  Next: SIN,  Prev: SIGN,  Up: Intrinsic Procedures

9.249 'SIGNAL' -- Signal handling subroutine (or function)
==========================================================

_Description_:
     'SIGNAL(NUMBER, HANDLER [, STATUS])' causes external subroutine
     HANDLER to be executed with a single integer argument when signal
     NUMBER occurs.  If HANDLER is an integer, it can be used to turn
     off handling of signal NUMBER or revert to its default action.  See
     'signal(2)'.

     If 'SIGNAL' is called as a subroutine and the STATUS argument is
     supplied, it is set to the value returned by 'signal(2)'.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL SIGNAL(NUMBER, HANDLER [, STATUS])'
     'STATUS = SIGNAL(NUMBER, HANDLER)'

_Arguments_:
     NUMBER      Shall be a scalar integer, with 'INTENT(IN)'
     HANDLER     Signal handler ('INTEGER FUNCTION' or
                 'SUBROUTINE') or dummy/global 'INTEGER' scalar.
                 'INTEGER'.  It is 'INTENT(IN)'.
     STATUS      (Optional) STATUS shall be a scalar integer.  It
                 has 'INTENT(OUT)'.

_Return value_:
     The 'SIGNAL' function returns the value returned by 'signal(2)'.

_Example_:
          program test_signal
            intrinsic signal
            external handler_print

            call signal (12, handler_print)
            call signal (10, 1)

            call sleep (30)
          end program test_signal


File: gfortran.info,  Node: SIN,  Next: SIND,  Prev: SIGNAL,  Up: Intrinsic Procedures

9.250 'SIN' -- Sine function
============================

_Description_:
     'SIN(X)' computes the sine of X.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = SIN(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value has same type and kind as X.

_Example_:
          program test_sin
            real :: x = 0.0
            x = sin(x)
          end program test_sin

_Specific names_:
     Name           Argument       Return type    Standard
     'SIN(X)'       'REAL(4) X'    'REAL(4)'      f77, gnu
     'DSIN(X)'      'REAL(8) X'    'REAL(8)'      f95, gnu
     'CSIN(X)'      'COMPLEX(4)    'COMPLEX(4)'   f95, gnu
                    X'
     'ZSIN(X)'      'COMPLEX(8)    'COMPLEX(8)'   f95, gnu
                    X'
     'CDSIN(X)'     'COMPLEX(8)    'COMPLEX(8)'   f95, gnu
                    X'

_See also_:
     Inverse function: *note ASIN:: Degrees function: *note SIND::


File: gfortran.info,  Node: SIND,  Next: SINH,  Prev: SIN,  Up: Intrinsic Procedures

9.251 'SIND' -- Sine function, degrees
======================================

_Description_:
     'SIND(X)' computes the sine of X in degrees.

     This function is for compatibility only and should be avoided in
     favor of standard constructs wherever possible.

_Standard_:
     GNU Extension, enabled with '-fdec-math'.

_Class_:
     Elemental function

_Syntax_:
     'RESULT = SIND(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value has same type and kind as X, and its value is in
     degrees.

_Example_:
          program test_sind
            real :: x = 0.0
            x = sind(x)
          end program test_sind

_Specific names_:
     Name           Argument       Return type    Standard
     'SIND(X)'      'REAL(4) X'    'REAL(4)'      GNU Extension
     'DSIND(X)'     'REAL(8) X'    'REAL(8)'      GNU Extension
     'CSIND(X)'     'COMPLEX(4)    'COMPLEX(4)'   GNU Extension
                    X'
     'ZSIND(X)'     'COMPLEX(8)    'COMPLEX(8)'   GNU Extension
                    X'
     'CDSIND(X)'    'COMPLEX(8)    'COMPLEX(8)'   GNU Extension
                    X'

_See also_:
     Inverse function: *note ASIND:: Radians function: *note SIN::


File: gfortran.info,  Node: SINH,  Next: SIZE,  Prev: SIND,  Up: Intrinsic Procedures

9.252 'SINH' -- Hyperbolic sine function
========================================

_Description_:
     'SINH(X)' computes the hyperbolic sine of X.

_Standard_:
     Fortran 95 and later, for a complex argument Fortran 2008 or later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = SINH(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value has same type and kind as X.

_Example_:
          program test_sinh
            real(8) :: x = - 1.0_8
            x = sinh(x)
          end program test_sinh

_Specific names_:
     Name           Argument       Return type    Standard
     'SINH(X)'      'REAL(4) X'    'REAL(4)'      Fortran 95 and
                                                  later
     'DSINH(X)'     'REAL(8) X'    'REAL(8)'      Fortran 95 and
                                                  later

_See also_:
     *note ASINH::


File: gfortran.info,  Node: SIZE,  Next: SIZEOF,  Prev: SINH,  Up: Intrinsic Procedures

9.253 'SIZE' -- Determine the size of an array
==============================================

_Description_:
     Determine the extent of ARRAY along a specified dimension DIM, or
     the total number of elements in ARRAY if DIM is absent.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = SIZE(ARRAY[, DIM [, KIND]])'

_Arguments_:
     ARRAY       Shall be an array of any type.  If ARRAY is a
                 pointer it must be associated and allocatable
                 arrays must be allocated.
     DIM         (Optional) shall be a scalar of type 'INTEGER'
                 and its value shall be in the range from 1 to n,
                 where n equals the rank of ARRAY.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER' and of kind KIND.  If KIND is
     absent, the return value is of default integer kind.

_Example_:
          PROGRAM test_size
            WRITE(*,*) SIZE((/ 1, 2 /))    ! 2
          END PROGRAM

_See also_:
     *note SHAPE::, *note RESHAPE::


File: gfortran.info,  Node: SIZEOF,  Next: SLEEP,  Prev: SIZE,  Up: Intrinsic Procedures

9.254 'SIZEOF' -- Size in bytes of an expression
================================================

_Description_:
     'SIZEOF(X)' calculates the number of bytes of storage the
     expression 'X' occupies.

_Standard_:
     GNU extension

_Class_:
     Inquiry function

_Syntax_:
     'N = SIZEOF(X)'

_Arguments_:
     X           The argument shall be of any type, rank or
                 shape.

_Return value_:
     The return value is of type integer and of the system-dependent
     kind C_SIZE_T (from the ISO_C_BINDING module).  Its value is the
     number of bytes occupied by the argument.  If the argument has the
     'POINTER' attribute, the number of bytes of the storage area
     pointed to is returned.  If the argument is of a derived type with
     'POINTER' or 'ALLOCATABLE' components, the return value does not
     account for the sizes of the data pointed to by these components.
     If the argument is polymorphic, the size according to the dynamic
     type is returned.  The argument may not be a procedure or procedure
     pointer.  Note that the code assumes for arrays that those are
     contiguous; for contiguous arrays, it returns the storage or an
     array element multiplied by the size of the array.

_Example_:
             integer :: i
             real :: r, s(5)
             print *, (sizeof(s)/sizeof(r) == 5)
             end
     The example will print '.TRUE.' unless you are using a platform
     where default 'REAL' variables are unusually padded.

_See also_:
     *note C_SIZEOF::, *note STORAGE_SIZE::


File: gfortran.info,  Node: SLEEP,  Next: SPACING,  Prev: SIZEOF,  Up: Intrinsic Procedures

9.255 'SLEEP' -- Sleep for the specified number of seconds
==========================================================

_Description_:
     Calling this subroutine causes the process to pause for SECONDS
     seconds.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL SLEEP(SECONDS)'

_Arguments_:
     SECONDS     The type shall be of default 'INTEGER'.

_Example_:
          program test_sleep
            call sleep(5)
          end


File: gfortran.info,  Node: SPACING,  Next: SPREAD,  Prev: SLEEP,  Up: Intrinsic Procedures

9.256 'SPACING' -- Smallest distance between two numbers of a given type
========================================================================

_Description_:
     Determines the distance between the argument X and the nearest
     adjacent number of the same type.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = SPACING(X)'

_Arguments_:
     X           Shall be of type 'REAL'.

_Return value_:
     The result is of the same type as the input argument X.

_Example_:
          PROGRAM test_spacing
            INTEGER, PARAMETER :: SGL = SELECTED_REAL_KIND(p=6, r=37)
            INTEGER, PARAMETER :: DBL = SELECTED_REAL_KIND(p=13, r=200)

            WRITE(*,*) spacing(1.0_SGL)      ! "1.1920929E-07"          on i686
            WRITE(*,*) spacing(1.0_DBL)      ! "2.220446049250313E-016" on i686
          END PROGRAM

_See also_:
     *note RRSPACING::


File: gfortran.info,  Node: SPREAD,  Next: SQRT,  Prev: SPACING,  Up: Intrinsic Procedures

9.257 'SPREAD' -- Add a dimension to an array
=============================================

_Description_:
     Replicates a SOURCE array NCOPIES times along a specified dimension
     DIM.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = SPREAD(SOURCE, DIM, NCOPIES)'

_Arguments_:
     SOURCE      Shall be a scalar or an array of any type and a
                 rank less than seven.
     DIM         Shall be a scalar of type 'INTEGER' with a value
                 in the range from 1 to n+1, where n equals the
                 rank of SOURCE.
     NCOPIES     Shall be a scalar of type 'INTEGER'.

_Return value_:
     The result is an array of the same type as SOURCE and has rank n+1
     where n equals the rank of SOURCE.

_Example_:
          PROGRAM test_spread
            INTEGER :: a = 1, b(2) = (/ 1, 2 /)
            WRITE(*,*) SPREAD(A, 1, 2)            ! "1 1"
            WRITE(*,*) SPREAD(B, 1, 2)            ! "1 1 2 2"
          END PROGRAM

_See also_:
     *note UNPACK::


File: gfortran.info,  Node: SQRT,  Next: SRAND,  Prev: SPREAD,  Up: Intrinsic Procedures

9.258 'SQRT' -- Square-root function
====================================

_Description_:
     'SQRT(X)' computes the square root of X.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = SQRT(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value is of type 'REAL' or 'COMPLEX'.  The kind type
     parameter is the same as X.

_Example_:
          program test_sqrt
            real(8) :: x = 2.0_8
            complex :: z = (1.0, 2.0)
            x = sqrt(x)
            z = sqrt(z)
          end program test_sqrt

_Specific names_:
     Name           Argument       Return type    Standard
     'SQRT(X)'      'REAL(4) X'    'REAL(4)'      Fortran 95 and
                                                  later
     'DSQRT(X)'     'REAL(8) X'    'REAL(8)'      Fortran 95 and
                                                  later
     'CSQRT(X)'     'COMPLEX(4)    'COMPLEX(4)'   Fortran 95 and
                    X'                            later
     'ZSQRT(X)'     'COMPLEX(8)    'COMPLEX(8)'   GNU extension
                    X'
     'CDSQRT(X)'    'COMPLEX(8)    'COMPLEX(8)'   GNU extension
                    X'


File: gfortran.info,  Node: SRAND,  Next: STAT,  Prev: SQRT,  Up: Intrinsic Procedures

9.259 'SRAND' -- Reinitialize the random number generator
=========================================================

_Description_:
     'SRAND' reinitializes the pseudo-random number generator called by
     'RAND' and 'IRAND'.  The new seed used by the generator is
     specified by the required argument SEED.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     'CALL SRAND(SEED)'

_Arguments_:
     SEED        Shall be a scalar 'INTEGER(kind=4)'.

_Return value_:
     Does not return anything.

_Example_:
     See 'RAND' and 'IRAND' for examples.

_Notes_:
     The Fortran standard specifies the intrinsic subroutines
     'RANDOM_SEED' to initialize the pseudo-random number generator and
     'RANDOM_NUMBER' to generate pseudo-random numbers.  These
     subroutines should be used in new codes.

     Please note that in GNU Fortran, these two sets of intrinsics
     ('RAND', 'IRAND' and 'SRAND' on the one hand, 'RANDOM_NUMBER' and
     'RANDOM_SEED' on the other hand) access two independent
     pseudo-random number generators.

_See also_:
     *note RAND::, *note RANDOM_SEED::, *note RANDOM_NUMBER::


File: gfortran.info,  Node: STAT,  Next: STORAGE_SIZE,  Prev: SRAND,  Up: Intrinsic Procedures

9.260 'STAT' -- Get file status
===============================

_Description_:
     This function returns information about a file.  No permissions are
     required on the file itself, but execute (search) permission is
     required on all of the directories in path that lead to the file.

     The elements that are obtained and stored in the array 'VALUES':
     'VALUES(1)' Device ID
     'VALUES(2)' Inode number
     'VALUES(3)' File mode
     'VALUES(4)' Number of links
     'VALUES(5)' Owner's uid
     'VALUES(6)' Owner's gid
     'VALUES(7)' ID of device containing directory entry for file
                 (0 if not available)
     'VALUES(8)' File size (bytes)
     'VALUES(9)' Last access time
     'VALUES(10)'Last modification time
     'VALUES(11)'Last file status change time
     'VALUES(12)'Preferred I/O block size (-1 if not available)
     'VALUES(13)'Number of blocks allocated (-1 if not available)

     Not all these elements are relevant on all systems.  If an element
     is not relevant, it is returned as 0.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL STAT(NAME, VALUES [, STATUS])'
     'STATUS = STAT(NAME, VALUES)'

_Arguments_:
     NAME        The type shall be 'CHARACTER', of the default
                 kind and a valid path within the file system.
     VALUES      The type shall be 'INTEGER(4), DIMENSION(13)'.
     STATUS      (Optional) status flag of type 'INTEGER(4)'.
                 Returns 0 on success and a system specific error
                 code otherwise.

_Example_:
          PROGRAM test_stat
            INTEGER, DIMENSION(13) :: buff
            INTEGER :: status

            CALL STAT("/etc/passwd", buff, status)

            IF (status == 0) THEN
              WRITE (*, FMT="('Device ID:',               T30, I19)") buff(1)
              WRITE (*, FMT="('Inode number:',            T30, I19)") buff(2)
              WRITE (*, FMT="('File mode (octal):',       T30, O19)") buff(3)
              WRITE (*, FMT="('Number of links:',         T30, I19)") buff(4)
              WRITE (*, FMT="('Owner''s uid:',            T30, I19)") buff(5)
              WRITE (*, FMT="('Owner''s gid:',            T30, I19)") buff(6)
              WRITE (*, FMT="('Device where located:',    T30, I19)") buff(7)
              WRITE (*, FMT="('File size:',               T30, I19)") buff(8)
              WRITE (*, FMT="('Last access time:',        T30, A19)") CTIME(buff(9))
              WRITE (*, FMT="('Last modification time',   T30, A19)") CTIME(buff(10))
              WRITE (*, FMT="('Last status change time:', T30, A19)") CTIME(buff(11))
              WRITE (*, FMT="('Preferred block size:',    T30, I19)") buff(12)
              WRITE (*, FMT="('No. of blocks allocated:', T30, I19)") buff(13)
            END IF
          END PROGRAM

_See also_:
     To stat an open file: *note FSTAT::, to stat a link: *note LSTAT::


File: gfortran.info,  Node: STORAGE_SIZE,  Next: SUM,  Prev: STAT,  Up: Intrinsic Procedures

9.261 'STORAGE_SIZE' -- Storage size in bits
============================================

_Description_:
     Returns the storage size of argument A in bits.
_Standard_:
     Fortran 2008 and later
_Class_:
     Inquiry function
_Syntax_:
     'RESULT = STORAGE_SIZE(A [, KIND])'

_Arguments_:
     A           Shall be a scalar or array of any type.
     KIND        (Optional) shall be a scalar integer constant
                 expression.

_Return Value_:
     The result is a scalar integer with the kind type parameter
     specified by KIND (or default integer type if KIND is missing).
     The result value is the size expressed in bits for an element of an
     array that has the dynamic type and type parameters of A.

_See also_:
     *note C_SIZEOF::, *note SIZEOF::


File: gfortran.info,  Node: SUM,  Next: SYMLNK,  Prev: STORAGE_SIZE,  Up: Intrinsic Procedures

9.262 'SUM' -- Sum of array elements
====================================

_Description_:
     Adds the elements of ARRAY along dimension DIM if the corresponding
     element in MASK is 'TRUE'.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = SUM(ARRAY[, MASK])'
     'RESULT = SUM(ARRAY, DIM[, MASK])'

_Arguments_:
     ARRAY       Shall be an array of type 'INTEGER', 'REAL' or
                 'COMPLEX'.
     DIM         (Optional) shall be a scalar of type 'INTEGER'
                 with a value in the range from 1 to n, where n
                 equals the rank of ARRAY.
     MASK        (Optional) shall be of type 'LOGICAL' and either
                 be a scalar or an array of the same shape as
                 ARRAY.

_Return value_:
     The result is of the same type as ARRAY.

     If DIM is absent, a scalar with the sum of all elements in ARRAY is
     returned.  Otherwise, an array of rank n-1, where n equals the rank
     of ARRAY, and a shape similar to that of ARRAY with dimension DIM
     dropped is returned.

_Example_:
          PROGRAM test_sum
            INTEGER :: x(5) = (/ 1, 2, 3, 4 ,5 /)
            print *, SUM(x)                        ! all elements, sum = 15
            print *, SUM(x, MASK=MOD(x, 2)==1)     ! odd elements, sum = 9
          END PROGRAM

_See also_:
     *note PRODUCT::


File: gfortran.info,  Node: SYMLNK,  Next: SYSTEM,  Prev: SUM,  Up: Intrinsic Procedures

9.263 'SYMLNK' -- Create a symbolic link
========================================

_Description_:
     Makes a symbolic link from file PATH1 to PATH2.  A null character
     ('CHAR(0)') can be used to mark the end of the names in PATH1 and
     PATH2; otherwise, trailing blanks in the file names are ignored.
     If the STATUS argument is supplied, it contains 0 on success or a
     nonzero error code upon return; see 'symlink(2)'.  If the system
     does not supply 'symlink(2)', 'ENOSYS' is returned.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL SYMLNK(PATH1, PATH2 [, STATUS])'
     'STATUS = SYMLNK(PATH1, PATH2)'

_Arguments_:
     PATH1       Shall be of default 'CHARACTER' type.
     PATH2       Shall be of default 'CHARACTER' type.
     STATUS      (Optional) Shall be of default 'INTEGER' type.

_See also_:
     *note LINK::, *note UNLINK::


File: gfortran.info,  Node: SYSTEM,  Next: SYSTEM_CLOCK,  Prev: SYMLNK,  Up: Intrinsic Procedures

9.264 'SYSTEM' -- Execute a shell command
=========================================

_Description_:
     Passes the command COMMAND to a shell (see 'system(3)').  If
     argument STATUS is present, it contains the value returned by
     'system(3)', which is presumably 0 if the shell command succeeded.
     Note that which shell is used to invoke the command is
     system-dependent and environment-dependent.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

     Note that the 'system' function need not be thread-safe.  It is the
     responsibility of the user to ensure that 'system' is not called
     concurrently.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL SYSTEM(COMMAND [, STATUS])'
     'STATUS = SYSTEM(COMMAND)'

_Arguments_:
     COMMAND     Shall be of default 'CHARACTER' type.
     STATUS      (Optional) Shall be of default 'INTEGER' type.

_See also_:
     *note EXECUTE_COMMAND_LINE::, which is part of the Fortran 2008
     standard and should considered in new code for future portability.


File: gfortran.info,  Node: SYSTEM_CLOCK,  Next: TAN,  Prev: SYSTEM,  Up: Intrinsic Procedures

9.265 'SYSTEM_CLOCK' -- Time function
=====================================

_Description_:
     Determines the COUNT of a processor clock since an unspecified time
     in the past modulo COUNT_MAX, COUNT_RATE determines the number of
     clock ticks per second.  If the platform supports a monotonic
     clock, that clock is used and can, depending on the platform clock
     implementation, provide up to nanosecond resolution.  If a
     monotonic clock is not available, the implementation falls back to
     a realtime clock.

     COUNT_RATE is system dependent and can vary depending on the kind
     of the arguments.  For KIND=4 arguments (and smaller integer
     kinds), COUNT represents milliseconds, while for KIND=8 arguments
     (and larger integer kinds), COUNT typically represents micro- or
     nanoseconds depending on resolution of the underlying platform
     clock.  COUNT_MAX usually equals 'HUGE(COUNT_MAX)'.  Note that the
     millisecond resolution of the KIND=4 version implies that the COUNT
     will wrap around in roughly 25 days.  In order to avoid issues with
     the wrap around and for more precise timing, please use the KIND=8
     version.

     If there is no clock, or querying the clock fails, COUNT is set to
     '-HUGE(COUNT)', and COUNT_RATE and COUNT_MAX are set to zero.

     When running on a platform using the GNU C library (glibc) version
     2.16 or older, or a derivative thereof, the high resolution
     monotonic clock is available only when linking with the RT library.
     This can be done explicitly by adding the '-lrt' flag when linking
     the application, but is also done implicitly when using OpenMP.

     On the Windows platform, the version with KIND=4 arguments uses the
     'GetTickCount' function, whereas the KIND=8 version uses
     'QueryPerformanceCounter' and 'QueryPerformanceCounterFrequency'.
     For more information, and potential caveats, please see the
     platform documentation.

_Standard_:
     Fortran 95 and later

_Class_:
     Subroutine

_Syntax_:
     'CALL SYSTEM_CLOCK([COUNT, COUNT_RATE, COUNT_MAX])'

_Arguments_:
     COUNT       (Optional) shall be a scalar of type 'INTEGER'
                 with 'INTENT(OUT)'.
     COUNT_RATE  (Optional) shall be a scalar of type 'INTEGER'
                 or 'REAL', with 'INTENT(OUT)'.
     COUNT_MAX   (Optional) shall be a scalar of type 'INTEGER'
                 with 'INTENT(OUT)'.

_Example_:
          PROGRAM test_system_clock
            INTEGER :: count, count_rate, count_max
            CALL SYSTEM_CLOCK(count, count_rate, count_max)
            WRITE(*,*) count, count_rate, count_max
          END PROGRAM

_See also_:
     *note DATE_AND_TIME::, *note CPU_TIME::


File: gfortran.info,  Node: TAN,  Next: TAND,  Prev: SYSTEM_CLOCK,  Up: Intrinsic Procedures

9.266 'TAN' -- Tangent function
===============================

_Description_:
     'TAN(X)' computes the tangent of X.

_Standard_:
     Fortran 77 and later, for a complex argument Fortran 2008 or later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = TAN(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value has same type and kind as X, and its value is in
     radians.

_Example_:
          program test_tan
            real(8) :: x = 0.165_8
            x = tan(x)
          end program test_tan

_Specific names_:
     Name           Argument       Return type    Standard
     'TAN(X)'       'REAL(4) X'    'REAL(4)'      Fortran 95 and
                                                  later
     'DTAN(X)'      'REAL(8) X'    'REAL(8)'      Fortran 95 and
                                                  later

_See also_:
     Inverse function: *note ATAN:: Degrees function: *note TAND::


File: gfortran.info,  Node: TAND,  Next: TANH,  Prev: TAN,  Up: Intrinsic Procedures

9.267 'TAND' -- Tangent function, degrees
=========================================

_Description_:
     'TAND(X)' computes the tangent of X in degrees.

     This function is for compatibility only and should be avoided in
     favor of standard constructs wherever possible.

_Standard_:
     GNU Extension, enabled with '-fdec-math'.

_Class_:
     Elemental function

_Syntax_:
     'RESULT = TAND(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value has same type and kind as X, and its value is in
     degrees.

_Example_:
          program test_tand
            real(8) :: x = 0.165_8
            x = tand(x)
          end program test_tand

_Specific names_:
     Name           Argument       Return type    Standard
     'TAND(X)'      'REAL(4) X'    'REAL(4)'      GNU Extension
     'DTAND(X)'     'REAL(8) X'    'REAL(8)'      GNU Extension

_See also_:
     Inverse function: *note ATAND:: Radians function: *note TAN::


File: gfortran.info,  Node: TANH,  Next: THIS_IMAGE,  Prev: TAND,  Up: Intrinsic Procedures

9.268 'TANH' -- Hyperbolic tangent function
===========================================

_Description_:
     'TANH(X)' computes the hyperbolic tangent of X.

_Standard_:
     Fortran 77 and later, for a complex argument Fortran 2008 or later

_Class_:
     Elemental function

_Syntax_:
     'X = TANH(X)'

_Arguments_:
     X           The type shall be 'REAL' or 'COMPLEX'.

_Return value_:
     The return value has same type and kind as X.  If X is complex, the
     imaginary part of the result is in radians.  If X is 'REAL', the
     return value lies in the range - 1 \leq tanh(x) \leq 1 .

_Example_:
          program test_tanh
            real(8) :: x = 2.1_8
            x = tanh(x)
          end program test_tanh

_Specific names_:
     Name           Argument       Return type    Standard
     'TANH(X)'      'REAL(4) X'    'REAL(4)'      Fortran 95 and
                                                  later
     'DTANH(X)'     'REAL(8) X'    'REAL(8)'      Fortran 95 and
                                                  later

_See also_:
     *note ATANH::


File: gfortran.info,  Node: THIS_IMAGE,  Next: TIME,  Prev: TANH,  Up: Intrinsic Procedures

9.269 'THIS_IMAGE' -- Function that returns the cosubscript index of this image
===============================================================================

_Description_:
     Returns the cosubscript for this image.

_Standard_:
     Fortran 2008 and later.  With DISTANCE argument, Technical
     Specification (TS) 18508 or later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = THIS_IMAGE()'
     'RESULT = THIS_IMAGE(DISTANCE)'
     'RESULT = THIS_IMAGE(COARRAY [, DIM])'

_Arguments_:
     DISTANCE    (optional, intent(in)) Nonnegative scalar
                 integer (not permitted together with COARRAY).
     COARRAY     Coarray of any type (optional; if DIM present,
                 required).
     DIM         default integer scalar (optional).  If present,
                 DIM shall be between one and the corank of
                 COARRAY.

_Return value_:
     Default integer.  If COARRAY is not present, it is scalar; if
     DISTANCE is not present or has value 0, its value is the image
     index on the invoking image for the current team, for values
     smaller or equal distance to the initial team, it returns the image
     index on the ancestor team which has a distance of DISTANCE from
     the invoking team.  If DISTANCE is larger than the distance to the
     initial team, the image index of the initial team is returned.
     Otherwise when the COARRAY is present, if DIM is not present, a
     rank-1 array with corank elements is returned, containing the
     cosubscripts for COARRAY specifying the invoking image.  If DIM is
     present, a scalar is returned, with the value of the DIM element of
     'THIS_IMAGE(COARRAY)'.

_Example_:
          INTEGER :: value[*]
          INTEGER :: i
          value = THIS_IMAGE()
          SYNC ALL
          IF (THIS_IMAGE() == 1) THEN
            DO i = 1, NUM_IMAGES()
              WRITE(*,'(2(a,i0))') 'value[', i, '] is ', value[i]
            END DO
          END IF

          ! Check whether the current image is the initial image
          IF (THIS_IMAGE(HUGE(1)) /= THIS_IMAGE())
            error stop "something is rotten here"

_See also_:
     *note NUM_IMAGES::, *note IMAGE_INDEX::


File: gfortran.info,  Node: TIME,  Next: TIME8,  Prev: THIS_IMAGE,  Up: Intrinsic Procedures

9.270 'TIME' -- Time function
=============================

_Description_:
     Returns the current time encoded as an integer (in the manner of
     the function 'time(3)' in the C standard library).  This value is
     suitable for passing to *note CTIME::, *note GMTIME::, and *note
     LTIME::.

     This intrinsic is not fully portable, such as to systems with
     32-bit 'INTEGER' types but supporting times wider than 32 bits.
     Therefore, the values returned by this intrinsic might be, or
     become, negative, or numerically less than previous values, during
     a single run of the compiled program.

     See *note TIME8::, for information on a similar intrinsic that
     might be portable to more GNU Fortran implementations, though to
     fewer Fortran compilers.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = TIME()'

_Return value_:
     The return value is a scalar of type 'INTEGER(4)'.

_See also_:
     *note DATE_AND_TIME::, *note CTIME::, *note GMTIME::, *note
     LTIME::, *note MCLOCK::, *note TIME8::


File: gfortran.info,  Node: TIME8,  Next: TINY,  Prev: TIME,  Up: Intrinsic Procedures

9.271 'TIME8' -- Time function (64-bit)
=======================================

_Description_:
     Returns the current time encoded as an integer (in the manner of
     the function 'time(3)' in the C standard library).  This value is
     suitable for passing to *note CTIME::, *note GMTIME::, and *note
     LTIME::.

     _Warning:_ this intrinsic does not increase the range of the timing
     values over that returned by 'time(3)'.  On a system with a 32-bit
     'time(3)', 'TIME8' will return a 32-bit value, even though it is
     converted to a 64-bit 'INTEGER(8)' value.  That means overflows of
     the 32-bit value can still occur.  Therefore, the values returned
     by this intrinsic might be or become negative or numerically less
     than previous values during a single run of the compiled program.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = TIME8()'

_Return value_:
     The return value is a scalar of type 'INTEGER(8)'.

_See also_:
     *note DATE_AND_TIME::, *note CTIME::, *note GMTIME::, *note
     LTIME::, *note MCLOCK8::, *note TIME::


File: gfortran.info,  Node: TINY,  Next: TRAILZ,  Prev: TIME8,  Up: Intrinsic Procedures

9.272 'TINY' -- Smallest positive number of a real kind
=======================================================

_Description_:
     'TINY(X)' returns the smallest positive (non zero) number in the
     model of the type of 'X'.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = TINY(X)'

_Arguments_:
     X           Shall be of type 'REAL'.

_Return value_:
     The return value is of the same type and kind as X

_Example_:
     See 'HUGE' for an example.


File: gfortran.info,  Node: TRAILZ,  Next: TRANSFER,  Prev: TINY,  Up: Intrinsic Procedures

9.273 'TRAILZ' -- Number of trailing zero bits of an integer
============================================================

_Description_:
     'TRAILZ' returns the number of trailing zero bits of an integer.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = TRAILZ(I)'

_Arguments_:
     I           Shall be of type 'INTEGER'.

_Return value_:
     The type of the return value is the default 'INTEGER'.  If all the
     bits of 'I' are zero, the result value is 'BIT_SIZE(I)'.

_Example_:
          PROGRAM test_trailz
            WRITE (*,*) TRAILZ(8)  ! prints 3
          END PROGRAM

_See also_:
     *note BIT_SIZE::, *note LEADZ::, *note POPPAR::, *note POPCNT::


File: gfortran.info,  Node: TRANSFER,  Next: TRANSPOSE,  Prev: TRAILZ,  Up: Intrinsic Procedures

9.274 'TRANSFER' -- Transfer bit patterns
=========================================

_Description_:
     Interprets the bitwise representation of SOURCE in memory as if it
     is the representation of a variable or array of the same type and
     type parameters as MOLD.

     This is approximately equivalent to the C concept of _casting_ one
     type to another.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = TRANSFER(SOURCE, MOLD[, SIZE])'

_Arguments_:
     SOURCE      Shall be a scalar or an array of any type.
     MOLD        Shall be a scalar or an array of any type.
     SIZE        (Optional) shall be a scalar of type 'INTEGER'.

_Return value_:
     The result has the same type as MOLD, with the bit level
     representation of SOURCE.  If SIZE is present, the result is a
     one-dimensional array of length SIZE.  If SIZE is absent but MOLD
     is an array (of any size or shape), the result is a one-
     dimensional array of the minimum length needed to contain the
     entirety of the bitwise representation of SOURCE.  If SIZE is
     absent and MOLD is a scalar, the result is a scalar.

     If the bitwise representation of the result is longer than that of
     SOURCE, then the leading bits of the result correspond to those of
     SOURCE and any trailing bits are filled arbitrarily.

     When the resulting bit representation does not correspond to a
     valid representation of a variable of the same type as MOLD, the
     results are undefined, and subsequent operations on the result
     cannot be guaranteed to produce sensible behavior.  For example, it
     is possible to create 'LOGICAL' variables for which 'VAR' and
     '.NOT.VAR' both appear to be true.

_Example_:
          PROGRAM test_transfer
            integer :: x = 2143289344
            print *, transfer(x, 1.0)    ! prints "NaN" on i686
          END PROGRAM


File: gfortran.info,  Node: TRANSPOSE,  Next: TRIM,  Prev: TRANSFER,  Up: Intrinsic Procedures

9.275 'TRANSPOSE' -- Transpose an array of rank two
===================================================

_Description_:
     Transpose an array of rank two.  Element (i, j) of the result has
     the value 'MATRIX(j, i)', for all i, j.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = TRANSPOSE(MATRIX)'

_Arguments_:
     MATRIX      Shall be an array of any type and have a rank of
                 two.

_Return value_:
     The result has the same type as MATRIX, and has shape '(/ m, n /)'
     if MATRIX has shape '(/ n, m /)'.


File: gfortran.info,  Node: TRIM,  Next: TTYNAM,  Prev: TRANSPOSE,  Up: Intrinsic Procedures

9.276 'TRIM' -- Remove trailing blank characters of a string
============================================================

_Description_:
     Removes trailing blank characters of a string.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = TRIM(STRING)'

_Arguments_:
     STRING      Shall be a scalar of type 'CHARACTER'.

_Return value_:
     A scalar of type 'CHARACTER' which length is that of STRING less
     the number of trailing blanks.

_Example_:
          PROGRAM test_trim
            CHARACTER(len=10), PARAMETER :: s = "GFORTRAN  "
            WRITE(*,*) LEN(s), LEN(TRIM(s))  ! "10 8", with/without trailing blanks
          END PROGRAM

_See also_:
     *note ADJUSTL::, *note ADJUSTR::


File: gfortran.info,  Node: TTYNAM,  Next: UBOUND,  Prev: TRIM,  Up: Intrinsic Procedures

9.277 'TTYNAM' -- Get the name of a terminal device.
====================================================

_Description_:
     Get the name of a terminal device.  For more information, see
     'ttyname(3)'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL TTYNAM(UNIT, NAME)'
     'NAME = TTYNAM(UNIT)'

_Arguments_:
     UNIT        Shall be a scalar 'INTEGER'.
     NAME        Shall be of type 'CHARACTER'.

_Example_:
          PROGRAM test_ttynam
            INTEGER :: unit
            DO unit = 1, 10
              IF (isatty(unit=unit)) write(*,*) ttynam(unit)
            END DO
          END PROGRAM

_See also_:
     *note ISATTY::


File: gfortran.info,  Node: UBOUND,  Next: UCOBOUND,  Prev: TTYNAM,  Up: Intrinsic Procedures

9.278 'UBOUND' -- Upper dimension bounds of an array
====================================================

_Description_:
     Returns the upper bounds of an array, or a single upper bound along
     the DIM dimension.
_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = UBOUND(ARRAY [, DIM [, KIND]])'

_Arguments_:
     ARRAY       Shall be an array, of any type.
     DIM         (Optional) Shall be a scalar 'INTEGER'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER' and of kind KIND.  If KIND is
     absent, the return value is of default integer kind.  If DIM is
     absent, the result is an array of the upper bounds of ARRAY.  If
     DIM is present, the result is a scalar corresponding to the upper
     bound of the array along that dimension.  If ARRAY is an expression
     rather than a whole array or array structure component, or if it
     has a zero extent along the relevant dimension, the upper bound is
     taken to be the number of elements along the relevant dimension.

_See also_:
     *note LBOUND::, *note LCOBOUND::


File: gfortran.info,  Node: UCOBOUND,  Next: UMASK,  Prev: UBOUND,  Up: Intrinsic Procedures

9.279 'UCOBOUND' -- Upper codimension bounds of an array
========================================================

_Description_:
     Returns the upper cobounds of a coarray, or a single upper cobound
     along the DIM codimension.
_Standard_:
     Fortran 2008 and later

_Class_:
     Inquiry function

_Syntax_:
     'RESULT = UCOBOUND(COARRAY [, DIM [, KIND]])'

_Arguments_:
     ARRAY       Shall be an coarray, of any type.
     DIM         (Optional) Shall be a scalar 'INTEGER'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER' and of kind KIND.  If KIND is
     absent, the return value is of default integer kind.  If DIM is
     absent, the result is an array of the lower cobounds of COARRAY.
     If DIM is present, the result is a scalar corresponding to the
     lower cobound of the array along that codimension.

_See also_:
     *note LCOBOUND::, *note LBOUND::


File: gfortran.info,  Node: UMASK,  Next: UNLINK,  Prev: UCOBOUND,  Up: Intrinsic Procedures

9.280 'UMASK' -- Set the file creation mask
===========================================

_Description_:
     Sets the file creation mask to MASK.  If called as a function, it
     returns the old value.  If called as a subroutine and argument OLD
     if it is supplied, it is set to the old value.  See 'umask(2)'.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL UMASK(MASK [, OLD])'
     'OLD = UMASK(MASK)'

_Arguments_:
     MASK        Shall be a scalar of type 'INTEGER'.
     OLD         (Optional) Shall be a scalar of type 'INTEGER'.


File: gfortran.info,  Node: UNLINK,  Next: UNPACK,  Prev: UMASK,  Up: Intrinsic Procedures

9.281 'UNLINK' -- Remove a file from the file system
====================================================

_Description_:
     Unlinks the file PATH.  A null character ('CHAR(0)') can be used to
     mark the end of the name in PATH; otherwise, trailing blanks in the
     file name are ignored.  If the STATUS argument is supplied, it
     contains 0 on success or a nonzero error code upon return; see
     'unlink(2)'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     'CALL UNLINK(PATH [, STATUS])'
     'STATUS = UNLINK(PATH)'

_Arguments_:
     PATH        Shall be of default 'CHARACTER' type.
     STATUS      (Optional) Shall be of default 'INTEGER' type.

_See also_:
     *note LINK::, *note SYMLNK::


File: gfortran.info,  Node: UNPACK,  Next: VERIFY,  Prev: UNLINK,  Up: Intrinsic Procedures

9.282 'UNPACK' -- Unpack an array of rank one into an array
===========================================================

_Description_:
     Store the elements of VECTOR in an array of higher rank.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     'RESULT = UNPACK(VECTOR, MASK, FIELD)'

_Arguments_:
     VECTOR      Shall be an array of any type and rank one.  It
                 shall have at least as many elements as MASK has
                 'TRUE' values.
     MASK        Shall be an array of type 'LOGICAL'.
     FIELD       Shall be of the same type as VECTOR and have the
                 same shape as MASK.

_Return value_:
     The resulting array corresponds to FIELD with 'TRUE' elements of
     MASK replaced by values from VECTOR in array element order.

_Example_:
          PROGRAM test_unpack
            integer :: vector(2)  = (/1,1/)
            logical :: mask(4)  = (/ .TRUE., .FALSE., .FALSE., .TRUE. /)
            integer :: field(2,2) = 0, unity(2,2)

            ! result: unity matrix
            unity = unpack(vector, reshape(mask, (/2,2/)), field)
          END PROGRAM

_See also_:
     *note PACK::, *note SPREAD::


File: gfortran.info,  Node: VERIFY,  Next: XOR,  Prev: UNPACK,  Up: Intrinsic Procedures

9.283 'VERIFY' -- Scan a string for characters not a given set
==============================================================

_Description_:
     Verifies that all the characters in STRING belong to the set of
     characters in SET.

     If BACK is either absent or equals 'FALSE', this function returns
     the position of the leftmost character of STRING that is not in
     SET.  If BACK equals 'TRUE', the rightmost position is returned.
     If all characters of STRING are found in SET, the result is zero.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     'RESULT = VERIFY(STRING, SET[, BACK [, KIND]])'

_Arguments_:
     STRING      Shall be of type 'CHARACTER'.
     SET         Shall be of type 'CHARACTER'.
     BACK        (Optional) shall be of type 'LOGICAL'.
     KIND        (Optional) An 'INTEGER' initialization
                 expression indicating the kind parameter of the
                 result.

_Return value_:
     The return value is of type 'INTEGER' and of kind KIND.  If KIND is
     absent, the return value is of default integer kind.

_Example_:
          PROGRAM test_verify
            WRITE(*,*) VERIFY("FORTRAN", "AO")           ! 1, found 'F'
            WRITE(*,*) VERIFY("FORTRAN", "FOO")          ! 3, found 'R'
            WRITE(*,*) VERIFY("FORTRAN", "C++")          ! 1, found 'F'
            WRITE(*,*) VERIFY("FORTRAN", "C++", .TRUE.)  ! 7, found 'N'
            WRITE(*,*) VERIFY("FORTRAN", "FORTRAN")      ! 0' found none
          END PROGRAM

_See also_:
     *note SCAN::, *note INDEX intrinsic::


File: gfortran.info,  Node: XOR,  Prev: VERIFY,  Up: Intrinsic Procedures

9.284 'XOR' -- Bitwise logical exclusive OR
===========================================

_Description_:
     Bitwise logical exclusive or.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  For integer arguments, programmers should consider
     the use of the *note IEOR:: intrinsic and for logical arguments the
     '.NEQV.' operator, which are both defined by the Fortran standard.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     'RESULT = XOR(I, J)'

_Arguments_:
     I           The type shall be either a scalar 'INTEGER' type
                 or a scalar 'LOGICAL' type or a
                 boz-literal-constant.
     J           The type shall be the same as the type of I or a
                 boz-literal-constant.  I and J shall not both be
                 boz-literal-constants.  If either I and J is a
                 boz-literal-constant, then the other argument
                 must be a scalar 'INTEGER'.

_Return value_:
     The return type is either a scalar 'INTEGER' or a scalar 'LOGICAL'.
     If the kind type parameters differ, then the smaller kind type is
     implicitly converted to larger kind, and the return has the larger
     kind.  A boz-literal-constant is converted to an 'INTEGER' with the
     kind type parameter of the other argument as-if a call to *note
     INT:: occurred.

_Example_:
          PROGRAM test_xor
            LOGICAL :: T = .TRUE., F = .FALSE.
            INTEGER :: a, b
            DATA a / Z'F' /, b / Z'3' /

            WRITE (*,*) XOR(T, T), XOR(T, F), XOR(F, T), XOR(F, F)
            WRITE (*,*) XOR(a, b)
          END PROGRAM

_See also_:
     Fortran 95 elemental function: *note IEOR::


File: gfortran.info,  Node: Intrinsic Modules,  Next: Contributing,  Prev: Intrinsic Procedures,  Up: Top

10 Intrinsic Modules
********************

* Menu:

* ISO_FORTRAN_ENV::
* ISO_C_BINDING::
* IEEE modules::
* OpenMP Modules OMP_LIB and OMP_LIB_KINDS::
* OpenACC Module OPENACC::


File: gfortran.info,  Node: ISO_FORTRAN_ENV,  Next: ISO_C_BINDING,  Up: Intrinsic Modules

10.1 'ISO_FORTRAN_ENV'
======================

_Standard_:
     Fortran 2003 and later, except when otherwise noted

   The 'ISO_FORTRAN_ENV' module provides the following scalar
default-integer named constants:

'ATOMIC_INT_KIND':
     Default-kind integer constant to be used as kind parameter when
     defining integer variables used in atomic operations.  (Fortran
     2008 or later.)

'ATOMIC_LOGICAL_KIND':
     Default-kind integer constant to be used as kind parameter when
     defining logical variables used in atomic operations.  (Fortran
     2008 or later.)

'CHARACTER_KINDS':
     Default-kind integer constant array of rank one containing the
     supported kind parameters of the 'CHARACTER' type.  (Fortran 2008
     or later.)

'CHARACTER_STORAGE_SIZE':
     Size in bits of the character storage unit.

'ERROR_UNIT':
     Identifies the preconnected unit used for error reporting.

'FILE_STORAGE_SIZE':
     Size in bits of the file-storage unit.

'INPUT_UNIT':
     Identifies the preconnected unit identified by the asterisk ('*')
     in 'READ' statement.

'INT8', 'INT16', 'INT32', 'INT64':
     Kind type parameters to specify an INTEGER type with a storage size
     of 16, 32, and 64 bits.  It is negative if a target platform does
     not support the particular kind.  (Fortran 2008 or later.)

'INTEGER_KINDS':
     Default-kind integer constant array of rank one containing the
     supported kind parameters of the 'INTEGER' type.  (Fortran 2008 or
     later.)

'IOSTAT_END':
     The value assigned to the variable passed to the 'IOSTAT='
     specifier of an input/output statement if an end-of-file condition
     occurred.

'IOSTAT_EOR':
     The value assigned to the variable passed to the 'IOSTAT='
     specifier of an input/output statement if an end-of-record
     condition occurred.

'IOSTAT_INQUIRE_INTERNAL_UNIT':
     Scalar default-integer constant, used by 'INQUIRE' for the
     'IOSTAT=' specifier to denote an that a unit number identifies an
     internal unit.  (Fortran 2008 or later.)

'NUMERIC_STORAGE_SIZE':
     The size in bits of the numeric storage unit.

'LOGICAL_KINDS':
     Default-kind integer constant array of rank one containing the
     supported kind parameters of the 'LOGICAL' type.  (Fortran 2008 or
     later.)

'OUTPUT_UNIT':
     Identifies the preconnected unit identified by the asterisk ('*')
     in 'WRITE' statement.

'REAL32', 'REAL64', 'REAL128':
     Kind type parameters to specify a REAL type with a storage size of
     32, 64, and 128 bits.  It is negative if a target platform does not
     support the particular kind.  (Fortran 2008 or later.)

'REAL_KINDS':
     Default-kind integer constant array of rank one containing the
     supported kind parameters of the 'REAL' type.  (Fortran 2008 or
     later.)

'STAT_LOCKED':
     Scalar default-integer constant used as STAT= return value by
     'LOCK' to denote that the lock variable is locked by the executing
     image.  (Fortran 2008 or later.)

'STAT_LOCKED_OTHER_IMAGE':
     Scalar default-integer constant used as STAT= return value by
     'UNLOCK' to denote that the lock variable is locked by another
     image.  (Fortran 2008 or later.)

'STAT_STOPPED_IMAGE':
     Positive, scalar default-integer constant used as STAT= return
     value if the argument in the statement requires synchronisation
     with an image, which has initiated the termination of the
     execution.  (Fortran 2008 or later.)

'STAT_FAILED_IMAGE':
     Positive, scalar default-integer constant used as STAT= return
     value if the argument in the statement requires communication with
     an image, which has is in the failed state.  (TS 18508 or later.)

'STAT_UNLOCKED':
     Scalar default-integer constant used as STAT= return value by
     'UNLOCK' to denote that the lock variable is unlocked.  (Fortran
     2008 or later.)

   The module provides the following derived type:

'LOCK_TYPE':
     Derived type with private components to be use with the 'LOCK' and
     'UNLOCK' statement.  A variable of its type has to be always
     declared as coarray and may not appear in a variable-definition
     context.  (Fortran 2008 or later.)

   The module also provides the following intrinsic procedures: *note
COMPILER_OPTIONS:: and *note COMPILER_VERSION::.


File: gfortran.info,  Node: ISO_C_BINDING,  Next: IEEE modules,  Prev: ISO_FORTRAN_ENV,  Up: Intrinsic Modules

10.2 'ISO_C_BINDING'
====================

_Standard_:
     Fortran 2003 and later, GNU extensions

   The following intrinsic procedures are provided by the module; their
definition can be found in the section Intrinsic Procedures of this
manual.

'C_ASSOCIATED'
'C_F_POINTER'
'C_F_PROCPOINTER'
'C_FUNLOC'
'C_LOC'
'C_SIZEOF'

   The 'ISO_C_BINDING' module provides the following named constants of
type default integer, which can be used as KIND type parameters.

   In addition to the integer named constants required by the Fortran
2003 standard and 'C_PTRDIFF_T' of TS 29113, GNU Fortran provides as an
extension named constants for the 128-bit integer types supported by the
C compiler: 'C_INT128_T, C_INT_LEAST128_T, C_INT_FAST128_T'.
Furthermore, if '__float128' is supported in C, the named constants
'C_FLOAT128, C_FLOAT128_COMPLEX' are defined.

Fortran     Named constant            C type                    Extension
Type
'INTEGER'   'C_INT'                   'int'
'INTEGER'   'C_SHORT'                 'short int'
'INTEGER'   'C_LONG'                  'long int'
'INTEGER'   'C_LONG_LONG'             'long long int'
'INTEGER'   'C_SIGNED_CHAR'           'signed char'/'unsigned
                                      char'
'INTEGER'   'C_SIZE_T'                'size_t'
'INTEGER'   'C_INT8_T'                'int8_t'
'INTEGER'   'C_INT16_T'               'int16_t'
'INTEGER'   'C_INT32_T'               'int32_t'
'INTEGER'   'C_INT64_T'               'int64_t'
'INTEGER'   'C_INT128_T'              'int128_t'                Ext.
'INTEGER'   'C_INT_LEAST8_T'          'int_least8_t'
'INTEGER'   'C_INT_LEAST16_T'         'int_least16_t'
'INTEGER'   'C_INT_LEAST32_T'         'int_least32_t'
'INTEGER'   'C_INT_LEAST64_T'         'int_least64_t'
'INTEGER'   'C_INT_LEAST128_T'        'int_least128_t'          Ext.
'INTEGER'   'C_INT_FAST8_T'           'int_fast8_t'
'INTEGER'   'C_INT_FAST16_T'          'int_fast16_t'
'INTEGER'   'C_INT_FAST32_T'          'int_fast32_t'
'INTEGER'   'C_INT_FAST64_T'          'int_fast64_t'
'INTEGER'   'C_INT_FAST128_T'         'int_fast128_t'           Ext.
'INTEGER'   'C_INTMAX_T'              'intmax_t'
'INTEGER'   'C_INTPTR_T'              'intptr_t'
'INTEGER'   'C_PTRDIFF_T'             'ptrdiff_t'               TS 29113
'REAL'      'C_FLOAT'                 'float'
'REAL'      'C_DOUBLE'                'double'
'REAL'      'C_LONG_DOUBLE'           'long double'
'REAL'      'C_FLOAT128'              '__float128'              Ext.
'COMPLEX'   'C_FLOAT_COMPLEX'         'float _Complex'
'COMPLEX'   'C_DOUBLE_COMPLEX'        'double _Complex'
'COMPLEX'   'C_LONG_DOUBLE_COMPLEX'   'long double _Complex'
'REAL'      'C_FLOAT128_COMPLEX'      '__float128 _Complex'     Ext.
'LOGICAL'   'C_BOOL'                  '_Bool'
'CHARACTER' 'C_CHAR'                  'char'

   Additionally, the following parameters of type
'CHARACTER(KIND=C_CHAR)' are defined.

Name           C definition                     Value
'C_NULL_CHAR'  null character                   ''\0''
'C_ALERT'      alert                            ''\a''
'C_BACKSPACE'  backspace                        ''\b''
'C_FORM_FEED'  form feed                        ''\f''
'C_NEW_LINE'   new line                         ''\n''
'C_CARRIAGE_RETURN'carriage return              ''\r''
'C_HORIZONTAL_TAB'horizontal tab                ''\t''
'C_VERTICAL_TAB'vertical tab                    ''\v''

   Moreover, the following two named constants are defined:

Name           Type
'C_NULL_PTR'   'C_PTR'
'C_NULL_FUNPTR''C_FUNPTR'

   Both are equivalent to the value 'NULL' in C.


File: gfortran.info,  Node: IEEE modules,  Next: OpenMP Modules OMP_LIB and OMP_LIB_KINDS,  Prev: ISO_C_BINDING,  Up: Intrinsic Modules

10.3 IEEE modules: 'IEEE_EXCEPTIONS', 'IEEE_ARITHMETIC', and 'IEEE_FEATURES'
============================================================================

_Standard_:
     Fortran 2003 and later

   The 'IEEE_EXCEPTIONS', 'IEEE_ARITHMETIC', and 'IEEE_FEATURES'
intrinsic modules provide support for exceptions and IEEE arithmetic, as
defined in Fortran 2003 and later standards, and the IEC 60559:1989
standard (_Binary floating-point arithmetic for microprocessor
systems_).  These modules are only provided on the following supported
platforms:

   * i386 and x86_64 processors
   * platforms which use the GNU C Library (glibc)
   * platforms with support for SysV/386 routines for floating point
     interface (including Solaris and BSDs)
   * platforms with the AIX OS

   For full compliance with the Fortran standards, code using the
'IEEE_EXCEPTIONS' or 'IEEE_ARITHMETIC' modules should be compiled with
the following options: '-fno-unsafe-math-optimizations -frounding-math
-fsignaling-nans'.


File: gfortran.info,  Node: OpenMP Modules OMP_LIB and OMP_LIB_KINDS,  Next: OpenACC Module OPENACC,  Prev: IEEE modules,  Up: Intrinsic Modules

10.4 OpenMP Modules 'OMP_LIB' and 'OMP_LIB_KINDS'
=================================================

_Standard_:
     OpenMP Application Program Interface v4.5

   The OpenMP Fortran runtime library routines are provided both in a
form of two Fortran 90 modules, named 'OMP_LIB' and 'OMP_LIB_KINDS', and
in a form of a Fortran 'include' file named 'omp_lib.h'.  The procedures
provided by 'OMP_LIB' can be found in the *note Introduction:
(libgomp)Top. manual, the named constants defined in the modules are
listed below.

   For details refer to the actual OpenMP Application Program Interface
v4.5 (http://www.openmp.org/wp-content/uploads/openmp-4.5.pdf).

   'OMP_LIB_KINDS' provides the following scalar default-integer named
constants:

'omp_lock_kind'
'omp_nest_lock_kind'
'omp_proc_bind_kind'
'omp_sched_kind'

   'OMP_LIB' provides the scalar default-integer named constant
'openmp_version' with a value of the form YYYYMM, where 'yyyy' is the
year and MM the month of the OpenMP version; for OpenMP v4.5 the value
is '201511'.

   The following scalar integer named constants of the kind
'omp_sched_kind':

'omp_sched_static'
'omp_sched_dynamic'
'omp_sched_guided'
'omp_sched_auto'

   And the following scalar integer named constants of the kind
'omp_proc_bind_kind':

'omp_proc_bind_false'
'omp_proc_bind_true'
'omp_proc_bind_master'
'omp_proc_bind_close'
'omp_proc_bind_spread'


File: gfortran.info,  Node: OpenACC Module OPENACC,  Prev: OpenMP Modules OMP_LIB and OMP_LIB_KINDS,  Up: Intrinsic Modules

10.5 OpenACC Module 'OPENACC'
=============================

_Standard_:
     OpenACC Application Programming Interface v2.0

   The OpenACC Fortran runtime library routines are provided both in a
form of a Fortran 90 module, named 'OPENACC', and in form of a Fortran
'include' file named 'openacc_lib.h'.  The procedures provided by
'OPENACC' can be found in the *note Introduction: (libgomp)Top. manual,
the named constants defined in the modules are listed below.

   For details refer to the actual OpenACC Application Programming
Interface v2.0 (http://www.openacc.org/).

   'OPENACC' provides the scalar default-integer named constant
'openacc_version' with a value of the form YYYYMM, where 'yyyy' is the
year and MM the month of the OpenACC version; for OpenACC v2.0 the value
is '201306'.


File: gfortran.info,  Node: Contributing,  Next: Copying,  Prev: Intrinsic Modules,  Up: Top

Contributing
************

Free software is only possible if people contribute to efforts to create
it.  We're always in need of more people helping out with ideas and
comments, writing documentation and contributing code.

   If you want to contribute to GNU Fortran, have a look at the long
lists of projects you can take on.  Some of these projects are small,
some of them are large; some are completely orthogonal to the rest of
what is happening on GNU Fortran, but others are "mainstream" projects
in need of enthusiastic hackers.  All of these projects are important!
We will eventually get around to the things here, but they are also
things doable by someone who is willing and able.

* Menu:

* Contributors::
* Projects::
* Proposed Extensions::


File: gfortran.info,  Node: Contributors,  Next: Projects,  Up: Contributing

Contributors to GNU Fortran
===========================

Most of the parser was hand-crafted by _Andy Vaught_, who is also the
initiator of the whole project.  Thanks Andy!  Most of the interface
with GCC was written by _Paul Brook_.

   The following individuals have contributed code and/or ideas and
significant help to the GNU Fortran project (in alphabetical order):

   - Janne Blomqvist
   - Steven Bosscher
   - Paul Brook
   - Tobias Burnus
   - Franc,ois-Xavier Coudert
   - Bud Davis
   - Jerry DeLisle
   - Erik Edelmann
   - Bernhard Fischer
   - Daniel Franke
   - Richard Guenther
   - Richard Henderson
   - Katherine Holcomb
   - Jakub Jelinek
   - Niels Kristian Bech Jensen
   - Steven Johnson
   - Steven G. Kargl
   - Thomas Koenig
   - Asher Langton
   - H. J. Lu
   - Toon Moene
   - Brooks Moses
   - Andrew Pinski
   - Tim Prince
   - Christopher D. Rickett
   - Richard Sandiford
   - Tobias Schlu"ter
   - Roger Sayle
   - Paul Thomas
   - Andy Vaught
   - Feng Wang
   - Janus Weil
   - Daniel Kraft

   The following people have contributed bug reports, smaller or larger
patches, and much needed feedback and encouragement for the GNU Fortran
project:

   - Bill Clodius
   - Dominique d'Humie`res
   - Kate Hedstrom
   - Erik Schnetter
   - Joost VandeVondele

   Many other individuals have helped debug, test and improve the GNU
Fortran compiler over the past few years, and we welcome you to do the
same!  If you already have done so, and you would like to see your name
listed in the list above, please contact us.


File: gfortran.info,  Node: Projects,  Next: Proposed Extensions,  Prev: Contributors,  Up: Contributing

Projects
========

_Help build the test suite_
     Solicit more code for donation to the test suite: the more
     extensive the testsuite, the smaller the risk of breaking things in
     the future!  We can keep code private on request.

_Bug hunting/squishing_
     Find bugs and write more test cases!  Test cases are especially
     very welcome, because it allows us to concentrate on fixing bugs
     instead of isolating them.  Going through the bugzilla database at
     <https://gcc.gnu.org/bugzilla/> to reduce testcases posted there
     and add more information (for example, for which version does the
     testcase work, for which versions does it fail?)  is also very
     helpful.


File: gfortran.info,  Node: Proposed Extensions,  Prev: Projects,  Up: Contributing

Proposed Extensions
===================

Here's a list of proposed extensions for the GNU Fortran compiler, in no
particular order.  Most of these are necessary to be fully compatible
with existing Fortran compilers, but they are not part of the official
J3 Fortran 95 standard.

Compiler extensions:
--------------------

   * User-specified alignment rules for structures.

   * Automatically extend single precision constants to double.

   * Compile code that conserves memory by dynamically allocating common
     and module storage either on stack or heap.

   * Compile flag to generate code for array conformance checking
     (suggest -CC).

   * User control of symbol names (underscores, etc).

   * Compile setting for maximum size of stack frame size before
     spilling parts to static or heap.

   * Flag to force local variables into static space.

   * Flag to force local variables onto stack.

Environment Options
-------------------

   * Pluggable library modules for random numbers, linear algebra.  LA
     should use BLAS calling conventions.

   * Environment variables controlling actions on arithmetic exceptions
     like overflow, underflow, precision loss--Generate NaN, abort,
     default.  action.

   * Set precision for fp units that support it (i387).

   * Variable for setting fp rounding mode.

   * Variable to fill uninitialized variables with a user-defined bit
     pattern.

   * Environment variable controlling filename that is opened for that
     unit number.

   * Environment variable to clear/trash memory being freed.

   * Environment variable to control tracing of allocations and frees.

   * Environment variable to display allocated memory at normal program
     end.

   * Environment variable for filename for * IO-unit.

   * Environment variable for temporary file directory.

   * Environment variable forcing standard output to be line buffered
     (Unix).


File: gfortran.info,  Node: Copying,  Next: GNU Free Documentation License,  Prev: Contributing,  Up: Top

GNU General Public License
**************************

                        Version 3, 29 June 2007

     Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies of this
     license document, but changing it is not allowed.

Preamble
========

The GNU General Public License is a free, copyleft license for software
and other kinds of works.

   The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program-to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

   To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

   Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

   For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

   Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

   Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

   The precise terms and conditions for copying, distribution and
modification follow.

TERMS AND CONDITIONS
====================

  0. Definitions.

     "This License" refers to version 3 of the GNU General Public
     License.

     "Copyright" also means copyright-like laws that apply to other
     kinds of works, such as semiconductor masks.

     "The Program" refers to any copyrightable work licensed under this
     License.  Each licensee is addressed as "you".  "Licensees" and
     "recipients" may be individuals or organizations.

     To "modify" a work means to copy from or adapt all or part of the
     work in a fashion requiring copyright permission, other than the
     making of an exact copy.  The resulting work is called a "modified
     version" of the earlier work or a work "based on" the earlier work.

     A "covered work" means either the unmodified Program or a work
     based on the Program.

     To "propagate" a work means to do anything with it that, without
     permission, would make you directly or secondarily liable for
     infringement under applicable copyright law, except executing it on
     a computer or modifying a private copy.  Propagation includes
     copying, distribution (with or without modification), making
     available to the public, and in some countries other activities as
     well.

     To "convey" a work means any kind of propagation that enables other
     parties to make or receive copies.  Mere interaction with a user
     through a computer network, with no transfer of a copy, is not
     conveying.

     An interactive user interface displays "Appropriate Legal Notices"
     to the extent that it includes a convenient and prominently visible
     feature that (1) displays an appropriate copyright notice, and (2)
     tells the user that there is no warranty for the work (except to
     the extent that warranties are provided), that licensees may convey
     the work under this License, and how to view a copy of this
     License.  If the interface presents a list of user commands or
     options, such as a menu, a prominent item in the list meets this
     criterion.

  1. Source Code.

     The "source code" for a work means the preferred form of the work
     for making modifications to it.  "Object code" means any non-source
     form of a work.

     A "Standard Interface" means an interface that either is an
     official standard defined by a recognized standards body, or, in
     the case of interfaces specified for a particular programming
     language, one that is widely used among developers working in that
     language.

     The "System Libraries" of an executable work include anything,
     other than the work as a whole, that (a) is included in the normal
     form of packaging a Major Component, but which is not part of that
     Major Component, and (b) serves only to enable use of the work with
     that Major Component, or to implement a Standard Interface for
     which an implementation is available to the public in source code
     form.  A "Major Component", in this context, means a major
     essential component (kernel, window system, and so on) of the
     specific operating system (if any) on which the executable work
     runs, or a compiler used to produce the work, or an object code
     interpreter used to run it.

     The "Corresponding Source" for a work in object code form means all
     the source code needed to generate, install, and (for an executable
     work) run the object code and to modify the work, including scripts
     to control those activities.  However, it does not include the
     work's System Libraries, or general-purpose tools or generally
     available free programs which are used unmodified in performing
     those activities but which are not part of the work.  For example,
     Corresponding Source includes interface definition files associated
     with source files for the work, and the source code for shared
     libraries and dynamically linked subprograms that the work is
     specifically designed to require, such as by intimate data
     communication or control flow between those subprograms and other
     parts of the work.

     The Corresponding Source need not include anything that users can
     regenerate automatically from other parts of the Corresponding
     Source.

     The Corresponding Source for a work in source code form is that
     same work.

  2. Basic Permissions.

     All rights granted under this License are granted for the term of
     copyright on the Program, and are irrevocable provided the stated
     conditions are met.  This License explicitly affirms your unlimited
     permission to run the unmodified Program.  The output from running
     a covered work is covered by this License only if the output, given
     its content, constitutes a covered work.  This License acknowledges
     your rights of fair use or other equivalent, as provided by
     copyright law.

     You may make, run and propagate covered works that you do not
     convey, without conditions so long as your license otherwise
     remains in force.  You may convey covered works to others for the
     sole purpose of having them make modifications exclusively for you,
     or provide you with facilities for running those works, provided
     that you comply with the terms of this License in conveying all
     material for which you do not control copyright.  Those thus making
     or running the covered works for you must do so exclusively on your
     behalf, under your direction and control, on terms that prohibit
     them from making any copies of your copyrighted material outside
     their relationship with you.

     Conveying under any other circumstances is permitted solely under
     the conditions stated below.  Sublicensing is not allowed; section
     10 makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

     No covered work shall be deemed part of an effective technological
     measure under any applicable law fulfilling obligations under
     article 11 of the WIPO copyright treaty adopted on 20 December
     1996, or similar laws prohibiting or restricting circumvention of
     such measures.

     When you convey a covered work, you waive any legal power to forbid
     circumvention of technological measures to the extent such
     circumvention is effected by exercising rights under this License
     with respect to the covered work, and you disclaim any intention to
     limit operation or modification of the work as a means of
     enforcing, against the work's users, your or third parties' legal
     rights to forbid circumvention of technological measures.

  4. Conveying Verbatim Copies.

     You may convey verbatim copies of the Program's source code as you
     receive it, in any medium, provided that you conspicuously and
     appropriately publish on each copy an appropriate copyright notice;
     keep intact all notices stating that this License and any
     non-permissive terms added in accord with section 7 apply to the
     code; keep intact all notices of the absence of any warranty; and
     give all recipients a copy of this License along with the Program.

     You may charge any price or no price for each copy that you convey,
     and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

     You may convey a work based on the Program, or the modifications to
     produce it from the Program, in the form of source code under the
     terms of section 4, provided that you also meet all of these
     conditions:

       a. The work must carry prominent notices stating that you
          modified it, and giving a relevant date.

       b. The work must carry prominent notices stating that it is
          released under this License and any conditions added under
          section 7.  This requirement modifies the requirement in
          section 4 to "keep intact all notices".

       c. You must license the entire work, as a whole, under this
          License to anyone who comes into possession of a copy.  This
          License will therefore apply, along with any applicable
          section 7 additional terms, to the whole of the work, and all
          its parts, regardless of how they are packaged.  This License
          gives no permission to license the work in any other way, but
          it does not invalidate such permission if you have separately
          received it.

       d. If the work has interactive user interfaces, each must display
          Appropriate Legal Notices; however, if the Program has
          interactive interfaces that do not display Appropriate Legal
          Notices, your work need not make them do so.

     A compilation of a covered work with other separate and independent
     works, which are not by their nature extensions of the covered
     work, and which are not combined with it such as to form a larger
     program, in or on a volume of a storage or distribution medium, is
     called an "aggregate" if the compilation and its resulting
     copyright are not used to limit the access or legal rights of the
     compilation's users beyond what the individual works permit.
     Inclusion of a covered work in an aggregate does not cause this
     License to apply to the other parts of the aggregate.

  6. Conveying Non-Source Forms.

     You may convey a covered work in object code form under the terms
     of sections 4 and 5, provided that you also convey the
     machine-readable Corresponding Source under the terms of this
     License, in one of these ways:

       a. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by the
          Corresponding Source fixed on a durable physical medium
          customarily used for software interchange.

       b. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by a
          written offer, valid for at least three years and valid for as
          long as you offer spare parts or customer support for that
          product model, to give anyone who possesses the object code
          either (1) a copy of the Corresponding Source for all the
          software in the product that is covered by this License, on a
          durable physical medium customarily used for software
          interchange, for a price no more than your reasonable cost of
          physically performing this conveying of source, or (2) access
          to copy the Corresponding Source from a network server at no
          charge.

       c. Convey individual copies of the object code with a copy of the
          written offer to provide the Corresponding Source.  This
          alternative is allowed only occasionally and noncommercially,
          and only if you received the object code with such an offer,
          in accord with subsection 6b.

       d. Convey the object code by offering access from a designated
          place (gratis or for a charge), and offer equivalent access to
          the Corresponding Source in the same way through the same
          place at no further charge.  You need not require recipients
          to copy the Corresponding Source along with the object code.
          If the place to copy the object code is a network server, the
          Corresponding Source may be on a different server (operated by
          you or a third party) that supports equivalent copying
          facilities, provided you maintain clear directions next to the
          object code saying where to find the Corresponding Source.
          Regardless of what server hosts the Corresponding Source, you
          remain obligated to ensure that it is available for as long as
          needed to satisfy these requirements.

       e. Convey the object code using peer-to-peer transmission,
          provided you inform other peers where the object code and
          Corresponding Source of the work are being offered to the
          general public at no charge under subsection 6d.

     A separable portion of the object code, whose source code is
     excluded from the Corresponding Source as a System Library, need
     not be included in conveying the object code work.

     A "User Product" is either (1) a "consumer product", which means
     any tangible personal property which is normally used for personal,
     family, or household purposes, or (2) anything designed or sold for
     incorporation into a dwelling.  In determining whether a product is
     a consumer product, doubtful cases shall be resolved in favor of
     coverage.  For a particular product received by a particular user,
     "normally used" refers to a typical or common use of that class of
     product, regardless of the status of the particular user or of the
     way in which the particular user actually uses, or expects or is
     expected to use, the product.  A product is a consumer product
     regardless of whether the product has substantial commercial,
     industrial or non-consumer uses, unless such uses represent the
     only significant mode of use of the product.

     "Installation Information" for a User Product means any methods,
     procedures, authorization keys, or other information required to
     install and execute modified versions of a covered work in that
     User Product from a modified version of its Corresponding Source.
     The information must suffice to ensure that the continued
     functioning of the modified object code is in no case prevented or
     interfered with solely because modification has been made.

     If you convey an object code work under this section in, or with,
     or specifically for use in, a User Product, and the conveying
     occurs as part of a transaction in which the right of possession
     and use of the User Product is transferred to the recipient in
     perpetuity or for a fixed term (regardless of how the transaction
     is characterized), the Corresponding Source conveyed under this
     section must be accompanied by the Installation Information.  But
     this requirement does not apply if neither you nor any third party
     retains the ability to install modified object code on the User
     Product (for example, the work has been installed in ROM).

     The requirement to provide Installation Information does not
     include a requirement to continue to provide support service,
     warranty, or updates for a work that has been modified or installed
     by the recipient, or for the User Product in which it has been
     modified or installed.  Access to a network may be denied when the
     modification itself materially and adversely affects the operation
     of the network or violates the rules and protocols for
     communication across the network.

     Corresponding Source conveyed, and Installation Information
     provided, in accord with this section must be in a format that is
     publicly documented (and with an implementation available to the
     public in source code form), and must require no special password
     or key for unpacking, reading or copying.

  7. Additional Terms.

     "Additional permissions" are terms that supplement the terms of
     this License by making exceptions from one or more of its
     conditions.  Additional permissions that are applicable to the
     entire Program shall be treated as though they were included in
     this License, to the extent that they are valid under applicable
     law.  If additional permissions apply only to part of the Program,
     that part may be used separately under those permissions, but the
     entire Program remains governed by this License without regard to
     the additional permissions.

     When you convey a copy of a covered work, you may at your option
     remove any additional permissions from that copy, or from any part
     of it.  (Additional permissions may be written to require their own
     removal in certain cases when you modify the work.)  You may place
     additional permissions on material, added by you to a covered work,
     for which you have or can give appropriate copyright permission.

     Notwithstanding any other provision of this License, for material
     you add to a covered work, you may (if authorized by the copyright
     holders of that material) supplement the terms of this License with
     terms:

       a. Disclaiming warranty or limiting liability differently from
          the terms of sections 15 and 16 of this License; or

       b. Requiring preservation of specified reasonable legal notices
          or author attributions in that material or in the Appropriate
          Legal Notices displayed by works containing it; or

       c. Prohibiting misrepresentation of the origin of that material,
          or requiring that modified versions of such material be marked
          in reasonable ways as different from the original version; or

       d. Limiting the use for publicity purposes of names of licensors
          or authors of the material; or

       e. Declining to grant rights under trademark law for use of some
          trade names, trademarks, or service marks; or

       f. Requiring indemnification of licensors and authors of that
          material by anyone who conveys the material (or modified
          versions of it) with contractual assumptions of liability to
          the recipient, for any liability that these contractual
          assumptions directly impose on those licensors and authors.

     All other non-permissive additional terms are considered "further
     restrictions" within the meaning of section 10.  If the Program as
     you received it, or any part of it, contains a notice stating that
     it is governed by this License along with a term that is a further
     restriction, you may remove that term.  If a license document
     contains a further restriction but permits relicensing or conveying
     under this License, you may add to a covered work material governed
     by the terms of that license document, provided that the further
     restriction does not survive such relicensing or conveying.

     If you add terms to a covered work in accord with this section, you
     must place, in the relevant source files, a statement of the
     additional terms that apply to those files, or a notice indicating
     where to find the applicable terms.

     Additional terms, permissive or non-permissive, may be stated in
     the form of a separately written license, or stated as exceptions;
     the above requirements apply either way.

  8. Termination.

     You may not propagate or modify a covered work except as expressly
     provided under this License.  Any attempt otherwise to propagate or
     modify it is void, and will automatically terminate your rights
     under this License (including any patent licenses granted under the
     third paragraph of section 11).

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, you do not qualify to receive new licenses
     for the same material under section 10.

  9. Acceptance Not Required for Having Copies.

     You are not required to accept this License in order to receive or
     run a copy of the Program.  Ancillary propagation of a covered work
     occurring solely as a consequence of using peer-to-peer
     transmission to receive a copy likewise does not require
     acceptance.  However, nothing other than this License grants you
     permission to propagate or modify any covered work.  These actions
     infringe copyright if you do not accept this License.  Therefore,
     by modifying or propagating a covered work, you indicate your
     acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

     Each time you convey a covered work, the recipient automatically
     receives a license from the original licensors, to run, modify and
     propagate that work, subject to this License.  You are not
     responsible for enforcing compliance by third parties with this
     License.

     An "entity transaction" is a transaction transferring control of an
     organization, or substantially all assets of one, or subdividing an
     organization, or merging organizations.  If propagation of a
     covered work results from an entity transaction, each party to that
     transaction who receives a copy of the work also receives whatever
     licenses to the work the party's predecessor in interest had or
     could give under the previous paragraph, plus a right to possession
     of the Corresponding Source of the work from the predecessor in
     interest, if the predecessor has it or can get it with reasonable
     efforts.

     You may not impose any further restrictions on the exercise of the
     rights granted or affirmed under this License.  For example, you
     may not impose a license fee, royalty, or other charge for exercise
     of rights granted under this License, and you may not initiate
     litigation (including a cross-claim or counterclaim in a lawsuit)
     alleging that any patent claim is infringed by making, using,
     selling, offering for sale, or importing the Program or any portion
     of it.

  11. Patents.

     A "contributor" is a copyright holder who authorizes use under this
     License of the Program or a work on which the Program is based.
     The work thus licensed is called the contributor's "contributor
     version".

     A contributor's "essential patent claims" are all patent claims
     owned or controlled by the contributor, whether already acquired or
     hereafter acquired, that would be infringed by some manner,
     permitted by this License, of making, using, or selling its
     contributor version, but do not include claims that would be
     infringed only as a consequence of further modification of the
     contributor version.  For purposes of this definition, "control"
     includes the right to grant patent sublicenses in a manner
     consistent with the requirements of this License.

     Each contributor grants you a non-exclusive, worldwide,
     royalty-free patent license under the contributor's essential
     patent claims, to make, use, sell, offer for sale, import and
     otherwise run, modify and propagate the contents of its contributor
     version.

     In the following three paragraphs, a "patent license" is any
     express agreement or commitment, however denominated, not to
     enforce a patent (such as an express permission to practice a
     patent or covenant not to sue for patent infringement).  To "grant"
     such a patent license to a party means to make such an agreement or
     commitment not to enforce a patent against the party.

     If you convey a covered work, knowingly relying on a patent
     license, and the Corresponding Source of the work is not available
     for anyone to copy, free of charge and under the terms of this
     License, through a publicly available network server or other
     readily accessible means, then you must either (1) cause the
     Corresponding Source to be so available, or (2) arrange to deprive
     yourself of the benefit of the patent license for this particular
     work, or (3) arrange, in a manner consistent with the requirements
     of this License, to extend the patent license to downstream
     recipients.  "Knowingly relying" means you have actual knowledge
     that, but for the patent license, your conveying the covered work
     in a country, or your recipient's use of the covered work in a
     country, would infringe one or more identifiable patents in that
     country that you have reason to believe are valid.

     If, pursuant to or in connection with a single transaction or
     arrangement, you convey, or propagate by procuring conveyance of, a
     covered work, and grant a patent license to some of the parties
     receiving the covered work authorizing them to use, propagate,
     modify or convey a specific copy of the covered work, then the
     patent license you grant is automatically extended to all
     recipients of the covered work and works based on it.

     A patent license is "discriminatory" if it does not include within
     the scope of its coverage, prohibits the exercise of, or is
     conditioned on the non-exercise of one or more of the rights that
     are specifically granted under this License.  You may not convey a
     covered work if you are a party to an arrangement with a third
     party that is in the business of distributing software, under which
     you make payment to the third party based on the extent of your
     activity of conveying the work, and under which the third party
     grants, to any of the parties who would receive the covered work
     from you, a discriminatory patent license (a) in connection with
     copies of the covered work conveyed by you (or copies made from
     those copies), or (b) primarily for and in connection with specific
     products or compilations that contain the covered work, unless you
     entered into that arrangement, or that patent license was granted,
     prior to 28 March 2007.

     Nothing in this License shall be construed as excluding or limiting
     any implied license or other defenses to infringement that may
     otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

     If conditions are imposed on you (whether by court order, agreement
     or otherwise) that contradict the conditions of this License, they
     do not excuse you from the conditions of this License.  If you
     cannot convey a covered work so as to satisfy simultaneously your
     obligations under this License and any other pertinent obligations,
     then as a consequence you may not convey it at all.  For example,
     if you agree to terms that obligate you to collect a royalty for
     further conveying from those to whom you convey the Program, the
     only way you could satisfy both those terms and this License would
     be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

     Notwithstanding any other provision of this License, you have
     permission to link or combine any covered work with a work licensed
     under version 3 of the GNU Affero General Public License into a
     single combined work, and to convey the resulting work.  The terms
     of this License will continue to apply to the part which is the
     covered work, but the special requirements of the GNU Affero
     General Public License, section 13, concerning interaction through
     a network will apply to the combination as such.

  14. Revised Versions of this License.

     The Free Software Foundation may publish revised and/or new
     versions of the GNU General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies that a certain numbered version of the GNU
     General Public License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that numbered version or of any later version published by the Free
     Software Foundation.  If the Program does not specify a version
     number of the GNU General Public License, you may choose any
     version ever published by the Free Software Foundation.

     If the Program specifies that a proxy can decide which future
     versions of the GNU General Public License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Program.

     Later license versions may give you additional or different
     permissions.  However, no additional obligations are imposed on any
     author or copyright holder as a result of your choosing to follow a
     later version.

  15. Disclaimer of Warranty.

     THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
     APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE
     COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS"
     WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE
     RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.
     SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
     NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

     IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES
     AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
     DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
     CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
     THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
     BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
     PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
     PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF
     THE POSSIBILITY OF SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

     If the disclaimer of warranty and limitation of liability provided
     above cannot be given local legal effect according to their terms,
     reviewing courts shall apply local law that most closely
     approximates an absolute waiver of all civil liability in
     connection with the Program, unless a warranty or assumption of
     liability accompanies a copy of the Program in return for a fee.

END OF TERMS AND CONDITIONS
===========================

How to Apply These Terms to Your New Programs
=============================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YEAR NAME OF AUTHOR

     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or (at
     your option) any later version.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Also add information on how to contact you by electronic and paper
mail.

   If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

     PROGRAM Copyright (C) YEAR NAME OF AUTHOR
     This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type 'show c' for details.

   The hypothetical commands 'show w' and 'show c' should show the
appropriate parts of the General Public License.  Of course, your
program's commands might be different; for a GUI interface, you would
use an "about box".

   You should also get your employer (if you work as a programmer) or
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  For more information on this, and how to apply and follow
the GNU GPL, see <http://www.gnu.org/licenses/>.

   The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Lesser General Public License instead of this License.  But first,
please read <http://www.gnu.org/philosophy/why-not-lgpl.html>.


File: gfortran.info,  Node: GNU Free Documentation License,  Next: Funding,  Prev: Copying,  Up: Top

GNU Free Documentation License
******************************

                     Version 1.3, 3 November 2008

     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <http://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     The "publisher" means any person or entity that distributes copies
     of the Document to the public.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled "History" in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          "History" section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version's
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, receipt of a copy of some or all of the
     same material does not give you any rights to use it.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <http://www.gnu.org/copyleft/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.  If the Document specifies that a proxy can
     decide which future versions of this License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

  11. RELICENSING

     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     "Incorporate" means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is "eligible for relicensing" if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts."  line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: gfortran.info,  Node: Funding,  Next: Option Index,  Prev: GNU Free Documentation License,  Up: Top

Funding Free Software
*********************

If you want to have more free software a few years from now, it makes
sense for you to help encourage people to contribute funds for its
development.  The most effective approach known is to encourage
commercial redistributors to donate.

   Users of free software systems can boost the pace of development by
encouraging for-a-fee distributors to donate part of their selling price
to free software developers--the Free Software Foundation, and others.

   The way to convince distributors to do this is to demand it and
expect it from them.  So when you compare distributors, judge them
partly by how much they give to free software development.  Show
distributors they must compete to be the one who gives the most.

   To make this approach work, you must insist on numbers that you can
compare, such as, "We will donate ten dollars to the Frobnitz project
for each disk sold."  Don't be satisfied with a vague promise, such as
"A portion of the profits are donated," since it doesn't give a basis
for comparison.

   Even a precise fraction "of the profits from this disk" is not very
meaningful, since creative accounting and unrelated business decisions
can greatly alter what fraction of the sales price counts as profit.  If
the price you pay is $50, ten percent of the profit is probably less
than a dollar; it might be a few cents, or nothing at all.

   Some redistributors do development work themselves.  This is useful
too; but to keep everyone honest, you need to inquire how much they do,
and what kind.  Some kinds of development make much more long-term
difference than others.  For example, maintaining a separate version of
a program contributes very little; maintaining the standard version of a
program for the whole community contributes much.  Easy new ports
contribute little, since someone else would surely do them; difficult
ports such as adding a new CPU to the GNU Compiler Collection contribute
more; major new features or packages contribute the most.

   By establishing the idea that supporting further development is "the
proper thing to do" when distributing free software for a fee, we can
assure a steady flow of resources into making more free software.

     Copyright (C) 1994 Free Software Foundation, Inc.
     Verbatim copying and redistribution of this section is permitted
     without royalty; alteration is not permitted.


File: gfortran.info,  Node: Option Index,  Next: Keyword Index,  Prev: Funding,  Up: Top

Option Index
************

'gfortran''s command line options are indexed here without any initial
'-' or '--'.  Where an option has both positive and negative forms (such
as -foption and -fno-option), relevant entries in the manual are indexed
under the most appropriate form; it may sometimes be useful to look up
both forms.

 [index ]
* Menu:

* 'A-PREDICATE=ANSWER':                  Preprocessing Options.
                                                              (line 119)
* 'APREDICATE=ANSWER':                   Preprocessing Options.
                                                              (line 113)
* 'backslash':                           Fortran Dialect Options.
                                                              (line  79)
* 'C':                                   Preprocessing Options.
                                                              (line 122)
* 'c-prototypes':                        Interoperability Options.
                                                              (line   7)
* 'c-prototypes-external':               Interoperability Options.
                                                              (line  25)
* 'CC':                                  Preprocessing Options.
                                                              (line 137)
* 'cpp':                                 Preprocessing Options.
                                                              (line  12)
* 'dD':                                  Preprocessing Options.
                                                              (line  35)
* 'dI':                                  Preprocessing Options.
                                                              (line  51)
* 'dM':                                  Preprocessing Options.
                                                              (line  26)
* 'dN':                                  Preprocessing Options.
                                                              (line  41)
* 'DNAME':                               Preprocessing Options.
                                                              (line 151)
* 'DNAME=DEFINITION':                    Preprocessing Options.
                                                              (line 154)
* 'dU':                                  Preprocessing Options.
                                                              (line  44)
* 'faggressive-function-elimination':    Code Gen Options.    (line 406)
* 'falign-commons':                      Code Gen Options.    (line 379)
* 'fall-intrinsics':                     Fortran Dialect Options.
                                                              (line  17)
* 'fblas-matmul-limit':                  Code Gen Options.    (line 308)
* 'fbounds-check':                       Code Gen Options.    (line 201)
* 'fcheck':                              Code Gen Options.    (line 144)
* 'fcheck-array-temporaries':            Code Gen Options.    (line 235)
* 'fcoarray':                            Code Gen Options.    (line 130)
* 'fconvert='CONVERSION:                 Runtime Options.     (line  10)
* 'fcray-pointer':                       Fortran Dialect Options.
                                                              (line 134)
* 'fd-lines-as-code':                    Fortran Dialect Options.
                                                              (line  27)
* 'fd-lines-as-comments':                Fortran Dialect Options.
                                                              (line  27)
* 'fdec':                                Fortran Dialect Options.
                                                              (line  34)
* 'fdec-include':                        Fortran Dialect Options.
                                                              (line  68)
* 'fdec-intrinsic-ints':                 Fortran Dialect Options.
                                                              (line  54)
* 'fdec-math':                           Fortran Dialect Options.
                                                              (line  59)
* 'fdec-static':                         Fortran Dialect Options.
                                                              (line  64)
* 'fdec-structure':                      Fortran Dialect Options.
                                                              (line  48)
* 'fdefault-double-8':                   Fortran Dialect Options.
                                                              (line 205)
* 'fdefault-integer-8':                  Fortran Dialect Options.
                                                              (line 169)
* 'fdefault-real-10':                    Fortran Dialect Options.
                                                              (line 185)
* 'fdefault-real-16':                    Fortran Dialect Options.
                                                              (line 195)
* 'fdefault-real-8':                     Fortran Dialect Options.
                                                              (line 175)
* 'fdollar-ok':                          Fortran Dialect Options.
                                                              (line  73)
* 'fdump-fortran-global':                Debugging Options.   (line  33)
* 'fdump-fortran-optimized':             Debugging Options.   (line  18)
* 'fdump-fortran-original':              Debugging Options.   (line  10)
* 'fdump-parse-tree':                    Debugging Options.   (line  25)
* 'fexternal-blas':                      Code Gen Options.    (line 300)
* ff2c:                                  Code Gen Options.    (line  28)
* 'ffixed-form':                         Fortran Dialect Options.
                                                              (line  11)
* 'ffixed-line-length-'N:                Fortran Dialect Options.
                                                              (line  96)
* 'ffpe-summary='LIST:                   Debugging Options.   (line  73)
* 'ffpe-trap='LIST:                      Debugging Options.   (line  40)
* 'ffree-form':                          Fortran Dialect Options.
                                                              (line  11)
* 'ffree-line-length-'N:                 Fortran Dialect Options.
                                                              (line 118)
* 'fimplicit-none':                      Fortran Dialect Options.
                                                              (line 129)
* 'finit-character':                     Code Gen Options.    (line 343)
* 'finit-derived':                       Code Gen Options.    (line 343)
* 'finit-integer':                       Code Gen Options.    (line 343)
* 'finit-local-zero':                    Code Gen Options.    (line 343)
* 'finit-logical':                       Code Gen Options.    (line 343)
* 'finit-real':                          Code Gen Options.    (line 343)
* 'finline-matmul-limit':                Code Gen Options.    (line 319)
* 'finteger-4-integer-8':                Fortran Dialect Options.
                                                              (line 213)
* 'fintrinsic-modules-path' DIR:         Directory Options.   (line  36)
* 'fmax-array-constructor':              Code Gen Options.    (line 238)
* 'fmax-errors='N:                       Error and Warning Options.
                                                              (line  27)
* 'fmax-identifier-length='N:            Fortran Dialect Options.
                                                              (line 125)
* 'fmax-stack-var-size':                 Code Gen Options.    (line 256)
* 'fmax-subrecord-length='LENGTH:        Runtime Options.     (line  29)
* 'fmodule-private':                     Fortran Dialect Options.
                                                              (line  91)
* 'fno-automatic':                       Code Gen Options.    (line  15)
* 'fno-backtrace':                       Debugging Options.   (line  86)
* 'fno-protect-parens':                  Code Gen Options.    (line 391)
* 'fno-underscoring':                    Code Gen Options.    (line  57)
* 'fopenacc':                            Fortran Dialect Options.
                                                              (line 138)
* 'fopenmp':                             Fortran Dialect Options.
                                                              (line 149)
* 'fpack-derived':                       Code Gen Options.    (line 278)
* 'fpad-source':                         Fortran Dialect Options.
                                                              (line 110)
* 'fpp':                                 Preprocessing Options.
                                                              (line  12)
* 'frange-check':                        Fortran Dialect Options.
                                                              (line 157)
* 'freal-4-real-10':                     Fortran Dialect Options.
                                                              (line 228)
* 'freal-4-real-16':                     Fortran Dialect Options.
                                                              (line 228)
* 'freal-4-real-8':                      Fortran Dialect Options.
                                                              (line 228)
* 'freal-8-real-10':                     Fortran Dialect Options.
                                                              (line 228)
* 'freal-8-real-16':                     Fortran Dialect Options.
                                                              (line 228)
* 'freal-8-real-4':                      Fortran Dialect Options.
                                                              (line 228)
* 'frealloc-lhs':                        Code Gen Options.    (line 400)
* 'frecord-marker='LENGTH:               Runtime Options.     (line  21)
* 'frecursive':                          Code Gen Options.    (line 333)
* 'frepack-arrays':                      Code Gen Options.    (line 284)
* 'frontend-loop-interchange':           Code Gen Options.    (line 427)
* 'frontend-optimize':                   Code Gen Options.    (line 414)
* 'fsecond-underscore':                  Code Gen Options.    (line 113)
* 'fshort-enums':                        Code Gen Options.    (line 294)
* 'fshort-enums' <1>:                    Fortran 2003 status. (line  92)
* 'fsign-zero':                          Runtime Options.     (line  34)
* 'fstack-arrays':                       Code Gen Options.    (line 270)
* 'fsyntax-only':                        Error and Warning Options.
                                                              (line  33)
* 'ftest-forall-temp':                   Fortran Dialect Options.
                                                              (line 258)
* 'fworking-directory':                  Preprocessing Options.
                                                              (line  55)
* 'H':                                   Preprocessing Options.
                                                              (line 174)
* 'I'DIR:                                Directory Options.   (line  14)
* 'idirafter DIR':                       Preprocessing Options.
                                                              (line  69)
* 'imultilib DIR':                       Preprocessing Options.
                                                              (line  76)
* 'iprefix PREFIX':                      Preprocessing Options.
                                                              (line  80)
* 'iquote DIR':                          Preprocessing Options.
                                                              (line  89)
* 'isysroot DIR':                        Preprocessing Options.
                                                              (line  85)
* 'isystem DIR':                         Preprocessing Options.
                                                              (line  96)
* 'J'DIR:                                Directory Options.   (line  29)
* 'M'DIR:                                Directory Options.   (line  29)
* 'nostdinc':                            Preprocessing Options.
                                                              (line 104)
* 'P':                                   Preprocessing Options.
                                                              (line 179)
* 'pedantic':                            Error and Warning Options.
                                                              (line  39)
* 'pedantic-errors':                     Error and Warning Options.
                                                              (line  58)
* 'static-libgfortran':                  Link Options.        (line  11)
* 'std='STD option:                      Fortran Dialect Options.
                                                              (line 239)
* 'tail-call-workaround':                Code Gen Options.    (line 205)
* 'UNAME':                               Preprocessing Options.
                                                              (line 185)
* 'undef':                               Preprocessing Options.
                                                              (line 109)
* 'Waliasing':                           Error and Warning Options.
                                                              (line  71)
* 'Walign-commons':                      Error and Warning Options.
                                                              (line 226)
* 'Wall':                                Error and Warning Options.
                                                              (line  62)
* 'Wampersand':                          Error and Warning Options.
                                                              (line  88)
* 'Wargument-mismatch':                  Error and Warning Options.
                                                              (line  96)
* 'Warray-temporaries':                  Error and Warning Options.
                                                              (line 101)
* 'Wc-binding-type':                     Error and Warning Options.
                                                              (line 106)
* 'Wcharacter-truncation':               Error and Warning Options.
                                                              (line 113)
* 'Wcompare-reals':                      Error and Warning Options.
                                                              (line 254)
* 'Wconversion':                         Error and Warning Options.
                                                              (line 122)
* 'Wconversion-extra':                   Error and Warning Options.
                                                              (line 126)
* 'Wdo-subscript':                       Error and Warning Options.
                                                              (line 266)
* 'Werror':                              Error and Warning Options.
                                                              (line 278)
* 'Wextra':                              Error and Warning Options.
                                                              (line 130)
* 'Wfrontend-loop-interchange':          Error and Warning Options.
                                                              (line 135)
* 'Wfunction-elimination':               Error and Warning Options.
                                                              (line 232)
* 'Wimplicit-interface':                 Error and Warning Options.
                                                              (line 139)
* 'Wimplicit-procedure':                 Error and Warning Options.
                                                              (line 145)
* 'Winteger-division':                   Error and Warning Options.
                                                              (line 149)
* 'Wintrinsic-shadow':                   Error and Warning Options.
                                                              (line 204)
* 'Wintrinsics-std':                     Error and Warning Options.
                                                              (line 153)
* 'Wline-truncation':                    Error and Warning Options.
                                                              (line 116)
* 'Wpedantic':                           Error and Warning Options.
                                                              (line  39)
* 'Wreal-q-constant':                    Error and Warning Options.
                                                              (line 160)
* 'Wrealloc-lhs':                        Error and Warning Options.
                                                              (line 237)
* 'Wrealloc-lhs-all':                    Error and Warning Options.
                                                              (line 249)
* 'Wsurprising':                         Error and Warning Options.
                                                              (line 164)
* 'Wtabs':                               Error and Warning Options.
                                                              (line 186)
* 'Wtargt-lifetime':                     Error and Warning Options.
                                                              (line 258)
* 'Wundefined-do-loop':                  Error and Warning Options.
                                                              (line 194)
* 'Wunderflow':                          Error and Warning Options.
                                                              (line 199)
* 'Wunused-dummy-argument':              Error and Warning Options.
                                                              (line 215)
* 'Wunused-parameter':                   Error and Warning Options.
                                                              (line 219)
* 'Wuse-without-only':                   Error and Warning Options.
                                                              (line 211)
* 'Wzerotrip':                           Error and Warning Options.
                                                              (line 262)


File: gfortran.info,  Node: Keyword Index,  Prev: Option Index,  Up: Top

Keyword Index
*************

 [index ]
* Menu:

* '$':                                   Fortran Dialect Options.
                                                              (line  73)
* '%LOC':                                Argument list functions.
                                                              (line   6)
* '%REF':                                Argument list functions.
                                                              (line   6)
* '%VAL':                                Argument list functions.
                                                              (line   6)
* '&':                                   Error and Warning Options.
                                                              (line  88)
* '[...]':                               Fortran 2003 status. (line  78)
* _gfortran_set_args:                    _gfortran_set_args.  (line   6)
* _gfortran_set_convert:                 _gfortran_set_convert.
                                                              (line   6)
* _gfortran_set_fpe:                     _gfortran_set_fpe.   (line   6)
* _gfortran_set_max_subrecord_length:    _gfortran_set_max_subrecord_length.
                                                              (line   6)
* _gfortran_set_options:                 _gfortran_set_options.
                                                              (line   6)
* _gfortran_set_record_marker:           _gfortran_set_record_marker.
                                                              (line   6)
* ABORT:                                 ABORT.               (line   6)
* ABS:                                   ABS.                 (line   6)
* absolute value:                        ABS.                 (line   6)
* ACCESS:                                ACCESS.              (line   6)
* 'ACCESS='STREAM'' I/O:                 Fortran 2003 status. (line 102)
* ACHAR:                                 ACHAR.               (line   6)
* ACOS:                                  ACOS.                (line   6)
* ACOSD:                                 ACOSD.               (line   6)
* ACOSH:                                 ACOSH.               (line   6)
* adjust string:                         ADJUSTL.             (line   6)
* adjust string <1>:                     ADJUSTR.             (line   6)
* ADJUSTL:                               ADJUSTL.             (line   6)
* ADJUSTR:                               ADJUSTR.             (line   6)
* AIMAG:                                 AIMAG.               (line   6)
* AINT:                                  AINT.                (line   6)
* ALARM:                                 ALARM.               (line   6)
* ALGAMA:                                LOG_GAMMA.           (line   6)
* aliasing:                              Error and Warning Options.
                                                              (line  71)
* alignment of 'COMMON' blocks:          Error and Warning Options.
                                                              (line 226)
* alignment of 'COMMON' blocks <1>:      Code Gen Options.    (line 379)
* ALL:                                   ALL.                 (line   6)
* all warnings:                          Error and Warning Options.
                                                              (line  62)
* 'ALLOCATABLE' components of derived types: Fortran 2003 status.
                                                              (line 100)
* 'ALLOCATABLE' dummy arguments:         Fortran 2003 status. (line  98)
* 'ALLOCATABLE' function results:        Fortran 2003 status. (line  99)
* ALLOCATED:                             ALLOCATED.           (line   6)
* allocation, moving:                    MOVE_ALLOC.          (line   6)
* allocation, status:                    ALLOCATED.           (line   6)
* ALOG:                                  LOG.                 (line   6)
* ALOG10:                                LOG10.               (line   6)
* AMAX0:                                 MAX.                 (line   6)
* AMAX1:                                 MAX.                 (line   6)
* AMIN0:                                 MIN.                 (line   6)
* AMIN1:                                 MIN.                 (line   6)
* AMOD:                                  MOD.                 (line   6)
* AND:                                   AND.                 (line   6)
* ANINT:                                 ANINT.               (line   6)
* ANY:                                   ANY.                 (line   6)
* area hyperbolic cosine:                ACOSH.               (line   6)
* area hyperbolic sine:                  ASINH.               (line   6)
* area hyperbolic tangent:               ATANH.               (line   6)
* argument list functions:               Argument list functions.
                                                              (line   6)
* arguments, to program:                 COMMAND_ARGUMENT_COUNT.
                                                              (line   6)
* arguments, to program <1>:             GETARG.              (line   6)
* arguments, to program <2>:             GET_COMMAND.         (line   6)
* arguments, to program <3>:             GET_COMMAND_ARGUMENT.
                                                              (line   6)
* arguments, to program <4>:             IARGC.               (line   6)
* array, add elements:                   SUM.                 (line   6)
* array, AND:                            IALL.                (line   6)
* array, apply condition:                ALL.                 (line   6)
* array, apply condition <1>:            ANY.                 (line   6)
* array, bounds checking:                Code Gen Options.    (line 144)
* array, change dimensions:              RESHAPE.             (line   6)
* array, combine arrays:                 MERGE.               (line   6)
* array, condition testing:              ALL.                 (line   6)
* array, condition testing <1>:          ANY.                 (line   6)
* array, conditionally add elements:     SUM.                 (line   6)
* array, conditionally count elements:   COUNT.               (line   6)
* array, conditionally multiply elements: PRODUCT.            (line   6)
* array, constructors:                   Fortran 2003 status. (line  78)
* array, contiguity:                     IS_CONTIGUOUS.       (line   6)
* array, count elements:                 SIZE.                (line   6)
* array, duplicate dimensions:           SPREAD.              (line   6)
* array, duplicate elements:             SPREAD.              (line   6)
* array, element counting:               COUNT.               (line   6)
* array, gather elements:                PACK.                (line   6)
* array, increase dimension:             SPREAD.              (line   6)
* array, increase dimension <1>:         UNPACK.              (line   6)
* array, indices of type real:           Real array indices.  (line   6)
* array, location of maximum element:    MAXLOC.              (line   6)
* array, location of minimum element:    MINLOC.              (line   6)
* array, lower bound:                    LBOUND.              (line   6)
* array, maximum value:                  MAXVAL.              (line   6)
* array, merge arrays:                   MERGE.               (line   6)
* array, minimum value:                  MINVAL.              (line   6)
* array, multiply elements:              PRODUCT.             (line   6)
* array, number of elements:             COUNT.               (line   6)
* array, number of elements <1>:         SIZE.                (line   6)
* array, OR:                             IANY.                (line   6)
* array, packing:                        PACK.                (line   6)
* array, parity:                         IPARITY.             (line   6)
* array, permutation:                    CSHIFT.              (line   6)
* array, product:                        PRODUCT.             (line   6)
* array, reduce dimension:               PACK.                (line   6)
* array, rotate:                         CSHIFT.              (line   6)
* array, scatter elements:               UNPACK.              (line   6)
* array, shape:                          SHAPE.               (line   6)
* array, shift:                          EOSHIFT.             (line   6)
* array, shift circularly:               CSHIFT.              (line   6)
* array, size:                           SIZE.                (line   6)
* array, sum:                            SUM.                 (line   6)
* array, transmogrify:                   RESHAPE.             (line   6)
* array, transpose:                      TRANSPOSE.           (line   6)
* array, unpacking:                      UNPACK.              (line   6)
* array, upper bound:                    UBOUND.              (line   6)
* array, XOR:                            IPARITY.             (line   6)
* ASCII collating sequence:              ACHAR.               (line   6)
* ASCII collating sequence <1>:          IACHAR.              (line   6)
* ASIN:                                  ASIN.                (line   6)
* ASIND:                                 ASIND.               (line   6)
* ASINH:                                 ASINH.               (line   6)
* ASSOCIATED:                            ASSOCIATED.          (line   6)
* association status:                    ASSOCIATED.          (line   6)
* association status, C pointer:         C_ASSOCIATED.        (line   6)
* asynchronous I/O:                      Asynchronous I/O.    (line   6)
* ATAN:                                  ATAN.                (line   6)
* ATAN2:                                 ATAN2.               (line   6)
* ATAN2D:                                ATAN2D.              (line   6)
* ATAND:                                 ATAND.               (line   6)
* ATANH:                                 ATANH.               (line   6)
* Atomic subroutine, add:                ATOMIC_ADD.          (line   6)
* Atomic subroutine, ADD with fetch:     ATOMIC_FETCH_ADD.    (line   6)
* Atomic subroutine, AND:                ATOMIC_AND.          (line   6)
* Atomic subroutine, AND with fetch:     ATOMIC_FETCH_AND.    (line   6)
* Atomic subroutine, compare and swap:   ATOMIC_CAS.          (line   6)
* Atomic subroutine, define:             ATOMIC_DEFINE.       (line   6)
* Atomic subroutine, OR:                 ATOMIC_OR.           (line   6)
* Atomic subroutine, OR with fetch:      ATOMIC_FETCH_OR.     (line   6)
* Atomic subroutine, reference:          ATOMIC_REF.          (line   6)
* Atomic subroutine, XOR:                ATOMIC_XOR.          (line   6)
* Atomic subroutine, XOR with fetch:     ATOMIC_FETCH_XOR.    (line   6)
* ATOMIC_ADD:                            ATOMIC_ADD.          (line   6)
* ATOMIC_AND:                            ATOMIC_AND.          (line   6)
* ATOMIC_DEFINE:                         ATOMIC_CAS.          (line   6)
* ATOMIC_DEFINE <1>:                     ATOMIC_DEFINE.       (line   6)
* ATOMIC_FETCH_ADD:                      ATOMIC_FETCH_ADD.    (line   6)
* ATOMIC_FETCH_AND:                      ATOMIC_FETCH_AND.    (line   6)
* ATOMIC_FETCH_OR:                       ATOMIC_FETCH_OR.     (line   6)
* ATOMIC_FETCH_XOR:                      ATOMIC_FETCH_XOR.    (line   6)
* ATOMIC_OR:                             ATOMIC_OR.           (line   6)
* ATOMIC_REF:                            ATOMIC_REF.          (line   6)
* ATOMIC_XOR:                            ATOMIC_XOR.          (line   6)
* Authors:                               Contributors.        (line   6)
* 'AUTOMATIC':                           AUTOMATIC and STATIC attributes.
                                                              (line   6)
* BABS:                                  ABS.                 (line   6)
* backslash:                             Fortran Dialect Options.
                                                              (line  79)
* 'BACKSPACE':                           Read/Write after EOF marker.
                                                              (line   6)
* BACKTRACE:                             BACKTRACE.           (line   6)
* backtrace:                             Debugging Options.   (line  86)
* backtrace <1>:                         BACKTRACE.           (line   6)
* base 10 logarithm function:            LOG10.               (line   6)
* BBCLR:                                 IBCLR.               (line   6)
* BBITS:                                 IBITS.               (line   6)
* BBSET:                                 IBSET.               (line   6)
* BBTEST:                                BTEST.               (line   6)
* BESJ0:                                 BESSEL_J0.           (line   6)
* BESJ1:                                 BESSEL_J1.           (line   6)
* BESJN:                                 BESSEL_JN.           (line   6)
* Bessel function, first kind:           BESSEL_J0.           (line   6)
* Bessel function, first kind <1>:       BESSEL_J1.           (line   6)
* Bessel function, first kind <2>:       BESSEL_JN.           (line   6)
* Bessel function, second kind:          BESSEL_Y0.           (line   6)
* Bessel function, second kind <1>:      BESSEL_Y1.           (line   6)
* Bessel function, second kind <2>:      BESSEL_YN.           (line   6)
* BESSEL_J0:                             BESSEL_J0.           (line   6)
* BESSEL_J1:                             BESSEL_J1.           (line   6)
* BESSEL_JN:                             BESSEL_JN.           (line   6)
* BESSEL_Y0:                             BESSEL_Y0.           (line   6)
* BESSEL_Y1:                             BESSEL_Y1.           (line   6)
* BESSEL_YN:                             BESSEL_YN.           (line   6)
* BESY0:                                 BESSEL_Y0.           (line   6)
* BESY1:                                 BESSEL_Y1.           (line   6)
* BESYN:                                 BESSEL_YN.           (line   6)
* BGE:                                   BGE.                 (line   6)
* BGT:                                   BGT.                 (line   6)
* BIAND:                                 IAND.                (line   6)
* BIEOR:                                 IEOR.                (line   6)
* binary representation:                 POPCNT.              (line   6)
* binary representation <1>:             POPPAR.              (line   6)
* BIOR:                                  IOR.                 (line   6)
* BITEST:                                BTEST.               (line   6)
* bits set:                              POPCNT.              (line   6)
* bits, AND of array elements:           IALL.                (line   6)
* bits, clear:                           IBCLR.               (line   6)
* bits, extract:                         IBITS.               (line   6)
* bits, get:                             IBITS.               (line   6)
* bits, merge:                           MERGE_BITS.          (line   6)
* bits, move:                            MVBITS.              (line   6)
* bits, move <1>:                        TRANSFER.            (line   6)
* bits, negate:                          NOT.                 (line   6)
* bits, number of:                       BIT_SIZE.            (line   6)
* bits, OR of array elements:            IANY.                (line   6)
* bits, set:                             IBSET.               (line   6)
* bits, shift:                           ISHFT.               (line   6)
* bits, shift circular:                  ISHFTC.              (line   6)
* bits, shift left:                      LSHIFT.              (line   6)
* bits, shift left <1>:                  SHIFTL.              (line   6)
* bits, shift right:                     RSHIFT.              (line   6)
* bits, shift right <1>:                 SHIFTA.              (line   6)
* bits, shift right <2>:                 SHIFTR.              (line   6)
* bits, testing:                         BTEST.               (line   6)
* bits, unset:                           IBCLR.               (line   6)
* bits, XOR of array elements:           IPARITY.             (line   6)
* bitwise comparison:                    BGE.                 (line   6)
* bitwise comparison <1>:                BGT.                 (line   6)
* bitwise comparison <2>:                BLE.                 (line   6)
* bitwise comparison <3>:                BLT.                 (line   6)
* bitwise logical and:                   AND.                 (line   6)
* bitwise logical and <1>:               IAND.                (line   6)
* bitwise logical exclusive or:          IEOR.                (line   6)
* bitwise logical exclusive or <1>:      XOR.                 (line   6)
* bitwise logical not:                   NOT.                 (line   6)
* bitwise logical or:                    IOR.                 (line   6)
* bitwise logical or <1>:                OR.                  (line   6)
* BIT_SIZE:                              BIT_SIZE.            (line   6)
* BJTEST:                                BTEST.               (line   6)
* BKTEST:                                BTEST.               (line   6)
* BLE:                                   BLE.                 (line   6)
* BLT:                                   BLT.                 (line   6)
* BMOD:                                  MOD.                 (line   6)
* BMVBITS:                               MVBITS.              (line   6)
* BNOT:                                  NOT.                 (line   6)
* bounds checking:                       Code Gen Options.    (line 144)
* BOZ literal constants:                 BOZ literal constants.
                                                              (line   6)
* BSHFT:                                 ISHFT.               (line   6)
* BSHFTC:                                ISHFTC.              (line   6)
* BTEST:                                 BTEST.               (line   6)
* CABS:                                  ABS.                 (line   6)
* calling convention:                    Code Gen Options.    (line  28)
* 'CARRIAGECONTROL':                     Extended I/O specifiers.
                                                              (line   6)
* CCOS:                                  COS.                 (line   6)
* CCOSD:                                 COSD.                (line   6)
* CDABS:                                 ABS.                 (line   6)
* CDCOS:                                 COS.                 (line   6)
* CDCOSD:                                COSD.                (line   6)
* CDEXP:                                 EXP.                 (line   6)
* CDLOG:                                 LOG.                 (line   6)
* CDSIN:                                 SIN.                 (line   6)
* CDSIND:                                SIND.                (line   6)
* CDSQRT:                                SQRT.                (line   6)
* CEILING:                               CEILING.             (line   6)
* ceiling:                               ANINT.               (line   6)
* ceiling <1>:                           CEILING.             (line   6)
* CEXP:                                  EXP.                 (line   6)
* CHAR:                                  CHAR.                (line   6)
* character kind:                        SELECTED_CHAR_KIND.  (line   6)
* character set:                         Fortran Dialect Options.
                                                              (line  73)
* CHDIR:                                 CHDIR.               (line   6)
* checking array temporaries:            Code Gen Options.    (line 144)
* checking subscripts:                   Code Gen Options.    (line 144)
* CHMOD:                                 CHMOD.               (line   6)
* clock ticks:                           MCLOCK.              (line   6)
* clock ticks <1>:                       MCLOCK8.             (line   6)
* clock ticks <2>:                       SYSTEM_CLOCK.        (line   6)
* CLOG:                                  LOG.                 (line   6)
* CMPLX:                                 CMPLX.               (line   6)
* coarray, 'IMAGE_INDEX':                IMAGE_INDEX.         (line   6)
* coarray, lower bound:                  LCOBOUND.            (line   6)
* coarray, 'NUM_IMAGES':                 NUM_IMAGES.          (line   6)
* coarray, 'THIS_IMAGE':                 THIS_IMAGE.          (line   6)
* coarray, upper bound:                  UCOBOUND.            (line   6)
* Coarray, _gfortran_caf_atomic_cas:     _gfortran_caf_atomic_cas.
                                                              (line   6)
* Coarray, _gfortran_caf_atomic_define:  _gfortran_caf_atomic_define.
                                                              (line   6)
* Coarray, _gfortran_caf_atomic_op:      _gfortran_caf_atomic_op.
                                                              (line   6)
* Coarray, _gfortran_caf_atomic_ref:     _gfortran_caf_atomic_ref.
                                                              (line   6)
* Coarray, _gfortran_caf_co_broadcast:   _gfortran_caf_co_broadcast.
                                                              (line   6)
* Coarray, _gfortran_caf_co_max:         _gfortran_caf_co_max.
                                                              (line   6)
* Coarray, _gfortran_caf_co_min:         _gfortran_caf_co_min.
                                                              (line   6)
* Coarray, _gfortran_caf_co_reduce:      _gfortran_caf_co_reduce.
                                                              (line   6)
* Coarray, _gfortran_caf_co_sum:         _gfortran_caf_co_sum.
                                                              (line   6)
* Coarray, _gfortran_caf_deregister:     _gfortran_caf_deregister.
                                                              (line   6)
* Coarray, _gfortran_caf_error_stop:     _gfortran_caf_error_stop.
                                                              (line   6)
* Coarray, _gfortran_caf_error_stop_str: _gfortran_caf_error_stop_str.
                                                              (line   6)
* Coarray, _gfortran_caf_event_post:     _gfortran_caf_event_post.
                                                              (line   6)
* Coarray, _gfortran_caf_event_query:    _gfortran_caf_event_query.
                                                              (line   6)
* Coarray, _gfortran_caf_event_wait:     _gfortran_caf_event_wait.
                                                              (line   6)
* Coarray, _gfortran_caf_failed_images:  _gfortran_caf_failed_images.
                                                              (line   6)
* Coarray, _gfortran_caf_fail_image:     _gfortran_caf_fail_image.
                                                              (line   6)
* Coarray, _gfortran_caf_finish:         _gfortran_caf_finish.
                                                              (line   6)
* Coarray, _gfortran_caf_get:            _gfortran_caf_get.   (line   6)
* Coarray, _gfortran_caf_get_by_ref:     _gfortran_caf_get_by_ref.
                                                              (line   6)
* Coarray, _gfortran_caf_image_status:   _gfortran_caf_image_status.
                                                              (line   6)
* Coarray, _gfortran_caf_init:           _gfortran_caf_init.  (line   6)
* Coarray, _gfortran_caf_is_present:     _gfortran_caf_is_present.
                                                              (line   6)
* Coarray, _gfortran_caf_lock:           _gfortran_caf_lock.  (line   6)
* Coarray, _gfortran_caf_num_images:     _gfortran_caf_num_images.
                                                              (line   6)
* Coarray, _gfortran_caf_register:       _gfortran_caf_register.
                                                              (line   6)
* Coarray, _gfortran_caf_send:           _gfortran_caf_send.  (line   6)
* Coarray, _gfortran_caf_sendget:        _gfortran_caf_sendget.
                                                              (line   6)
* Coarray, _gfortran_caf_sendget_by_ref: _gfortran_caf_sendget_by_ref.
                                                              (line   6)
* Coarray, _gfortran_caf_send_by_ref:    _gfortran_caf_send_by_ref.
                                                              (line   6)
* Coarray, _gfortran_caf_stopped_images: _gfortran_caf_stopped_images.
                                                              (line   6)
* Coarray, _gfortran_caf_sync_all:       _gfortran_caf_sync_all.
                                                              (line   6)
* Coarray, _gfortran_caf_sync_images:    _gfortran_caf_sync_images.
                                                              (line   6)
* Coarray, _gfortran_caf_sync_memory:    _gfortran_caf_sync_memory.
                                                              (line   6)
* Coarray, _gfortran_caf_this_image:     _gfortran_caf_this_image.
                                                              (line   6)
* Coarray, _gfortran_caf_unlock:         _gfortran_caf_unlock.
                                                              (line   6)
* coarrays:                              Code Gen Options.    (line 130)
* Coarrays:                              Coarray Programming. (line   6)
* code generation, conventions:          Code Gen Options.    (line   6)
* collating sequence, ASCII:             ACHAR.               (line   6)
* collating sequence, ASCII <1>:         IACHAR.              (line   6)
* Collectives, generic reduction:        CO_REDUCE.           (line   6)
* Collectives, maximal value:            CO_MAX.              (line   6)
* Collectives, minimal value:            CO_MIN.              (line   6)
* Collectives, sum of values:            CO_SUM.              (line   6)
* Collectives, value broadcasting:       CO_BROADCAST.        (line   6)
* command line:                          EXECUTE_COMMAND_LINE.
                                                              (line   6)
* command options:                       Invoking GNU Fortran.
                                                              (line   6)
* command-line arguments:                COMMAND_ARGUMENT_COUNT.
                                                              (line   6)
* command-line arguments <1>:            GETARG.              (line   6)
* command-line arguments <2>:            GET_COMMAND.         (line   6)
* command-line arguments <3>:            GET_COMMAND_ARGUMENT.
                                                              (line   6)
* command-line arguments <4>:            IARGC.               (line   6)
* command-line arguments, number of:     COMMAND_ARGUMENT_COUNT.
                                                              (line   6)
* command-line arguments, number of <1>: IARGC.               (line   6)
* COMMAND_ARGUMENT_COUNT:                COMMAND_ARGUMENT_COUNT.
                                                              (line   6)
* 'COMMON':                              Volatile COMMON blocks.
                                                              (line   6)
* compiler flags inquiry function:       COMPILER_OPTIONS.    (line   6)
* compiler, name and version:            COMPILER_VERSION.    (line   6)
* COMPILER_OPTIONS:                      COMPILER_OPTIONS.    (line   6)
* COMPILER_VERSION:                      COMPILER_VERSION.    (line   6)
* COMPLEX:                               COMPLEX.             (line   6)
* complex conjugate:                     CONJG.               (line   6)
* Complex function:                      Alternate complex function syntax.
                                                              (line   6)
* complex numbers, conversion to:        CMPLX.               (line   6)
* complex numbers, conversion to <1>:    COMPLEX.             (line   6)
* complex numbers, conversion to <2>:    DCMPLX.              (line   6)
* complex numbers, imaginary part:       AIMAG.               (line   6)
* complex numbers, real part:            DREAL.               (line   6)
* complex numbers, real part <1>:        REAL.                (line   6)
* Conditional compilation:               Preprocessing and conditional compilation.
                                                              (line   6)
* CONJG:                                 CONJG.               (line   6)
* consistency, durability:               Data consistency and durability.
                                                              (line   6)
* Contributing:                          Contributing.        (line   6)
* Contributors:                          Contributors.        (line   6)
* conversion:                            Error and Warning Options.
                                                              (line 122)
* conversion <1>:                        Error and Warning Options.
                                                              (line 126)
* conversion, to character:              CHAR.                (line   6)
* conversion, to complex:                CMPLX.               (line   6)
* conversion, to complex <1>:            COMPLEX.             (line   6)
* conversion, to complex <2>:            DCMPLX.              (line   6)
* conversion, to integer:                Implicitly convert LOGICAL and INTEGER values.
                                                              (line   6)
* conversion, to integer <1>:            IACHAR.              (line   6)
* conversion, to integer <2>:            ICHAR.               (line   6)
* conversion, to integer <3>:            INT.                 (line   6)
* conversion, to integer <4>:            INT2.                (line   6)
* conversion, to integer <5>:            INT8.                (line   6)
* conversion, to integer <6>:            LONG.                (line   6)
* conversion, to logical:                Implicitly convert LOGICAL and INTEGER values.
                                                              (line   6)
* conversion, to logical <1>:            LOGICAL.             (line   6)
* conversion, to real:                   DBLE.                (line   6)
* conversion, to real <1>:               REAL.                (line   6)
* conversion, to string:                 CTIME.               (line   6)
* 'CONVERT' specifier:                   CONVERT specifier.   (line   6)
* core, dump:                            ABORT.               (line   6)
* COS:                                   COS.                 (line   6)
* COSD:                                  COSD.                (line   6)
* COSH:                                  COSH.                (line   6)
* cosine:                                COS.                 (line   6)
* cosine, degrees:                       COSD.                (line   6)
* cosine, hyperbolic:                    COSH.                (line   6)
* cosine, hyperbolic, inverse:           ACOSH.               (line   6)
* cosine, inverse:                       ACOS.                (line   6)
* cosine, inverse, degrees:              ACOSD.               (line   6)
* COTAN:                                 COTAN.               (line   6)
* COTAND:                                COTAND.              (line   6)
* cotangent:                             COTAN.               (line   6)
* cotangent, degrees:                    COTAND.              (line   6)
* COUNT:                                 COUNT.               (line   6)
* CO_BROADCAST:                          CO_BROADCAST.        (line   6)
* CO_MAX:                                CO_MAX.              (line   6)
* CO_MIN:                                CO_MIN.              (line   6)
* CO_REDUCE:                             CO_REDUCE.           (line   6)
* CO_SUM:                                CO_SUM.              (line   6)
* CPP:                                   Preprocessing and conditional compilation.
                                                              (line   6)
* CPP <1>:                               Preprocessing Options.
                                                              (line   6)
* CPU_TIME:                              CPU_TIME.            (line   6)
* Credits:                               Contributors.        (line   6)
* CSHIFT:                                CSHIFT.              (line   6)
* CSIN:                                  SIN.                 (line   6)
* CSIND:                                 SIND.                (line   6)
* CSQRT:                                 SQRT.                (line   6)
* CTIME:                                 CTIME.               (line   6)
* current date:                          DATE_AND_TIME.       (line   6)
* current date <1>:                      FDATE.               (line   6)
* current date <2>:                      IDATE.               (line   6)
* current time:                          DATE_AND_TIME.       (line   6)
* current time <1>:                      FDATE.               (line   6)
* current time <2>:                      ITIME.               (line   6)
* current time <3>:                      TIME.                (line   6)
* current time <4>:                      TIME8.               (line   6)
* C_ASSOCIATED:                          C_ASSOCIATED.        (line   6)
* C_FUNLOC:                              C_FUNLOC.            (line   6)
* C_F_POINTER:                           C_F_POINTER.         (line   6)
* C_F_PROCPOINTER:                       C_F_PROCPOINTER.     (line   6)
* C_LOC:                                 C_LOC.               (line   6)
* C_SIZEOF:                              C_SIZEOF.            (line   6)
* DABS:                                  ABS.                 (line   6)
* DACOS:                                 ACOS.                (line   6)
* DACOSD:                                ACOSD.               (line   6)
* DACOSH:                                ACOSH.               (line   6)
* DASIN:                                 ASIN.                (line   6)
* DASIND:                                ASIND.               (line   6)
* DASINH:                                ASINH.               (line   6)
* DATAN:                                 ATAN.                (line   6)
* DATAN2:                                ATAN2.               (line   6)
* DATAN2D:                               ATAN2D.              (line   6)
* DATAND:                                ATAND.               (line   6)
* DATANH:                                ATANH.               (line   6)
* date, current:                         DATE_AND_TIME.       (line   6)
* date, current <1>:                     FDATE.               (line   6)
* date, current <2>:                     IDATE.               (line   6)
* DATE_AND_TIME:                         DATE_AND_TIME.       (line   6)
* DBESJ0:                                BESSEL_J0.           (line   6)
* DBESJ1:                                BESSEL_J1.           (line   6)
* DBESJN:                                BESSEL_JN.           (line   6)
* DBESY0:                                BESSEL_Y0.           (line   6)
* DBESY1:                                BESSEL_Y1.           (line   6)
* DBESYN:                                BESSEL_YN.           (line   6)
* DBLE:                                  DBLE.                (line   6)
* DCMPLX:                                DCMPLX.              (line   6)
* DCONJG:                                CONJG.               (line   6)
* DCOS:                                  COS.                 (line   6)
* DCOSD:                                 COSD.                (line   6)
* DCOSH:                                 COSH.                (line   6)
* DCOTAN:                                COTAN.               (line   6)
* DCOTAND:                               COTAND.              (line   6)
* DDIM:                                  DIM.                 (line   6)
* debugging information options:         Debugging Options.   (line   6)
* debugging, preprocessor:               Preprocessing Options.
                                                              (line  26)
* debugging, preprocessor <1>:           Preprocessing Options.
                                                              (line  35)
* debugging, preprocessor <2>:           Preprocessing Options.
                                                              (line  41)
* debugging, preprocessor <3>:           Preprocessing Options.
                                                              (line  44)
* debugging, preprocessor <4>:           Preprocessing Options.
                                                              (line  51)
* 'DECODE':                              ENCODE and DECODE statements.
                                                              (line   6)
* delayed execution:                     ALARM.               (line   6)
* delayed execution <1>:                 SLEEP.               (line   6)
* DEXP:                                  EXP.                 (line   6)
* DFLOAT:                                REAL.                (line   6)
* DGAMMA:                                GAMMA.               (line   6)
* dialect options:                       Fortran Dialect Options.
                                                              (line   6)
* DIGITS:                                DIGITS.              (line   6)
* DIM:                                   DIM.                 (line   6)
* DIMAG:                                 AIMAG.               (line   6)
* DINT:                                  AINT.                (line   6)
* directive, 'INCLUDE':                  Directory Options.   (line   6)
* directory, options:                    Directory Options.   (line   6)
* directory, search paths for inclusion: Directory Options.   (line  14)
* division, modulo:                      MODULO.              (line   6)
* division, remainder:                   MOD.                 (line   6)
* DLGAMA:                                LOG_GAMMA.           (line   6)
* DLOG:                                  LOG.                 (line   6)
* DLOG10:                                LOG10.               (line   6)
* DMAX1:                                 MAX.                 (line   6)
* DMIN1:                                 MIN.                 (line   6)
* DMOD:                                  MOD.                 (line   6)
* DNINT:                                 ANINT.               (line   6)
* dot product:                           DOT_PRODUCT.         (line   6)
* DOT_PRODUCT:                           DOT_PRODUCT.         (line   6)
* DPROD:                                 DPROD.               (line   6)
* DREAL:                                 DREAL.               (line   6)
* DSHIFTL:                               DSHIFTL.             (line   6)
* DSHIFTR:                               DSHIFTR.             (line   6)
* DSIGN:                                 SIGN.                (line   6)
* DSIN:                                  SIN.                 (line   6)
* DSIND:                                 SIND.                (line   6)
* DSINH:                                 SINH.                (line   6)
* DSQRT:                                 SQRT.                (line   6)
* DTAN:                                  TAN.                 (line   6)
* DTAND:                                 TAND.                (line   6)
* DTANH:                                 TANH.                (line   6)
* DTIME:                                 DTIME.               (line   6)
* dummy argument, unused:                Error and Warning Options.
                                                              (line 215)
* elapsed time:                          DTIME.               (line   6)
* elapsed time <1>:                      SECNDS.              (line   6)
* elapsed time <2>:                      SECOND.              (line   6)
* Elimination of functions with identical argument lists: Code Gen Options.
                                                              (line 406)
* 'ENCODE':                              ENCODE and DECODE statements.
                                                              (line   6)
* 'ENUM' statement:                      Fortran 2003 status. (line  92)
* 'ENUMERATOR' statement:                Fortran 2003 status. (line  92)
* environment variable:                  Environment Variables.
                                                              (line   6)
* environment variable <1>:              Runtime.             (line   6)
* environment variable <2>:              GETENV.              (line   6)
* environment variable <3>:              GET_ENVIRONMENT_VARIABLE.
                                                              (line   6)
* 'EOF':                                 Read/Write after EOF marker.
                                                              (line   6)
* EOSHIFT:                               EOSHIFT.             (line   6)
* EPSILON:                               EPSILON.             (line   6)
* ERF:                                   ERF.                 (line   6)
* ERFC:                                  ERFC.                (line   6)
* ERFC_SCALED:                           ERFC_SCALED.         (line   6)
* error function:                        ERF.                 (line   6)
* error function, complementary:         ERFC.                (line   6)
* error function, complementary, exponentially-scaled: ERFC_SCALED.
                                                              (line   6)
* errors, limiting:                      Error and Warning Options.
                                                              (line  27)
* escape characters:                     Fortran Dialect Options.
                                                              (line  79)
* ETIME:                                 ETIME.               (line   6)
* Euclidean distance:                    HYPOT.               (line   6)
* Euclidean vector norm:                 NORM2.               (line   6)
* Events, EVENT_QUERY:                   EVENT_QUERY.         (line   6)
* EVENT_QUERY:                           EVENT_QUERY.         (line   6)
* EXECUTE_COMMAND_LINE:                  EXECUTE_COMMAND_LINE.
                                                              (line   6)
* EXIT:                                  EXIT.                (line   6)
* EXP:                                   EXP.                 (line   6)
* EXPONENT:                              EXPONENT.            (line   6)
* exponent:                              Default exponents.   (line   6)
* exponential function:                  EXP.                 (line   6)
* exponential function, inverse:         LOG.                 (line   6)
* exponential function, inverse <1>:     LOG10.               (line   6)
* expression size:                       C_SIZEOF.            (line   6)
* expression size <1>:                   SIZEOF.              (line   6)
* EXTENDS_TYPE_OF:                       EXTENDS_TYPE_OF.     (line   6)
* extensions:                            Extensions.          (line   6)
* extensions, implemented:               Extensions implemented in GNU Fortran.
                                                              (line   6)
* extensions, not implemented:           Extensions not implemented in GNU Fortran.
                                                              (line   6)
* extra warnings:                        Error and Warning Options.
                                                              (line 130)
* 'f2c' calling convention:              Code Gen Options.    (line  28)
* 'f2c' calling convention <1>:          Code Gen Options.    (line 113)
* Factorial function:                    GAMMA.               (line   6)
* FDATE:                                 FDATE.               (line   6)
* FDL, GNU Free Documentation License:   GNU Free Documentation License.
                                                              (line   6)
* FGET:                                  FGET.                (line   6)
* FGETC:                                 FGETC.               (line   6)
* file format, fixed:                    Fortran Dialect Options.
                                                              (line  11)
* file format, fixed <1>:                Fortran Dialect Options.
                                                              (line  96)
* file format, free:                     Fortran Dialect Options.
                                                              (line  11)
* file format, free <1>:                 Fortran Dialect Options.
                                                              (line 118)
* file operation, file number:           FNUM.                (line   6)
* file operation, flush:                 FLUSH.               (line   6)
* file operation, position:              FSEEK.               (line   6)
* file operation, position <1>:          FTELL.               (line   6)
* file operation, read character:        FGET.                (line   6)
* file operation, read character <1>:    FGETC.               (line   6)
* file operation, seek:                  FSEEK.               (line   6)
* file operation, write character:       FPUT.                (line   6)
* file operation, write character <1>:   FPUTC.               (line   6)
* file system, access mode:              ACCESS.              (line   6)
* file system, change access mode:       CHMOD.               (line   6)
* file system, create link:              LINK.                (line   6)
* file system, create link <1>:          SYMLNK.              (line   6)
* file system, file creation mask:       UMASK.               (line   6)
* file system, file status:              FSTAT.               (line   6)
* file system, file status <1>:          LSTAT.               (line   6)
* file system, file status <2>:          STAT.                (line   6)
* file system, hard link:                LINK.                (line   6)
* file system, remove file:              UNLINK.              (line   6)
* file system, rename file:              RENAME.              (line   6)
* file system, soft link:                SYMLNK.              (line   6)
* file, symbolic link:                   File operations on symbolic links.
                                                              (line   6)
* file, unformatted sequential:          File format of unformatted sequential files.
                                                              (line   6)
* FINDLOC:                               FINDLOC.             (line   6)
* findloc:                               FINDLOC.             (line   6)
* flags inquiry function:                COMPILER_OPTIONS.    (line   6)
* FLOAT:                                 REAL.                (line   6)
* FLOATI:                                REAL.                (line   6)
* floating point, exponent:              EXPONENT.            (line   6)
* floating point, fraction:              FRACTION.            (line   6)
* floating point, nearest different:     NEAREST.             (line   6)
* floating point, relative spacing:      RRSPACING.           (line   6)
* floating point, relative spacing <1>:  SPACING.             (line   6)
* floating point, scale:                 SCALE.               (line   6)
* floating point, set exponent:          SET_EXPONENT.        (line   6)
* FLOATJ:                                REAL.                (line   6)
* FLOATK:                                REAL.                (line   6)
* FLOOR:                                 FLOOR.               (line   6)
* floor:                                 AINT.                (line   6)
* floor <1>:                             FLOOR.               (line   6)
* FLUSH:                                 FLUSH.               (line   6)
* 'FLUSH' statement:                     Fortran 2003 status. (line  88)
* FNUM:                                  FNUM.                (line   6)
* form feed whitespace:                  Form feed as whitespace.
                                                              (line   6)
* 'FORMAT':                              Variable FORMAT expressions.
                                                              (line   6)
* Fortran 77:                            GNU Fortran and G77. (line   6)
* FPP:                                   Preprocessing and conditional compilation.
                                                              (line   6)
* FPUT:                                  FPUT.                (line   6)
* FPUTC:                                 FPUTC.               (line   6)
* FRACTION:                              FRACTION.            (line   6)
* FREE:                                  FREE.                (line   6)
* Front-end optimization:                Code Gen Options.    (line 414)
* FSEEK:                                 FSEEK.               (line   6)
* FSTAT:                                 FSTAT.               (line   6)
* FTELL:                                 FTELL.               (line   6)
* function elimination:                  Error and Warning Options.
                                                              (line 232)
* 'g77':                                 GNU Fortran and G77. (line   6)
* 'g77' calling convention:              Code Gen Options.    (line  28)
* 'g77' calling convention <1>:          Code Gen Options.    (line 113)
* GAMMA:                                 GAMMA.               (line   6)
* Gamma function:                        GAMMA.               (line   6)
* Gamma function, logarithm of:          LOG_GAMMA.           (line   6)
* GCC:                                   GNU Fortran and GCC. (line   6)
* Generating C prototypes from external procedures: Interoperability Options.
                                                              (line  25)
* Generating C prototypes from Fortran BIND(C) enteties: Interoperability Options.
                                                              (line   7)
* GERROR:                                GERROR.              (line   6)
* GETARG:                                GETARG.              (line   6)
* GETCWD:                                GETCWD.              (line   6)
* GETENV:                                GETENV.              (line   6)
* GETGID:                                GETGID.              (line   6)
* GETLOG:                                GETLOG.              (line   6)
* GETPID:                                GETPID.              (line   6)
* GETUID:                                GETUID.              (line   6)
* GET_COMMAND:                           GET_COMMAND.         (line   6)
* GET_COMMAND_ARGUMENT:                  GET_COMMAND_ARGUMENT.
                                                              (line   6)
* GET_ENVIRONMENT_VARIABLE:              GET_ENVIRONMENT_VARIABLE.
                                                              (line   6)
* GMTIME:                                GMTIME.              (line   6)
* GNU Compiler Collection:               GNU Fortran and GCC. (line   6)
* GNU Fortran command options:           Invoking GNU Fortran.
                                                              (line   6)
* Hollerith constants:                   Hollerith constants support.
                                                              (line   6)
* HOSTNM:                                HOSTNM.              (line   6)
* HUGE:                                  HUGE.                (line   6)
* hyperbolic cosine:                     COSH.                (line   6)
* hyperbolic function, cosine:           COSH.                (line   6)
* hyperbolic function, cosine, inverse:  ACOSH.               (line   6)
* hyperbolic function, sine:             SINH.                (line   6)
* hyperbolic function, sine, inverse:    ASINH.               (line   6)
* hyperbolic function, tangent:          TANH.                (line   6)
* hyperbolic function, tangent, inverse: ATANH.               (line   6)
* hyperbolic sine:                       SINH.                (line   6)
* hyperbolic tangent:                    TANH.                (line   6)
* HYPOT:                                 HYPOT.               (line   6)
* I/O item lists:                        I/O item lists.      (line   6)
* I/O specifiers:                        Extended I/O specifiers.
                                                              (line   6)
* IABS:                                  ABS.                 (line   6)
* IACHAR:                                IACHAR.              (line   6)
* IALL:                                  IALL.                (line   6)
* IAND:                                  IAND.                (line   6)
* IANY:                                  IANY.                (line   6)
* IARGC:                                 IARGC.               (line   6)
* IBCLR:                                 IBCLR.               (line   6)
* IBITS:                                 IBITS.               (line   6)
* IBSET:                                 IBSET.               (line   6)
* ICHAR:                                 ICHAR.               (line   6)
* IDATE:                                 IDATE.               (line   6)
* IDIM:                                  DIM.                 (line   6)
* IDINT:                                 INT.                 (line   6)
* IDNINT:                                NINT.                (line   6)
* IEEE, ISNAN:                           ISNAN.               (line   6)
* IEOR:                                  IEOR.                (line   6)
* IERRNO:                                IERRNO.              (line   6)
* IFIX:                                  INT.                 (line   6)
* IIABS:                                 ABS.                 (line   6)
* IIAND:                                 IAND.                (line   6)
* IIBCLR:                                IBCLR.               (line   6)
* IIBITS:                                IBITS.               (line   6)
* IIBSET:                                IBSET.               (line   6)
* IIEOR:                                 IEOR.                (line   6)
* IIOR:                                  IOR.                 (line   6)
* IISHFT:                                ISHFT.               (line   6)
* IISHFTC:                               ISHFTC.              (line   6)
* IMAG:                                  AIMAG.               (line   6)
* images, cosubscript to image index conversion: IMAGE_INDEX. (line   6)
* images, index of this image:           THIS_IMAGE.          (line   6)
* images, number of:                     NUM_IMAGES.          (line   6)
* IMAGE_INDEX:                           IMAGE_INDEX.         (line   6)
* IMAGPART:                              AIMAG.               (line   6)
* IMOD:                                  MOD.                 (line   6)
* 'IMPORT' statement:                    Fortran 2003 status. (line 119)
* IMVBITS:                               MVBITS.              (line   6)
* 'INCLUDE' directive:                   Directory Options.   (line   6)
* inclusion, directory search paths for: Directory Options.   (line  14)
* INDEX:                                 INDEX intrinsic.     (line   6)
* INOT:                                  NOT.                 (line   6)
* input/output, asynchronous:            Asynchronous I/O.    (line   6)
* INT:                                   INT.                 (line   6)
* INT2:                                  INT2.                (line   6)
* INT8:                                  INT8.                (line   6)
* integer kind:                          SELECTED_INT_KIND.   (line   6)
* Interoperability:                      Mixed-Language Programming.
                                                              (line   6)
* intrinsic:                             Error and Warning Options.
                                                              (line 204)
* intrinsic <1>:                         Error and Warning Options.
                                                              (line 211)
* intrinsic Modules:                     Intrinsic Modules.   (line   6)
* intrinsic procedures:                  Intrinsic Procedures.
                                                              (line   6)
* intrinsics, integer:                   Type variants for integer intrinsics.
                                                              (line   6)
* intrinsics, math:                      Extended math intrinsics.
                                                              (line   6)
* intrinsics, trigonometric functions:   Extended math intrinsics.
                                                              (line   6)
* Introduction:                          Top.                 (line   6)
* inverse hyperbolic cosine:             ACOSH.               (line   6)
* inverse hyperbolic sine:               ASINH.               (line   6)
* inverse hyperbolic tangent:            ATANH.               (line   6)
* 'IOMSG=' specifier:                    Fortran 2003 status. (line  90)
* IOR:                                   IOR.                 (line   6)
* 'IOSTAT', end of file:                 IS_IOSTAT_END.       (line   6)
* 'IOSTAT', end of record:               IS_IOSTAT_EOR.       (line   6)
* IPARITY:                               IPARITY.             (line   6)
* IRAND:                                 IRAND.               (line   6)
* ISATTY:                                ISATTY.              (line   6)
* ISHFT:                                 ISHFT.               (line   6)
* ISHFTC:                                ISHFTC.              (line   6)
* ISIGN:                                 SIGN.                (line   6)
* ISNAN:                                 ISNAN.               (line   6)
* 'ISO_FORTRAN_ENV' statement:           Fortran 2003 status. (line 127)
* IS_IOSTAT_END:                         IS_IOSTAT_END.       (line   6)
* IS_IOSTAT_EOR:                         IS_CONTIGUOUS.       (line   6)
* IS_IOSTAT_EOR <1>:                     IS_IOSTAT_EOR.       (line   6)
* ITIME:                                 ITIME.               (line   6)
* JIABS:                                 ABS.                 (line   6)
* JIAND:                                 IAND.                (line   6)
* JIBCLR:                                IBCLR.               (line   6)
* JIBITS:                                IBITS.               (line   6)
* JIBSET:                                IBSET.               (line   6)
* JIEOR:                                 IEOR.                (line   6)
* JIOR:                                  IOR.                 (line   6)
* JISHFT:                                ISHFT.               (line   6)
* JISHFTC:                               ISHFTC.              (line   6)
* JMOD:                                  MOD.                 (line   6)
* JMVBITS:                               MVBITS.              (line   6)
* JNOT:                                  NOT.                 (line   6)
* KIABS:                                 ABS.                 (line   6)
* KIAND:                                 IAND.                (line   6)
* KIBCLR:                                IBCLR.               (line   6)
* KIBITS:                                IBITS.               (line   6)
* KIBSET:                                IBSET.               (line   6)
* KIEOR:                                 IEOR.                (line   6)
* KILL:                                  KILL.                (line   6)
* kind:                                  KIND Type Parameters.
                                                              (line   6)
* KIND:                                  KIND.                (line   6)
* kind <1>:                              KIND.                (line   6)
* kind, character:                       SELECTED_CHAR_KIND.  (line   6)
* kind, integer:                         SELECTED_INT_KIND.   (line   6)
* kind, old-style:                       Old-style kind specifications.
                                                              (line   6)
* kind, real:                            SELECTED_REAL_KIND.  (line   6)
* KIOR:                                  IOR.                 (line   6)
* KISHFT:                                ISHFT.               (line   6)
* KISHFTC:                               ISHFTC.              (line   6)
* KMOD:                                  MOD.                 (line   6)
* KMVBITS:                               MVBITS.              (line   6)
* KNOT:                                  NOT.                 (line   6)
* L2 vector norm:                        NORM2.               (line   6)
* language, dialect options:             Fortran Dialect Options.
                                                              (line   6)
* LBOUND:                                LBOUND.              (line   6)
* LCOBOUND:                              LCOBOUND.            (line   6)
* LEADZ:                                 LEADZ.               (line   6)
* left shift, combined:                  DSHIFTL.             (line   6)
* LEN:                                   LEN.                 (line   6)
* LEN_TRIM:                              LEN_TRIM.            (line   6)
* lexical comparison of strings:         LGE.                 (line   6)
* lexical comparison of strings <1>:     LGT.                 (line   6)
* lexical comparison of strings <2>:     LLE.                 (line   6)
* lexical comparison of strings <3>:     LLT.                 (line   6)
* LGAMMA:                                LOG_GAMMA.           (line   6)
* LGE:                                   LGE.                 (line   6)
* LGT:                                   LGT.                 (line   6)
* libf2c calling convention:             Code Gen Options.    (line  28)
* libf2c calling convention <1>:         Code Gen Options.    (line 113)
* libgfortran initialization, set_args:  _gfortran_set_args.  (line   6)
* libgfortran initialization, set_convert: _gfortran_set_convert.
                                                              (line   6)
* libgfortran initialization, set_fpe:   _gfortran_set_fpe.   (line   6)
* libgfortran initialization, set_max_subrecord_length: _gfortran_set_max_subrecord_length.
                                                              (line   6)
* libgfortran initialization, set_options: _gfortran_set_options.
                                                              (line   6)
* libgfortran initialization, set_record_marker: _gfortran_set_record_marker.
                                                              (line   6)
* limits, largest number:                HUGE.                (line   6)
* limits, smallest number:               TINY.                (line   6)
* LINK:                                  LINK.                (line   6)
* linking, static:                       Link Options.        (line   6)
* LLE:                                   LLE.                 (line   6)
* LLT:                                   LLT.                 (line   6)
* LNBLNK:                                LNBLNK.              (line   6)
* LOC:                                   %LOC as an rvalue.   (line   6)
* LOC <1>:                               LOC.                 (line   6)
* location of a variable in memory:      LOC.                 (line   6)
* LOG:                                   LOG.                 (line   6)
* LOG10:                                 LOG10.               (line   6)
* logarithm function:                    LOG.                 (line   6)
* logarithm function with base 10:       LOG10.               (line   6)
* logarithm function, inverse:           EXP.                 (line   6)
* LOGICAL:                               LOGICAL.             (line   6)
* logical and, bitwise:                  AND.                 (line   6)
* logical and, bitwise <1>:              IAND.                (line   6)
* logical exclusive or, bitwise:         IEOR.                (line   6)
* logical exclusive or, bitwise <1>:     XOR.                 (line   6)
* logical not, bitwise:                  NOT.                 (line   6)
* logical or, bitwise:                   IOR.                 (line   6)
* logical or, bitwise <1>:               OR.                  (line   6)
* logical, bitwise:                      Bitwise logical operators.
                                                              (line   6)
* logical, variable representation:      Internal representation of LOGICAL variables.
                                                              (line   6)
* login name:                            GETLOG.              (line   6)
* LOG_GAMMA:                             LOG_GAMMA.           (line   6)
* LONG:                                  LONG.                (line   6)
* loop interchange, Fortran:             Code Gen Options.    (line 427)
* loop interchange, warning:             Error and Warning Options.
                                                              (line 135)
* LSHIFT:                                LSHIFT.              (line   6)
* LSTAT:                                 LSTAT.               (line   6)
* LTIME:                                 LTIME.               (line   6)
* MALLOC:                                MALLOC.              (line   6)
* 'MAP':                                 UNION and MAP.       (line   6)
* mask, left justified:                  MASKL.               (line   6)
* mask, right justified:                 MASKR.               (line   6)
* MASKL:                                 MASKL.               (line   6)
* MASKR:                                 MASKR.               (line   6)
* MATMUL:                                MATMUL.              (line   6)
* matrix multiplication:                 MATMUL.              (line   6)
* matrix, transpose:                     TRANSPOSE.           (line   6)
* MAX:                                   MAX.                 (line   6)
* MAX, MIN, NaN:                         MAX and MIN intrinsics with REAL NaN arguments.
                                                              (line   6)
* MAX0:                                  MAX.                 (line   6)
* MAX1:                                  MAX.                 (line   6)
* MAXEXPONENT:                           MAXEXPONENT.         (line   6)
* maximum value:                         MAX.                 (line   6)
* maximum value <1>:                     MAXVAL.              (line   6)
* MAXLOC:                                MAXLOC.              (line   6)
* MAXVAL:                                MAXVAL.              (line   6)
* MCLOCK:                                MCLOCK.              (line   6)
* MCLOCK8:                               MCLOCK8.             (line   6)
* memory checking:                       Code Gen Options.    (line 144)
* MERGE:                                 MERGE.               (line   6)
* MERGE_BITS:                            MERGE_BITS.          (line   6)
* messages, error:                       Error and Warning Options.
                                                              (line   6)
* messages, warning:                     Error and Warning Options.
                                                              (line   6)
* MIN:                                   MIN.                 (line   6)
* MIN0:                                  MIN.                 (line   6)
* MIN1:                                  MIN.                 (line   6)
* MINEXPONENT:                           MINEXPONENT.         (line   6)
* minimum value:                         MIN.                 (line   6)
* minimum value <1>:                     MINVAL.              (line   6)
* MINLOC:                                MINLOC.              (line   6)
* MINVAL:                                MINVAL.              (line   6)
* Mixed-language programming:            Mixed-Language Programming.
                                                              (line   6)
* MOD:                                   MOD.                 (line   6)
* model representation, base:            RADIX.               (line   6)
* model representation, epsilon:         EPSILON.             (line   6)
* model representation, largest number:  HUGE.                (line   6)
* model representation, maximum exponent: MAXEXPONENT.        (line   6)
* model representation, minimum exponent: MINEXPONENT.        (line   6)
* model representation, precision:       PRECISION.           (line   6)
* model representation, radix:           RADIX.               (line   6)
* model representation, range:           RANGE.               (line   6)
* model representation, significant digits: DIGITS.           (line   6)
* model representation, smallest number: TINY.                (line   6)
* module entities:                       Fortran Dialect Options.
                                                              (line  91)
* module search path:                    Directory Options.   (line  14)
* module search path <1>:                Directory Options.   (line  29)
* module search path <2>:                Directory Options.   (line  36)
* MODULO:                                MODULO.              (line   6)
* modulo:                                MODULO.              (line   6)
* MOVE_ALLOC:                            MOVE_ALLOC.          (line   6)
* moving allocation:                     MOVE_ALLOC.          (line   6)
* multiply array elements:               PRODUCT.             (line   6)
* MVBITS:                                MVBITS.              (line   6)
* 'NAME':                                OPEN( ... NAME=).    (line   6)
* Namelist:                              Extensions to namelist.
                                                              (line   6)
* natural logarithm function:            LOG.                 (line   6)
* NEAREST:                               NEAREST.             (line   6)
* newline:                               NEW_LINE.            (line   6)
* NEW_LINE:                              NEW_LINE.            (line   6)
* NINT:                                  NINT.                (line   6)
* norm, Euclidean:                       NORM2.               (line   6)
* NORM2:                                 NORM2.               (line   6)
* 'NOSHARED':                            Extended I/O specifiers.
                                                              (line   6)
* NOT:                                   NOT.                 (line   6)
* NULL:                                  NULL.                (line   6)
* NUM_IMAGES:                            NUM_IMAGES.          (line   6)
* open, action:                          Files opened without an explicit ACTION= specifier.
                                                              (line   6)
* OpenACC:                               Fortran Dialect Options.
                                                              (line 138)
* OpenACC <1>:                           OpenACC.             (line   6)
* OpenMP:                                Fortran Dialect Options.
                                                              (line 149)
* OpenMP <1>:                            OpenMP.              (line   6)
* operators, unary:                      Unary operators.     (line   6)
* operators, xor:                        .XOR. operator.      (line   6)
* options inquiry function:              COMPILER_OPTIONS.    (line   6)
* options, code generation:              Code Gen Options.    (line   6)
* options, debugging:                    Debugging Options.   (line   6)
* options, dialect:                      Fortran Dialect Options.
                                                              (line   6)
* options, directory search:             Directory Options.   (line   6)
* options, errors:                       Error and Warning Options.
                                                              (line   6)
* options, Fortran dialect:              Fortran Dialect Options.
                                                              (line  11)
* options, 'gfortran' command:           Invoking GNU Fortran.
                                                              (line   6)
* options, linking:                      Link Options.        (line   6)
* options, negative forms:               Invoking GNU Fortran.
                                                              (line  13)
* options, preprocessor:                 Preprocessing Options.
                                                              (line   6)
* options, real kind type promotion:     Fortran Dialect Options.
                                                              (line 228)
* options, run-time:                     Code Gen Options.    (line   6)
* options, runtime:                      Runtime Options.     (line   6)
* options, warnings:                     Error and Warning Options.
                                                              (line   6)
* OR:                                    OR.                  (line   6)
* output, newline:                       NEW_LINE.            (line   6)
* PACK:                                  PACK.                (line   6)
* PARAMETER:                             Legacy PARAMETER statements.
                                                              (line   6)
* PARITY:                                PARITY.              (line   6)
* Parity:                                PARITY.              (line   6)
* parity:                                POPPAR.              (line   6)
* paths, search:                         Directory Options.   (line  14)
* paths, search <1>:                     Directory Options.   (line  29)
* paths, search <2>:                     Directory Options.   (line  36)
* PERROR:                                PERROR.              (line   6)
* pointer checking:                      Code Gen Options.    (line 144)
* pointer, C address of pointers:        C_F_PROCPOINTER.     (line   6)
* pointer, C address of procedures:      C_FUNLOC.            (line   6)
* pointer, C association status:         C_ASSOCIATED.        (line   6)
* pointer, convert C to Fortran:         C_F_POINTER.         (line   6)
* pointer, Cray:                         Cray pointers.       (line   6)
* pointer, cray:                         FREE.                (line   6)
* pointer, cray <1>:                     MALLOC.              (line   6)
* pointer, disassociated:                NULL.                (line   6)
* pointer, status:                       ASSOCIATED.          (line   6)
* pointer, status <1>:                   NULL.                (line   6)
* POPCNT:                                POPCNT.              (line   6)
* POPPAR:                                POPPAR.              (line   6)
* positive difference:                   DIM.                 (line   6)
* PRECISION:                             PRECISION.           (line   6)
* Preprocessing:                         Preprocessing and conditional compilation.
                                                              (line   6)
* preprocessing, assertion:              Preprocessing Options.
                                                              (line 113)
* preprocessing, assertion <1>:          Preprocessing Options.
                                                              (line 119)
* preprocessing, define macros:          Preprocessing Options.
                                                              (line 151)
* preprocessing, define macros <1>:      Preprocessing Options.
                                                              (line 154)
* preprocessing, include path:           Preprocessing Options.
                                                              (line  69)
* preprocessing, include path <1>:       Preprocessing Options.
                                                              (line  76)
* preprocessing, include path <2>:       Preprocessing Options.
                                                              (line  80)
* preprocessing, include path <3>:       Preprocessing Options.
                                                              (line  85)
* preprocessing, include path <4>:       Preprocessing Options.
                                                              (line  89)
* preprocessing, include path <5>:       Preprocessing Options.
                                                              (line  96)
* preprocessing, keep comments:          Preprocessing Options.
                                                              (line 122)
* preprocessing, keep comments <1>:      Preprocessing Options.
                                                              (line 137)
* preprocessing, no linemarkers:         Preprocessing Options.
                                                              (line 179)
* preprocessing, undefine macros:        Preprocessing Options.
                                                              (line 185)
* preprocessor:                          Preprocessing Options.
                                                              (line   6)
* preprocessor, debugging:               Preprocessing Options.
                                                              (line  26)
* preprocessor, debugging <1>:           Preprocessing Options.
                                                              (line  35)
* preprocessor, debugging <2>:           Preprocessing Options.
                                                              (line  41)
* preprocessor, debugging <3>:           Preprocessing Options.
                                                              (line  44)
* preprocessor, debugging <4>:           Preprocessing Options.
                                                              (line  51)
* preprocessor, disable:                 Preprocessing Options.
                                                              (line  12)
* preprocessor, enable:                  Preprocessing Options.
                                                              (line  12)
* preprocessor, include file handling:   Preprocessing and conditional compilation.
                                                              (line   6)
* preprocessor, working directory:       Preprocessing Options.
                                                              (line  55)
* PRESENT:                               PRESENT.             (line   6)
* private:                               Fortran Dialect Options.
                                                              (line  91)
* procedure pointer, convert C to Fortran: C_LOC.             (line   6)
* process ID:                            GETPID.              (line   6)
* PRODUCT:                               PRODUCT.             (line   6)
* product, double-precision:             DPROD.               (line   6)
* product, matrix:                       MATMUL.              (line   6)
* product, vector:                       DOT_PRODUCT.         (line   6)
* program termination:                   EXIT.                (line   6)
* program termination, with core dump:   ABORT.               (line   6)
* 'PROTECTED' statement:                 Fortran 2003 status. (line 113)
* 'Q' edit descriptor:                   Q edit descriptor.   (line   6)
* 'Q' exponent-letter:                   'Q' exponent-letter. (line   6)
* RADIX:                                 RADIX.               (line   6)
* radix, real:                           SELECTED_REAL_KIND.  (line   6)
* RAN:                                   RAN.                 (line   6)
* RAND:                                  RAND.                (line   6)
* random number generation:              IRAND.               (line   6)
* random number generation <1>:          RAN.                 (line   6)
* random number generation <2>:          RAND.                (line   6)
* random number generation <3>:          RANDOM_NUMBER.       (line   6)
* random number generation, initialization: RANDOM_INIT.      (line   6)
* random number generation, seeding:     RANDOM_SEED.         (line   6)
* random number generation, seeding <1>: SRAND.               (line   6)
* RANDOM_INIT:                           RANDOM_INIT.         (line   6)
* RANDOM_NUMBER:                         RANDOM_NUMBER.       (line   6)
* RANDOM_SEED:                           RANDOM_SEED.         (line   6)
* RANGE:                                 RANGE.               (line   6)
* range checking:                        Code Gen Options.    (line 144)
* RANK:                                  RANK.                (line   6)
* rank:                                  RANK.                (line   6)
* re-association of parenthesized expressions: Code Gen Options.
                                                              (line 391)
* read character, stream mode:           FGET.                (line   6)
* read character, stream mode <1>:       FGETC.               (line   6)
* 'READONLY':                            Extended I/O specifiers.
                                                              (line   6)
* REAL:                                  REAL.                (line   6)
* real kind:                             SELECTED_REAL_KIND.  (line   6)
* real number, exponent:                 EXPONENT.            (line   6)
* real number, fraction:                 FRACTION.            (line   6)
* real number, nearest different:        NEAREST.             (line   6)
* real number, relative spacing:         RRSPACING.           (line   6)
* real number, relative spacing <1>:     SPACING.             (line   6)
* real number, scale:                    SCALE.               (line   6)
* real number, set exponent:             SET_EXPONENT.        (line   6)
* Reallocate the LHS in assignments:     Code Gen Options.    (line 400)
* Reallocate the LHS in assignments, notification: Error and Warning Options.
                                                              (line 237)
* REALPART:                              REAL.                (line   6)
* 'RECORD':                              STRUCTURE and RECORD.
                                                              (line   6)
* record marker:                         File format of unformatted sequential files.
                                                              (line   6)
* Reduction, XOR:                        PARITY.              (line   6)
* remainder:                             MOD.                 (line   6)
* RENAME:                                RENAME.              (line   6)
* repacking arrays:                      Code Gen Options.    (line 284)
* REPEAT:                                REPEAT.              (line   6)
* RESHAPE:                               RESHAPE.             (line   6)
* 'REWIND':                              Read/Write after EOF marker.
                                                              (line   6)
* right shift, combined:                 DSHIFTR.             (line   6)
* root:                                  SQRT.                (line   6)
* rounding, ceiling:                     ANINT.               (line   6)
* rounding, ceiling <1>:                 CEILING.             (line   6)
* rounding, floor:                       AINT.                (line   6)
* rounding, floor <1>:                   FLOOR.               (line   6)
* rounding, nearest whole number:        NINT.                (line   6)
* RRSPACING:                             RRSPACING.           (line   6)
* RSHIFT:                                RSHIFT.              (line   6)
* run-time checking:                     Code Gen Options.    (line 144)
* SAME_TYPE_AS:                          SAME_TYPE_AS.        (line   6)
* 'SAVE' statement:                      Code Gen Options.    (line  15)
* SCALE:                                 SCALE.               (line   6)
* SCAN:                                  SCAN.                (line   6)
* search path:                           Directory Options.   (line   6)
* search paths, for included files:      Directory Options.   (line  14)
* SECNDS:                                SECNDS.              (line   6)
* SECOND:                                SECOND.              (line   6)
* seeding a random number generator:     RANDOM_SEED.         (line   6)
* seeding a random number generator <1>: SRAND.               (line   6)
* SELECTED_CHAR_KIND:                    SELECTED_CHAR_KIND.  (line   6)
* SELECTED_INT_KIND:                     SELECTED_INT_KIND.   (line   6)
* SELECTED_REAL_KIND:                    SELECTED_REAL_KIND.  (line   6)
* sequential, unformatted:               File format of unformatted sequential files.
                                                              (line   6)
* SET_EXPONENT:                          SET_EXPONENT.        (line   6)
* SHAPE:                                 SHAPE.               (line   6)
* 'SHARE':                               Extended I/O specifiers.
                                                              (line   6)
* 'SHARED':                              Extended I/O specifiers.
                                                              (line   6)
* shift, left:                           DSHIFTL.             (line   6)
* shift, left <1>:                       SHIFTL.              (line   6)
* shift, right:                          DSHIFTR.             (line   6)
* shift, right <1>:                      SHIFTR.              (line   6)
* shift, right with fill:                SHIFTA.              (line   6)
* SHIFTA:                                SHIFTA.              (line   6)
* SHIFTL:                                SHIFTL.              (line   6)
* SHIFTR:                                SHIFTR.              (line   6)
* SHORT:                                 INT2.                (line   6)
* SIGN:                                  SIGN.                (line   6)
* sign copying:                          SIGN.                (line   6)
* SIGNAL:                                SIGNAL.              (line   6)
* SIN:                                   SIN.                 (line   6)
* SIND:                                  SIND.                (line   6)
* sine:                                  SIN.                 (line   6)
* sine, degrees:                         SIND.                (line   6)
* sine, hyperbolic:                      SINH.                (line   6)
* sine, hyperbolic, inverse:             ASINH.               (line   6)
* sine, inverse:                         ASIN.                (line   6)
* sine, inverse, degrees:                ASIND.               (line   6)
* SINH:                                  SINH.                (line   6)
* SIZE:                                  SIZE.                (line   6)
* size of a variable, in bits:           BIT_SIZE.            (line   6)
* size of an expression:                 C_SIZEOF.            (line   6)
* size of an expression <1>:             SIZEOF.              (line   6)
* SIZEOF:                                SIZEOF.              (line   6)
* SLEEP:                                 SLEEP.               (line   6)
* SNGL:                                  REAL.                (line   6)
* SPACING:                               SPACING.             (line   6)
* SPREAD:                                SPREAD.              (line   6)
* SQRT:                                  SQRT.                (line   6)
* square-root:                           SQRT.                (line   6)
* SRAND:                                 SRAND.               (line   6)
* Standards:                             Standards.           (line   6)
* STAT:                                  STAT.                (line   6)
* statement, 'ENUM':                     Fortran 2003 status. (line  92)
* statement, 'ENUMERATOR':               Fortran 2003 status. (line  92)
* statement, 'FLUSH':                    Fortran 2003 status. (line  88)
* statement, 'IMPORT':                   Fortran 2003 status. (line 119)
* statement, 'ISO_FORTRAN_ENV':          Fortran 2003 status. (line 127)
* statement, 'PROTECTED':                Fortran 2003 status. (line 113)
* statement, 'SAVE':                     Code Gen Options.    (line  15)
* statement, 'USE, INTRINSIC':           Fortran 2003 status. (line 127)
* statement, 'VALUE':                    Fortran 2003 status. (line 115)
* statement, 'VOLATILE':                 Fortran 2003 status. (line 117)
* 'STATIC':                              AUTOMATIC and STATIC attributes.
                                                              (line   6)
* storage size:                          STORAGE_SIZE.        (line   6)
* STORAGE_SIZE:                          STORAGE_SIZE.        (line   6)
* 'STREAM' I/O:                          Fortran 2003 status. (line 102)
* stream mode, read character:           FGET.                (line   6)
* stream mode, read character <1>:       FGETC.               (line   6)
* stream mode, write character:          FPUT.                (line   6)
* stream mode, write character <1>:      FPUTC.               (line   6)
* string, adjust left:                   ADJUSTL.             (line   6)
* string, adjust right:                  ADJUSTR.             (line   6)
* string, comparison:                    LGE.                 (line   6)
* string, comparison <1>:                LGT.                 (line   6)
* string, comparison <2>:                LLE.                 (line   6)
* string, comparison <3>:                LLT.                 (line   6)
* string, concatenate:                   REPEAT.              (line   6)
* string, find missing set:              VERIFY.              (line   6)
* string, find non-blank character:      LNBLNK.              (line   6)
* string, find subset:                   SCAN.                (line   6)
* string, find substring:                INDEX intrinsic.     (line   6)
* string, length:                        LEN.                 (line   6)
* string, length, without trailing whitespace: LEN_TRIM.      (line   6)
* string, remove trailing whitespace:    TRIM.                (line   6)
* string, repeat:                        REPEAT.              (line   6)
* strings, varying length:               Varying Length Character Strings.
                                                              (line   6)
* 'STRUCTURE':                           STRUCTURE and RECORD.
                                                              (line   6)
* structure packing:                     Code Gen Options.    (line 278)
* subrecord:                             File format of unformatted sequential files.
                                                              (line   6)
* subscript checking:                    Code Gen Options.    (line 144)
* substring position:                    INDEX intrinsic.     (line   6)
* SUM:                                   SUM.                 (line   6)
* sum array elements:                    SUM.                 (line   6)
* suppressing warnings:                  Error and Warning Options.
                                                              (line   6)
* symbol names:                          Fortran Dialect Options.
                                                              (line  73)
* symbol names, transforming:            Code Gen Options.    (line  57)
* symbol names, transforming <1>:        Code Gen Options.    (line 113)
* symbol names, underscores:             Code Gen Options.    (line  57)
* symbol names, underscores <1>:         Code Gen Options.    (line 113)
* SYMLNK:                                SYMLNK.              (line   6)
* syntax checking:                       Error and Warning Options.
                                                              (line  33)
* SYSTEM:                                SYSTEM.              (line   6)
* system, error handling:                GERROR.              (line   6)
* system, error handling <1>:            IERRNO.              (line   6)
* system, error handling <2>:            PERROR.              (line   6)
* system, group ID:                      GETGID.              (line   6)
* system, host name:                     HOSTNM.              (line   6)
* system, login name:                    GETLOG.              (line   6)
* system, process ID:                    GETPID.              (line   6)
* system, signal handling:               SIGNAL.              (line   6)
* system, system call:                   EXECUTE_COMMAND_LINE.
                                                              (line   6)
* system, system call <1>:               SYSTEM.              (line   6)
* system, terminal:                      ISATTY.              (line   6)
* system, terminal <1>:                  TTYNAM.              (line   6)
* system, user ID:                       GETUID.              (line   6)
* system, working directory:             CHDIR.               (line   6)
* system, working directory <1>:         GETCWD.              (line   6)
* SYSTEM_CLOCK:                          SYSTEM_CLOCK.        (line   6)
* tabulators:                            Error and Warning Options.
                                                              (line 186)
* TAN:                                   TAN.                 (line   6)
* TAND:                                  TAND.                (line   6)
* tangent:                               TAN.                 (line   6)
* tangent, degrees:                      TAND.                (line   6)
* tangent, hyperbolic:                   TANH.                (line   6)
* tangent, hyperbolic, inverse:          ATANH.               (line   6)
* tangent, inverse:                      ATAN.                (line   6)
* tangent, inverse <1>:                  ATAN2.               (line   6)
* tangent, inverse, degrees:             ATAND.               (line   6)
* tangent, inverse, degrees <1>:         ATAN2D.              (line   6)
* TANH:                                  TANH.                (line   6)
* terminate program:                     EXIT.                (line   6)
* terminate program, with core dump:     ABORT.               (line   6)
* THIS_IMAGE:                            THIS_IMAGE.          (line   6)
* thread-safety, threads:                Thread-safety of the runtime library.
                                                              (line   6)
* TIME:                                  TIME.                (line   6)
* time, clock ticks:                     MCLOCK.              (line   6)
* time, clock ticks <1>:                 MCLOCK8.             (line   6)
* time, clock ticks <2>:                 SYSTEM_CLOCK.        (line   6)
* time, conversion to GMT info:          GMTIME.              (line   6)
* time, conversion to local time info:   LTIME.               (line   6)
* time, conversion to string:            CTIME.               (line   6)
* time, current:                         DATE_AND_TIME.       (line   6)
* time, current <1>:                     FDATE.               (line   6)
* time, current <2>:                     ITIME.               (line   6)
* time, current <3>:                     TIME.                (line   6)
* time, current <4>:                     TIME8.               (line   6)
* time, elapsed:                         CPU_TIME.            (line   6)
* time, elapsed <1>:                     DTIME.               (line   6)
* time, elapsed <2>:                     ETIME.               (line   6)
* time, elapsed <3>:                     SECNDS.              (line   6)
* time, elapsed <4>:                     SECOND.              (line   6)
* TIME8:                                 TIME8.               (line   6)
* TINY:                                  TINY.                (line   6)
* TR 15581:                              Fortran 2003 status. (line  97)
* trace:                                 Debugging Options.   (line  86)
* TRAILZ:                                TRAILZ.              (line   6)
* TRANSFER:                              TRANSFER.            (line   6)
* transforming symbol names:             Code Gen Options.    (line  57)
* transforming symbol names <1>:         Code Gen Options.    (line 113)
* TRANSPOSE:                             TRANSPOSE.           (line   6)
* transpose:                             TRANSPOSE.           (line   6)
* trigonometric function, cosine:        COS.                 (line   6)
* trigonometric function, cosine, degrees: COSD.              (line   6)
* trigonometric function, cosine, inverse: ACOS.              (line   6)
* trigonometric function, cosine, inverse, degrees: ACOSD.    (line   6)
* trigonometric function, cotangent:     COTAN.               (line   6)
* trigonometric function, cotangent, degrees: COTAND.         (line   6)
* trigonometric function, sine:          SIN.                 (line   6)
* trigonometric function, sine, degrees: SIND.                (line   6)
* trigonometric function, sine, inverse: ASIN.                (line   6)
* trigonometric function, sine, inverse, degrees: ASIND.      (line   6)
* trigonometric function, tangent:       TAN.                 (line   6)
* trigonometric function, tangent, degrees: TAND.             (line   6)
* trigonometric function, tangent, inverse: ATAN.             (line   6)
* trigonometric function, tangent, inverse <1>: ATAN2.        (line   6)
* trigonometric function, tangent, inverse, degrees: ATAND.   (line   6)
* trigonometric function, tangent, inverse, degrees <1>: ATAN2D.
                                                              (line   6)
* TRIM:                                  TRIM.                (line   6)
* TTYNAM:                                TTYNAM.              (line   6)
* type alias print:                      TYPE as an alias for PRINT.
                                                              (line   6)
* type cast:                             TRANSFER.            (line   6)
* UBOUND:                                UBOUND.              (line   6)
* UCOBOUND:                              UCOBOUND.            (line   6)
* UMASK:                                 UMASK.               (line   6)
* underflow:                             Error and Warning Options.
                                                              (line 199)
* underscore:                            Code Gen Options.    (line  57)
* underscore <1>:                        Code Gen Options.    (line 113)
* unformatted sequential:                File format of unformatted sequential files.
                                                              (line   6)
* 'UNION':                               UNION and MAP.       (line   6)
* UNLINK:                                UNLINK.              (line   6)
* UNPACK:                                UNPACK.              (line   6)
* unused dummy argument:                 Error and Warning Options.
                                                              (line 215)
* unused parameter:                      Error and Warning Options.
                                                              (line 219)
* 'USE, INTRINSIC' statement:            Fortran 2003 status. (line 127)
* user id:                               GETUID.              (line   6)
* 'VALUE' statement:                     Fortran 2003 status. (line 115)
* variable attributes:                   AUTOMATIC and STATIC attributes.
                                                              (line   6)
* Varying length character strings:      Varying Length Character Strings.
                                                              (line   6)
* Varying length strings:                Varying Length Character Strings.
                                                              (line   6)
* vector product:                        DOT_PRODUCT.         (line   6)
* VERIFY:                                VERIFY.              (line   6)
* version of the compiler:               COMPILER_VERSION.    (line   6)
* 'VOLATILE':                            Volatile COMMON blocks.
                                                              (line   6)
* 'VOLATILE' statement:                  Fortran 2003 status. (line 117)
* warning, C binding type:               Error and Warning Options.
                                                              (line 106)
* warnings, aliasing:                    Error and Warning Options.
                                                              (line  71)
* warnings, alignment of 'COMMON' blocks: Error and Warning Options.
                                                              (line 226)
* warnings, all:                         Error and Warning Options.
                                                              (line  62)
* warnings, ampersand:                   Error and Warning Options.
                                                              (line  88)
* warnings, argument mismatch:           Error and Warning Options.
                                                              (line  96)
* warnings, array temporaries:           Error and Warning Options.
                                                              (line 101)
* warnings, character truncation:        Error and Warning Options.
                                                              (line 113)
* warnings, conversion:                  Error and Warning Options.
                                                              (line 122)
* warnings, conversion <1>:              Error and Warning Options.
                                                              (line 126)
* warnings, division of integers:        Error and Warning Options.
                                                              (line 149)
* warnings, extra:                       Error and Warning Options.
                                                              (line 130)
* warnings, function elimination:        Error and Warning Options.
                                                              (line 232)
* warnings, implicit interface:          Error and Warning Options.
                                                              (line 139)
* warnings, implicit procedure:          Error and Warning Options.
                                                              (line 145)
* warnings, integer division:            Error and Warning Options.
                                                              (line 149)
* warnings, interface mismatch:          Error and Warning Options.
                                                              (line  96)
* warnings, intrinsic:                   Error and Warning Options.
                                                              (line 204)
* warnings, intrinsics of other standards: Error and Warning Options.
                                                              (line 153)
* warnings, line truncation:             Error and Warning Options.
                                                              (line 116)
* warnings, loop interchange:            Error and Warning Options.
                                                              (line 135)
* warnings, non-standard intrinsics:     Error and Warning Options.
                                                              (line 153)
* warnings, parameter mismatch:          Error and Warning Options.
                                                              (line  96)
* warnings, 'q' exponent-letter:         Error and Warning Options.
                                                              (line 160)
* warnings, suppressing:                 Error and Warning Options.
                                                              (line   6)
* warnings, suspicious code:             Error and Warning Options.
                                                              (line 164)
* warnings, tabs:                        Error and Warning Options.
                                                              (line 186)
* warnings, to errors:                   Error and Warning Options.
                                                              (line 278)
* warnings, undefined do loop:           Error and Warning Options.
                                                              (line 194)
* warnings, underflow:                   Error and Warning Options.
                                                              (line 199)
* warnings, unused dummy argument:       Error and Warning Options.
                                                              (line 215)
* warnings, unused parameter:            Error and Warning Options.
                                                              (line 219)
* warnings, use statements:              Error and Warning Options.
                                                              (line 211)
* write character, stream mode:          FPUT.                (line   6)
* write character, stream mode <1>:      FPUTC.               (line   6)
* XOR:                                   XOR.                 (line   6)
* XOR reduction:                         PARITY.              (line   6)
* ZABS:                                  ABS.                 (line   6)
* ZCOS:                                  COS.                 (line   6)
* ZCOSD:                                 COSD.                (line   6)
* zero bits:                             LEADZ.               (line   6)
* zero bits <1>:                         TRAILZ.              (line   6)
* ZEXP:                                  EXP.                 (line   6)
* ZLOG:                                  LOG.                 (line   6)
* ZSIN:                                  SIN.                 (line   6)
* ZSIND:                                 SIND.                (line   6)
* ZSQRT:                                 SQRT.                (line   6)



Tag Table:
Node: Top1950
Node: Introduction3367
Node: About GNU Fortran4116
Node: GNU Fortran and GCC8117
Node: Preprocessing and conditional compilation10231
Node: GNU Fortran and G7712320
Node: Project Status12893
Node: Standards15635
Node: Varying Length Character Strings16972
Node: Invoking GNU Fortran17724
Node: Option Summary19558
Node: Fortran Dialect Options23579
Node: Preprocessing Options36166
Node: Error and Warning Options44407
Node: Debugging Options56189
Node: Directory Options60961
Node: Link Options62396
Node: Runtime Options63022
Node: Code Gen Options64929
Node: Interoperability Options84787
Node: Environment Variables86865
Node: Runtime87478
Node: TMPDIR88652
Node: GFORTRAN_STDIN_UNIT89322
Node: GFORTRAN_STDOUT_UNIT89704
Node: GFORTRAN_STDERR_UNIT90105
Node: GFORTRAN_UNBUFFERED_ALL90507
Node: GFORTRAN_UNBUFFERED_PRECONNECTED91038
Node: GFORTRAN_SHOW_LOCUS91682
Node: GFORTRAN_OPTIONAL_PLUS92178
Node: GFORTRAN_LIST_SEPARATOR92656
Node: GFORTRAN_CONVERT_UNIT93264
Node: GFORTRAN_ERROR_BACKTRACE96119
Node: GFORTRAN_FORMATTED_BUFFER_SIZE96715
Node: GFORTRAN_UNFORMATTED_BUFFER_SIZE97163
Node: Fortran standards status97592
Node: Fortran 2003 status97844
Node: Fortran 2008 status102999
Node: Fortran 2018 status108377
Node: Compiler Characteristics110735
Node: KIND Type Parameters111518
Node: Internal representation of LOGICAL variables112946
Node: Evaluation of logical expressions113803
Node: MAX and MIN intrinsics with REAL NaN arguments114654
Node: Thread-safety of the runtime library115475
Node: Data consistency and durability117880
Node: Files opened without an explicit ACTION= specifier120993
Node: File operations on symbolic links121684
Node: File format of unformatted sequential files122804
Node: Asynchronous I/O125176
Node: Extensions125876
Node: Extensions implemented in GNU Fortran126481
Node: Old-style kind specifications128379
Node: Old-style variable initialization129481
Node: Extensions to namelist130793
Node: X format descriptor without count field133096
Node: Commas in FORMAT specifications133623
Node: Missing period in FORMAT specifications134140
Node: I/O item lists134702
Node: 'Q' exponent-letter135089
Node: BOZ literal constants135689
Node: Real array indices138270
Node: Unary operators138569
Node: Implicitly convert LOGICAL and INTEGER values138983
Node: Hollerith constants support139942
Node: Cray pointers141714
Node: CONVERT specifier147222
Node: OpenMP149217
Node: OpenACC151475
Node: Argument list functions152784
Node: Read/Write after EOF marker154427
Node: STRUCTURE and RECORD155030
Node: UNION and MAP160117
Node: Type variants for integer intrinsics163085
Node: AUTOMATIC and STATIC attributes165087
Node: Extended math intrinsics166621
Node: Form feed as whitespace168417
Node: TYPE as an alias for PRINT168963
Node: %LOC as an rvalue169428
Node: .XOR. operator170075
Node: Bitwise logical operators170475
Node: Extended I/O specifiers172027
Node: Legacy PARAMETER statements175747
Node: Default exponents176352
Node: Extensions not implemented in GNU Fortran176704
Node: ENCODE and DECODE statements177671
Node: Variable FORMAT expressions179002
Node: Alternate complex function syntax180107
Node: Volatile COMMON blocks180657
Node: OPEN( ... NAME=)181159
Node: Q edit descriptor181587
Node: Mixed-Language Programming182539
Node: Interoperability with C183119
Node: Intrinsic Types184453
Node: Derived Types and struct185449
Node: Interoperable Global Variables186807
Node: Interoperable Subroutines and Functions188082
Node: Working with Pointers191876
Node: Further Interoperability of Fortran with C196352
Node: GNU Fortran Compiler Directives199924
Node: ATTRIBUTES directive200300
Node: UNROLL directive203488
Node: BUILTIN directive204021
Node: IVDEP directive204863
Node: VECTOR directive205682
Node: NOVECTOR directive206080
Node: Non-Fortran Main Program206465
Node: _gfortran_set_args208653
Node: _gfortran_set_options209591
Node: _gfortran_set_convert213198
Node: _gfortran_set_record_marker214066
Node: _gfortran_set_fpe214876
Node: _gfortran_set_max_subrecord_length216074
Node: Naming and argument-passing conventions216997
Node: Naming conventions217716
Node: Argument passing conventions219188
Node: Coarray Programming224493
Node: Type and enum ABI Documentation224740
Node: caf_token_t225038
Node: caf_register_t225274
Node: caf_deregister_t226485
Node: caf_reference_t226987
Node: caf_team_t231311
Node: Function ABI Documentation231610
Node: _gfortran_caf_init234060
Node: _gfortran_caf_finish235486
Node: _gfortran_caf_this_image236425
Node: _gfortran_caf_num_images237180
Node: _gfortran_caf_image_status238291
Node: _gfortran_caf_failed_images239411
Node: _gfortran_caf_stopped_images240581
Node: _gfortran_caf_register241754
Node: _gfortran_caf_deregister245936
Node: _gfortran_caf_is_present247542
Node: _gfortran_caf_send248621
Node: _gfortran_caf_get251811
Node: _gfortran_caf_sendget254892
Node: _gfortran_caf_send_by_ref258803
Node: _gfortran_caf_get_by_ref262412
Node: _gfortran_caf_sendget_by_ref265931
Node: _gfortran_caf_lock270227
Node: _gfortran_caf_unlock272013
Node: _gfortran_caf_event_post273494
Node: _gfortran_caf_event_wait274943
Node: _gfortran_caf_event_query277050
Node: _gfortran_caf_sync_all278381
Node: _gfortran_caf_sync_images279309
Node: _gfortran_caf_sync_memory280844
Node: _gfortran_caf_error_stop281836
Node: _gfortran_caf_error_stop_str282440
Node: _gfortran_caf_fail_image283145
Node: _gfortran_caf_atomic_define283681
Node: _gfortran_caf_atomic_ref284996
Node: _gfortran_caf_atomic_cas286300
Node: _gfortran_caf_atomic_op288061
Node: _gfortran_caf_co_broadcast290163
Node: _gfortran_caf_co_max291268
Node: _gfortran_caf_co_min292894
Node: _gfortran_caf_co_sum294514
Node: _gfortran_caf_co_reduce296054
Node: Intrinsic Procedures298698
Node: Introduction to Intrinsics315957
Node: ABORT318307
Node: ABS319052
Node: ACCESS321002
Node: ACHAR322932
Node: ACOS324136
Node: ACOSD325422
Node: ACOSH326734
Node: ADJUSTL327730
Node: ADJUSTR328672
Node: AIMAG329622
Node: AINT330994
Node: ALARM332600
Node: ALL334232
Node: ALLOCATED336156
Node: AND337295
Node: ANINT339030
Node: ANY340527
Node: ASIN342453
Node: ASIND343728
Node: ASINH345026
Node: ASSOCIATED346032
Node: ATAN349043
Node: ATAND350493
Node: ATAN2351963
Node: ATAN2D353828
Node: ATANH355803
Node: ATOMIC_ADD356809
Node: ATOMIC_AND358341
Node: ATOMIC_CAS359929
Node: ATOMIC_DEFINE361788
Node: ATOMIC_FETCH_ADD363507
Node: ATOMIC_FETCH_AND365307
Node: ATOMIC_FETCH_OR367097
Node: ATOMIC_FETCH_XOR368874
Node: ATOMIC_OR370657
Node: ATOMIC_REF372242
Node: ATOMIC_XOR374138
Node: BACKTRACE375723
Node: BESSEL_J0376303
Node: BESSEL_J1377319
Node: BESSEL_JN378336
Node: BESSEL_Y0380161
Node: BESSEL_Y1381116
Node: BESSEL_YN382071
Node: BGE383902
Node: BGT384594
Node: BIT_SIZE385244
Node: BLE386066
Node: BLT386748
Node: BTEST387386
Node: C_ASSOCIATED388843
Node: C_F_POINTER390054
Node: C_F_PROCPOINTER391489
Node: C_FUNLOC392996
Node: C_LOC394367
Node: C_SIZEOF395646
Node: CEILING397059
Node: CHAR398067
Node: CHDIR399279
Node: CHMOD400453
Node: CMPLX402368
Node: CO_BROADCAST403811
Node: CO_MAX405584
Node: CO_MIN407464
Node: CO_REDUCE409330
Node: CO_SUM412833
Node: COMMAND_ARGUMENT_COUNT414740
Node: COMPILER_OPTIONS415657
Node: COMPILER_VERSION416683
Node: COMPLEX417647
Node: CONJG418786
Node: COS419842
Node: COSD421297
Node: COSH422746
Node: COTAN423929
Node: COTAND425068
Node: COUNT426247
Node: CPU_TIME428272
Node: CSHIFT429629
Node: CTIME431289
Node: DATE_AND_TIME432797
Node: DBLE435277
Node: DCMPLX436072
Node: DIGITS437254
Node: DIM438221
Node: DOT_PRODUCT439502
Node: DPROD441145
Node: DREAL442072
Node: DSHIFTL442738
Node: DSHIFTR444071
Node: DTIME445405
Node: EOSHIFT448220
Node: EPSILON450293
Node: ERF451020
Node: ERFC451801
Node: ERFC_SCALED452611
Node: ETIME453304
Node: EVENT_QUERY455543
Node: EXECUTE_COMMAND_LINE457132
Node: EXIT459912
Node: EXP460790
Node: EXPONENT462043
Node: EXTENDS_TYPE_OF462807
Node: FDATE463665
Node: FGET465151
Node: FGETC466978
Node: FINDLOC468788
Node: FLOOR471248
Node: FLUSH472239
Node: FNUM474118
Node: FPUT474843
Node: FPUTC476477
Node: FRACTION478258
Node: FREE479162
Node: FSEEK480005
Node: FSTAT482311
Node: FTELL483398
Node: GAMMA484380
Node: GERROR485434
Node: GETARG486156
Node: GET_COMMAND487928
Node: GET_COMMAND_ARGUMENT489302
Node: GETCWD491349
Node: GETENV492329
Node: GET_ENVIRONMENT_VARIABLE493761
Node: GETGID495924
Node: GETLOG496461
Node: GETPID497323
Node: GETUID498053
Node: GMTIME498569
Node: HOSTNM500329
Node: HUGE501250
Node: HYPOT501972
Node: IACHAR502798
Node: IALL503966
Node: IAND505451
Node: IANY507178
Node: IARGC508672
Node: IBCLR509693
Node: IBITS510941
Node: IBSET512445
Node: ICHAR513688
Node: IDATE515858
Node: IEOR517158
Node: IERRNO518778
Node: IMAGE_INDEX519327
Node: INDEX intrinsic520355
Node: INT521881
Node: INT2523640
Node: INT8524408
Node: IOR525123
Node: IPARITY526719
Node: IRAND528251
Node: IS_CONTIGUOUS529610
Node: IS_IOSTAT_END530776
Node: IS_IOSTAT_EOR531883
Node: ISATTY533012
Node: ISHFT533795
Node: ISHFTC535364
Node: ISNAN537171
Node: ITIME537938
Node: KILL539236
Node: KIND540321
Node: LBOUND541167
Node: LCOBOUND542505
Node: LEADZ543640
Node: LEN544501
Node: LEN_TRIM545797
Node: LGE546785
Node: LGT548298
Node: LINK549776
Node: LLE550815
Node: LLT552315
Node: LNBLNK553786
Node: LOC554564
Node: LOG555296
Node: LOG10556641
Node: LOG_GAMMA557631
Node: LOGICAL558733
Node: LONG559545
Node: LSHIFT560303
Node: LSTAT561412
Node: LTIME562612
Node: MALLOC564294
Node: MASKL565756
Node: MASKR566523
Node: MATMUL567293
Node: MAX568466
Node: MAXEXPONENT570001
Node: MAXLOC570818
Node: MAXVAL573435
Node: MCLOCK575075
Node: MCLOCK8576098
Node: MERGE577328
Node: MERGE_BITS578080
Node: MIN579119
Node: MINEXPONENT580657
Node: MINLOC581288
Node: MINVAL583936
Node: MOD585589
Node: MODULO587753
Node: MOVE_ALLOC589056
Node: MVBITS590089
Node: NEAREST591741
Node: NEW_LINE592841
Node: NINT593614
Node: NORM2595035
Node: NOT596177
Node: NULL597347
Node: NUM_IMAGES598255
Node: OR599956
Node: PACK601679
Node: PARITY603687
Node: PERROR604908
Node: POPCNT605533
Node: POPPAR606405
Node: PRECISION607459
Node: PRESENT608346
Node: PRODUCT609458
Node: RADIX610992
Node: RAN611804
Node: RAND612260
Node: RANDOM_INIT613593
Node: RANDOM_NUMBER615549
Node: RANDOM_SEED616791
Node: RANGE619261
Node: RANK619942
Node: REAL620723
Node: RENAME622712
Node: REPEAT623734
Node: RESHAPE624462
Node: RRSPACING625929
Node: RSHIFT626622
Node: SAME_TYPE_AS627790
Node: SCALE628622
Node: SCAN629403
Node: SECNDS630961
Node: SECOND632053
Node: SELECTED_CHAR_KIND632929
Node: SELECTED_INT_KIND634524
Node: SELECTED_REAL_KIND635701
Node: SET_EXPONENT638378
Node: SHAPE639375
Node: SHIFTA640799
Node: SHIFTL641790
Node: SHIFTR642650
Node: SIGN643511
Node: SIGNAL644737
Node: SIN646243
Node: SIND647334
Node: SINH648663
Node: SIZE649676
Node: SIZEOF650995
Node: SLEEP652650
Node: SPACING653211
Node: SPREAD654225
Node: SQRT655376
Node: SRAND656708
Node: STAT657942
Node: STORAGE_SIZE661110
Node: SUM661989
Node: SYMLNK663481
Node: SYSTEM664616
Node: SYSTEM_CLOCK665871
Node: TAN668701
Node: TAND669772
Node: TANH670856
Node: THIS_IMAGE672031
Node: TIME674331
Node: TIME8675502
Node: TINY676701
Node: TRAILZ677302
Node: TRANSFER678120
Node: TRANSPOSE680156
Node: TRIM680846
Node: TTYNAM681704
Node: UBOUND682622
Node: UCOBOUND684012
Node: UMASK685149
Node: UNLINK685831
Node: UNPACK686811
Node: VERIFY688106
Node: XOR689835
Node: Intrinsic Modules691645
Node: ISO_FORTRAN_ENV691934
Node: ISO_C_BINDING696337
Node: IEEE modules700043
Node: OpenMP Modules OMP_LIB and OMP_LIB_KINDS701186
Node: OpenACC Module OPENACC702726
Node: Contributing703653
Node: Contributors704507
Node: Projects706138
Node: Proposed Extensions706945
Node: Copying708955
Node: GNU Free Documentation License746501
Node: Funding771625
Node: Option Index774151
Node: Keyword Index792444

End Tag Table
