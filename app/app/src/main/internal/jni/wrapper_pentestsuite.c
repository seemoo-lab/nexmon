/*
 * Nexmon PenTestSuite
 * Copyright (C) 2016 Fabian Knapp
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License 2
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include "wrapper_pentestsuite.h"


JNIEXPORT jstring Java_de_tu_1darmstadt_seemoo_nexmon_net_FrameReceiver_getMyData(JNIEnv* pEnv, jobject pThis) {
	jclass cls = (*pEnv)->GetObjectClass(pEnv, pThis);
	jmethodID mid = (*pEnv)->GetMethodID(pEnv, cls, "receivePaket", "([B[B)V");
	if(mid == 0)
		return "nothing";

	return (*pEnv)->NewStringUTF(pEnv, sniff_it(pEnv, pThis, mid));
}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_net_FrameReceiver_stopSniffing(JNIEnv* pEnv, jobject pThis) {
	stop_sniffer();
}

JNIEXPORT jobject Java_de_tu_1darmstadt_seemoo_nexmon_net_FrameSender_sendFrame(JNIEnv* pEnv, jclass pClazz, jbyteArray frame) {
	int len = (*pEnv)->GetArrayLength(pEnv, frame);
	jbyte frameBytes[len];
    struct ret_msg my_message;

	(*pEnv)->GetByteArrayRegion(pEnv, frame, 0, len, frameBytes);

    jclass attack_info_string = (*pEnv)->FindClass(pEnv, "de/tu_darmstadt/seemoo/nexmon/stations/AttackInfoString");
    jmethodID constructor = (*pEnv)->GetMethodID(pEnv, attack_info_string, "<init>", "()V");
    jobject obj = (*pEnv)->NewObject(pEnv, attack_info_string, constructor);

    jfieldID message_type_id = (*pEnv)->GetFieldID(pEnv, attack_info_string, "messageType", "I");
    jfieldID message_string_id = (*pEnv)->GetFieldID(pEnv, attack_info_string, "message", "Ljava/lang/String;");

    inject_it((char*) frameBytes, len, "wlan0", &my_message);

    (*pEnv)->SetIntField(pEnv, obj, message_type_id, my_message.msg_type);
    (*pEnv)->SetObjectField(pEnv, obj, message_string_id, (*pEnv)->NewStringUTF(pEnv, my_message.msg));

	return obj;
}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_sharky_Packet_decrypt(JNIEnv* env, jobject pThis, jstring bssid, jstring essid, jstring passphrase, jstring fileDir, jint encryption) {
	/*decrypt_pcap("a0:f3:c1:f5:58:22", "Stube", "planschbecken2012", "/sdcard/ttttt.pcap", 2);*/

	const char *native_bssid = (*env)->GetStringUTFChars(env, bssid, 0);
    const char *native_essid = (*env)->GetStringUTFChars(env, essid, 0);
	const char *native_passphrase = (*env)->GetStringUTFChars(env, passphrase, 0);
	const char *native_filedir = (*env)->GetStringUTFChars(env, fileDir, 0);

	decrypt_pcap(native_bssid, native_essid, native_passphrase, native_filedir, (int) encryption);

	(*env)->ReleaseStringUTFChars(env, bssid, native_bssid);
	(*env)->ReleaseStringUTFChars(env, essid, native_essid);
    (*env)->ReleaseStringUTFChars(env, passphrase, native_passphrase);
    (*env)->ReleaseStringUTFChars(env, fileDir, native_filedir);
}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_FakeAuthAttack_fakeauth(JNIEnv* env, jobject pThis, jstring bssid, jstring essid, jboolean useCustomStationMac, jstring stationMac, jstring interfaceName, jint reassocTiming, jint keepaliveTiming, jint packetTiming, jint id) {
    const char *native_bssid = (*env)->GetStringUTFChars(env, bssid, 0);
    const char *native_essid = (*env)->GetStringUTFChars(env, essid, 0);
    const char *native_interface = (*env)->GetStringUTFChars(env, interfaceName, 0);
    const char *native_station_mac = (*env)->GetStringUTFChars(env, stationMac, 0);

    int use_station_mac_native = (useCustomStationMac == JNI_TRUE) ? 1 : 0;

	jclass cls = (*env)->GetObjectClass(env, pThis);
	jmethodID mid = (*env)->GetMethodID(env, cls, "fakeauthUpdate", "(Ljava/lang/String;II)V");
	if(mid == 0)
		return;

    attack_fakeauth(env, pThis, mid, native_interface, (int)reassocTiming, native_essid, native_bssid, use_station_mac_native, native_station_mac, (int) keepaliveTiming, (int) packetTiming, (int) id);

    (*env)->ReleaseStringUTFChars(env, stationMac, native_station_mac);
    (*env)->ReleaseStringUTFChars(env, bssid, native_bssid);
    (*env)->ReleaseStringUTFChars(env, essid, native_essid);
    (*env)->ReleaseStringUTFChars(env, interfaceName, native_interface);
}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_FakeAuthAttack_stopfakeauth(JNIEnv* env, jobject pThis, jboolean running) {
    int running_native = (running == JNI_TRUE) ? 1 : 0;
    stop_attack_fakeauth(running_native);
}


JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_WepCrackAttack_wepcrack(JNIEnv* env, jobject pThis, jstring bssid, jstring essid, jboolean useEssid, jstring fileDir, jboolean useDecloak, jboolean useKorek, jint id) {
     const char *native_bssid = (*env)->GetStringUTFChars(env, bssid, 0);
     const char *native_essid = (*env)->GetStringUTFChars(env, essid, 0);
     const char *native_file = (*env)->GetStringUTFChars(env, fileDir, 0);

    int native_use_decloak = (useDecloak == JNI_TRUE) ? 1 : 0;
    int native_use_essid = (useEssid == JNI_TRUE) ? 1 : 0;
    int native_use_korek = (useKorek == JNI_TRUE) ? 1 : 0;


    jclass cls = (*env)->GetObjectClass(env, pThis);
    jmethodID mid = (*env)->GetMethodID(env, cls, "wepCrackUpdate", "(Ljava/lang/String;II)V");

    if(mid == 0)
        return;

    attack_crack_wep(env, pThis, mid, native_bssid, native_use_essid, native_essid, native_file, native_use_decloak, native_use_korek, (int) id);

    (*env)->ReleaseStringUTFChars(env, bssid, native_bssid);
    (*env)->ReleaseStringUTFChars(env, essid, native_essid);
    (*env)->ReleaseStringUTFChars(env, fileDir, native_file);
}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_WepCrackAttack_stopwepcrack(JNIEnv* env, jobject pThis, jboolean stopAttack) {
    int stop_native = (stopAttack == JNI_TRUE) ? 1 : 0;
    stop_attack_crack_wep(stop_native);
}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_BeaconFloodAttack_beaconflood(JNIEnv* env, jobject pThis, jstring interfaceName, jint id) {
     const char *native_interface = (*env)->GetStringUTFChars(env, interfaceName, 0);

    jclass cls = (*env)->GetObjectClass(env, pThis);
    jmethodID mid = (*env)->GetMethodID(env, cls, "beaconFloodUpdate", "(Ljava/lang/String;II)V");
    jmethodID mid_stats = (*env)->GetMethodID(env, cls, "beaconFloodStats", "(II)V");

    if(mid == 0 || mid_stats == 0)
        return;

    attack_beacon_flood(env, pThis, mid, mid_stats, native_interface, (int) id);

    (*env)->ReleaseStringUTFChars(env, interfaceName, native_interface);

}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_BeaconFloodAttack_stopbeaconflood(JNIEnv* env, jobject pThis, jboolean stopAttack) {
    int stop_native = (stopAttack == JNI_TRUE) ? 1 : 0;
    stop_attack_beaconflood(stop_native);
}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_AuthFloodAttack_authflood(JNIEnv* env, jobject pThis, jstring interfaceName, jstring apMac, jboolean intelligent, jint id) {
    jmethodID mid, mid_stats;
    int native_intelligent = (intelligent == JNI_TRUE) ? 1 : 0;

    const char *native_interface = (*env)->GetStringUTFChars(env, interfaceName, 0);
    const char *native_mac = (*env)->GetStringUTFChars(env, apMac, 0);

    jclass cls = (*env)->GetObjectClass(env, pThis);

    mid = (*env)->GetMethodID(env, cls, "authFloodUpdate", "(Ljava/lang/String;II)V");
    mid_stats = (*env)->GetMethodID(env, cls, "authFloodStats", "(II)V");

    if(mid == 0 || mid_stats == 0)
        return;

    attack_auth_flood(env, pThis, mid, mid_stats, native_interface, native_mac, native_intelligent, (int) id);

    (*env)->ReleaseStringUTFChars(env, interfaceName, native_interface);
    (*env)->ReleaseStringUTFChars(env, apMac, native_mac);
}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_AuthFloodAttack_stopauthflood(JNIEnv* env, jobject pThis, jboolean stopAttack) {
    int stop_native = (stopAttack == JNI_TRUE) ? 1 : 0;
    stop_attack_authflood(stop_native);
}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_CountermeasuresAttack_countermeasures(JNIEnv* env, jobject pThis, jstring interfaceName, jstring apMac, jint burstPause, jint packetsPerBurst, jboolean useQosExploit, jint speed, jint id) {
    jmethodID mid, mid_stats;
    int use_qos_exploit = (useQosExploit == JNI_TRUE) ? 1 : 0;

    const char *native_interface = (*env)->GetStringUTFChars(env, interfaceName, 0);
    const char *native_mac = (*env)->GetStringUTFChars(env, apMac, 0);

    jclass cls = (*env)->GetObjectClass(env, pThis);

    mid = (*env)->GetMethodID(env, cls, "countermeasuresUpdate", "(Ljava/lang/String;II)V");
    mid_stats = (*env)->GetMethodID(env, cls, "countermeasuresStats", "(II)V");

    if(mid == 0 || mid_stats == 0)
        return;

    attack_countermeasures(env, pThis, mid, mid_stats, native_interface, native_mac, (int) burstPause, (int) packetsPerBurst, use_qos_exploit, (int) speed, (int) id);

    (*env)->ReleaseStringUTFChars(env, interfaceName, native_interface);
    (*env)->ReleaseStringUTFChars(env, apMac, native_mac);
}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_CountermeasuresAttack_stopcountermeasures(JNIEnv* env, jobject pThis, jboolean stopAttack) {
    int stop_native = (stopAttack == JNI_TRUE) ? 1 : 0;
    stop_attack_countermeasures(stop_native);
}


JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_WidsAttack_wids(JNIEnv* env, jobject pThis, jstring interfaceName, jstring apEssid, jboolean useChannelHopping, jboolean useZeroChaos, jint id) {
    jmethodID mid, mid_stats;
    int use_channel_hopping = (useChannelHopping == JNI_TRUE) ? 1 : 0;
    int use_zero_chaos = (useZeroChaos == JNI_TRUE) ? 1 : 0;

    const char *native_interface = (*env)->GetStringUTFChars(env, interfaceName, 0);
    const char *native_essid = (*env)->GetStringUTFChars(env, apEssid, 0);

    jclass cls = (*env)->GetObjectClass(env, pThis);

    mid = (*env)->GetMethodID(env, cls, "widsUpdate", "(Ljava/lang/String;II)V");
    mid_stats = (*env)->GetMethodID(env, cls, "widsStats", "(II)V");

    if(mid == 0 || mid_stats == 0)
        return;
    attack_wids(env, pThis, mid, mid_stats, native_interface, native_essid, use_channel_hopping, use_zero_chaos, (int) id);

    (*env)->ReleaseStringUTFChars(env, interfaceName, native_interface);
    (*env)->ReleaseStringUTFChars(env, apEssid, native_essid);
}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_WidsAttack_stopwids(JNIEnv* env, jobject pThis, jboolean stopAttack) {
    int stop_native = (stopAttack == JNI_TRUE) ? 1 : 0;
    stop_attack_wids(stop_native);
}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_sharky_IvsTools_merge(JNIEnv* env, jobject pThis, jstring file1, jstring file2, jstring outputFile) {

    const char *native_file1 = (*env)->GetStringUTFChars(env, file1, 0);
    const char *native_file2 = (*env)->GetStringUTFChars(env, file2, 0);
    const char *native_output_file = (*env)->GetStringUTFChars(env, outputFile, 0);

    merge_ivs_files(env, pThis, native_file1, native_file2, native_output_file);

    (*env)->ReleaseStringUTFChars(env, file1, native_file1);
    (*env)->ReleaseStringUTFChars(env, file2, native_file2);
    (*env)->ReleaseStringUTFChars(env, outputFile, native_output_file);

}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_sharky_IvsTools_convert(JNIEnv* env, jobject pThis, jstring pcapFile, jstring outputFile) {
    const char *native_pcap_file = (*env)->GetStringUTFChars(env, pcapFile, 0);
    const char *native_output_file = (*env)->GetStringUTFChars(env, outputFile, 0);

    create_ivs_from_pcap_file(env, pThis, native_pcap_file, native_output_file);

    (*env)->ReleaseStringUTFChars(env, pcapFile, native_pcap_file);
    (*env)->ReleaseStringUTFChars(env, outputFile, native_output_file);
}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_UpcAttack_upc(JNIEnv* env, jobject pThis, jstring essid, jstring prefixes, jint id) {
    const char *native_essid = (*env)->GetStringUTFChars(env, essid, 0);
    const char *native_prefixes = (*env)->GetStringUTFChars(env, prefixes, 0);

    jclass cls = (*env)->GetObjectClass(env, pThis);

    jmethodID mid = (*env)->GetMethodID(env, cls, "upcUpdate", "(Ljava/lang/String;II)V");

    if(mid == 0)
        return;

    upc_attack(env, pThis, mid, native_essid, native_prefixes, (int) id);

    (*env)->ReleaseStringUTFChars(env, essid, native_essid);
    (*env)->ReleaseStringUTFChars(env, prefixes, native_prefixes);
}



JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_ReaverAttack_reaver(JNIEnv* env, jobject pThis, jstring interfaceName, jstring bssid, jstring essid, jboolean useAutoSettings, jboolean disableChanHopping, jboolean usePixieDust, jint id) {
/*    const char *native_essid = (*env)->GetStringUTFChars(env, essid, 0);
    const char *native_bssid = (*env)->GetStringUTFChars(env, bssid, 0);
    const char *native_interface = (*env)->GetStringUTFChars(env, interfaceName, 0);

    int disable_channel_hopping = (disableChanHopping == JNI_TRUE) ? 1 : 0;
    int use_auto_settings = (useAutoSettings == JNI_TRUE) ? 1 : 0;
    int use_pixie_dust = (usePixieDust == JNI_TRUE) ? 1 : 0;

    jclass cls = (*env)->GetObjectClass(env, pThis);

    jmethodID mid = (*env)->GetMethodID(env, cls, "reaverUpdate", "(Ljava/lang/String;II)V");
    if(mid == 0)
        return;

    attack_reaver(env, pThis, mid, native_interface, native_bssid, native_essid, use_auto_settings, disable_channel_hopping, use_pixie_dust, (int) id);

    (*env)->ReleaseStringUTFChars(env, essid, native_essid);
    (*env)->ReleaseStringUTFChars(env, bssid, native_bssid);
    (*env)->ReleaseStringUTFChars(env, interfaceName, native_interface);*/

}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_ReaverAttack_stopreaver(JNIEnv* env, jobject pThis, jboolean stopAttack) {
/*    int stop_native = (stopAttack == JNI_TRUE) ? 1 : 0;
    stop_attack_reaver(stop_native);*/
}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_WpaDictAttack_cowpatty(JNIEnv* env, jobject pThis, jstring essid, jstring dictOrHashFile, jboolean isHashFile, jstring pcapFile, jint id) {
    const char *native_essid = (*env)->GetStringUTFChars(env, essid, 0);
    const char *native_dictorhash_file = (*env)->GetStringUTFChars(env, dictOrHashFile, 0);
    const char *native_pcap_file = (*env)->GetStringUTFChars(env, pcapFile, 0);

    int is_hash_file = (isHashFile == JNI_TRUE) ? 1 : 0;

    jclass cls = (*env)->GetObjectClass(env, pThis);

    jmethodID mid = (*env)->GetMethodID(env, cls, "cowpattyUpdate", "(Ljava/lang/String;II)V");
    if(mid == 0)
        return;

    attack_cowpatty(env, pThis, mid, native_dictorhash_file, is_hash_file, native_pcap_file, native_essid, (int) id);

    (*env)->ReleaseStringUTFChars(env, essid, native_essid);
    (*env)->ReleaseStringUTFChars(env, dictOrHashFile, native_dictorhash_file);
    (*env)->ReleaseStringUTFChars(env, pcapFile, native_pcap_file);

}

JNIEXPORT void Java_de_tu_1darmstadt_seemoo_nexmon_stations_WpaDictAttack_stopcowpatty(JNIEnv* env, jobject pThis, jboolean stopAttack) {
    int stop_native = (stopAttack == JNI_TRUE) ? 1 : 0;
    stop_attack_cowpatty(stop_native);
}