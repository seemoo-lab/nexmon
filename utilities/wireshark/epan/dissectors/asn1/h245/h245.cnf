# H.245 conformation file
# Copyright 2005 Anders Broman anders.broman[at]ericsson.com
#----------------------------------------------------------------------------------------

#.OPT
PER
ALIGNED
#.END

#.MODULE_EXPORTS
T38FaxProfile
DataProtocolCapability NO_PROT_PREFIX
OpenLogicalChannel
QOSCapability
H223Capability EXTERN WS_DLL
H223LogicalChannelParameters
TransportAddress
UnicastAddress
MulticastAddress
Capability
#.END

#.PDU
OpenLogicalChannel

#.MAKE_ENUM
RequestMessage     TYPE_PREFIX
ResponseMessage    TYPE_PREFIX
CommandMessage     TYPE_PREFIX
IndicationMessage  TYPE_PREFIX

AudioCapability TYPE_PREFIX
#.END

#----------------------------------------------------------------------------------------

#.VIRTUAL_ASSGN
G723AnnexCAudioMode  G7231AnnexCCapability/g723AnnexCAudioMode  G7231AnnexCMode/g723AnnexCAudioMode
Application  DataApplicationCapability/application
Nlpid  Application/nlpid  DataMode/application/nlpid
Al3 H223LogicalChannelParameters/adaptationLayerType/al3  H223ModeParameters/adaptationLayerType/al3
ArqType  H223AL1MParameters/arqType  H223AL3MParameters/arqType
Restriction  FlowControlCommand/restriction  FlowControlIndication/restriction
Scope  FlowControlCommand/scope  FlowControlIndication/scope  JitterIndication/scope
EncryptedAlphanumeric  UserInputIndication/extendedAlphanumeric/encryptedAlphanumeric  UserInputIndication/encryptedAlphanumeric

DepSeparateStream  DepFECData/rfc2733/mode/separateStream  DepFECMode/rfc2733Mode/mode/separateStream

Rfc2733Format  FECCapability/rfc2733Format  FECMode/rfc2733Format

#----------------------------------------------------------------------------------------
#.FN_BODY MultiplexEntryDescriptor
  /*MultiplexEntryDescriptor*/
  h223_me = NULL;
  h223_mc = 0;
%(DEFAULT_BODY)s
  if(h223_set_mc_handle)
    (*h223_set_mc_handle)(%(ACTX)s->pinfo, h223_mc, h223_me, %(ACTX)s->pinfo->ctype, %(ACTX)s->pinfo->circuit_id);
 /* stuff */
#.END
#----------------------------------------------------------------------------------------
#.FN_PARS MultiplexTableEntryNumber
  VAL_PTR = &value
#.FN_BODY MultiplexTableEntryNumber
  guint32 value;
%(DEFAULT_BODY)s
  h223_mc = value & 0xf;
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY MultiplexEntryDescriptor/elementList
  /* create a h223_mux_element to hold onto the head of the list, since
   * h223_me will track the tail */
  h223_mux_element dummy_me;
  memset (&dummy_me, 0, sizeof (h223_mux_element));
  h223_me = &dummy_me;
%(DEFAULT_BODY)s
  /* set h223_me to the head of the list for MEDescriptor to pick up */
  h223_me = dummy_me.next;
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR MultiplexElement
  /*MultiplexElement*/
  h223_mux_element* me = wmem_new(wmem_file_scope(), h223_mux_element);
  h223_me->next = me;
  h223_me = me;
  h223_me->next = NULL;
#.END
#----------------------------------------------------------------------------------------
#.FN_PARS MultiplexElement/type/logicalChannelNumber
  VAL_PTR = &value
#.FN_BODY MultiplexElement/type/logicalChannelNumber
  /*MultiplexElement/type/logicalChannelNumber*/
  guint32 value;
%(DEFAULT_BODY)s
  h223_me->sublist = NULL;
  h223_me->vc = value & 0xffff;
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY MultiplexElement/type/subElementList
  h223_mux_element dummy_me, *parent_me = h223_me;
  memset (&dummy_me, 0, sizeof (h223_mux_element));
  h223_me = &dummy_me;
%(DEFAULT_BODY)s
  parent_me->sublist = dummy_me.next;
  h223_me = parent_me;
  h223_me->vc = 0;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR MultiplexElement/repeatCount/untilClosingFlag
  h223_me->repeat_count = 0;
#.END
#----------------------------------------------------------------------------------------
#.FN_PARS MultiplexElement/repeatCount/finite
  VAL_PTR = &value
#.FN_BODY MultiplexElement/repeatCount/finite
  guint32 value;
%(DEFAULT_BODY)s
  h223_me->repeat_count = value & 0xffff;
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY LogicalChannelNumber  VAL_PTR = &value
  guint32 value;
%(DEFAULT_BODY)s
  h245_lc_temp = value & 0xfff;
#.END

#=== OpenLogicalChannel =================================================================
#.FN_BODY OpenLogicalChannel
  gint32 temp;

  upcoming_olc = (!actx->pinfo->fd->flags.visited) ? wmem_new0(wmem_file_scope(), olc_info_t) : NULL;

  h223_fw_lc_num = 0;
  h223_lc_params_temp = NULL;

%(DEFAULT_BODY)s

  if(h223_fw_lc_num != 0 && h223_fw_lc_params) {
	h223_pending_olc *pending = wmem_new(wmem_file_scope(), h223_pending_olc);
	pending->fw_channel_params = h223_fw_lc_params;
	pending->rev_channel_params = h223_rev_lc_params;
	temp = h223_fw_lc_num;
	if (%(ACTX)s->pinfo->p2p_dir > -1)
		g_hash_table_insert(h223_pending_olc_reqs[%(ACTX)s->pinfo->p2p_dir], GINT_TO_POINTER(temp), pending);
  }

  if (upcoming_olc) {
    if (fast_start) {
      h245_setup_channels(actx->pinfo, &upcoming_olc->rev_lc);
    } else {
      g_hash_table_insert(h245_pending_olc_reqs,
        wmem_strdup(wmem_file_scope(), gen_olc_key(upcoming_olc->fwd_lc_num, &%(ACTX)s->pinfo->dst, &%(ACTX)s->pinfo->src)),
        upcoming_olc);
    }
  }
  upcoming_olc = NULL;

  if (h245_pi != NULL)
    h245_pi->msg_type = H245_OpenLogChn;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR OpenLogicalChannel/forwardLogicalChannelNumber
  if (upcoming_olc) upcoming_olc->fwd_lc_num = h245_lc_temp;
  h223_fw_lc_num = h245_lc_temp;
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY OpenLogicalChannel/forwardLogicalChannelParameters

  upcoming_channel = (upcoming_olc) ? &upcoming_olc->fwd_lc : NULL;

  h245_lc_dissector = NULL;
%(DEFAULT_BODY)s
  if(h223_lc_params_temp && h245_lc_dissector)
	h223_lc_params_temp->subdissector = h245_lc_dissector;
  else if(h223_lc_params_temp)
	h223_lc_params_temp->subdissector = data_handle;

  if (upcoming_channel && codec_type) {
    g_strlcpy(upcoming_channel->data_type_str, codec_type, sizeof(upcoming_channel->data_type_str));
  }
  upcoming_channel = NULL;
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR OpenLogicalChannel/forwardLogicalChannelParameters/multiplexParameters/h223LogicalChannelParameters
  h223_fw_lc_params = wmem_new(wmem_file_scope(), h223_lc_params);
  h223_fw_lc_params->al_type = al_nonStandard;
  h223_fw_lc_params->al_params = NULL;
  h223_fw_lc_params->segmentable = 0;
  h223_fw_lc_params->subdissector = NULL;
  h223_lc_params_temp = h223_fw_lc_params;
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY OpenLogicalChannel/reverseLogicalChannelParameters

  upcoming_channel = (upcoming_olc) ? &upcoming_olc->rev_lc : NULL;

%(DEFAULT_BODY)s

  if (upcoming_channel && codec_type) {
    g_strlcpy(upcoming_channel->data_type_str, codec_type, sizeof(upcoming_channel->data_type_str));
  }
  upcoming_channel = NULL;
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR OpenLogicalChannel/reverseLogicalChannelParameters/multiplexParameters/h223LogicalChannelParameters
  h223_rev_lc_params = wmem_new(wmem_file_scope(), h223_lc_params);
  h223_rev_lc_params->al_type = al_nonStandard;
  h223_rev_lc_params->al_params = NULL;
  h223_rev_lc_params->segmentable = 0;
  h223_rev_lc_params->subdissector = NULL;
  h223_lc_params_temp = h223_rev_lc_params;
#.END
#========================================================================================


#=== OpenLogicalChannelAck ==============================================================
#.FN_BODY OpenLogicalChannelAck
  guint32 temp;
  int p2p_dir;
  h223_pending_olc *pend;
  const gchar *olc_key;
  olc_info_t *olc_req;

  upcoming_olc = (!actx->pinfo->fd->flags.visited) ? wmem_new0(wmem_packet_scope(), olc_info_t) : NULL;

  h223_fw_lc_num = 0;
  h223_rev_lc_num = 0;

%(DEFAULT_BODY)s

  temp = h223_fw_lc_num;
  p2p_dir = %(ACTX)s->pinfo->p2p_dir;

  if(%(ACTX)s->pinfo->p2p_dir == P2P_DIR_SENT)
	%(ACTX)s->pinfo->p2p_dir = P2P_DIR_RECV;
  else
	%(ACTX)s->pinfo->p2p_dir = P2P_DIR_SENT;
  pend = (h223_pending_olc *)g_hash_table_lookup( h223_pending_olc_reqs[%(ACTX)s->pinfo->p2p_dir], GINT_TO_POINTER(temp) );
  if (pend) {
	DISSECTOR_ASSERT( ( h223_rev_lc_num &&  pend->rev_channel_params)
				   || (!h223_rev_lc_num && !pend->rev_channel_params) );
	if(h223_add_lc_handle) {
	  (*h223_add_lc_handle)( %(ACTX)s->pinfo, h223_fw_lc_num, pend->fw_channel_params, %(ACTX)s->pinfo->ctype, %(ACTX)s->pinfo->circuit_id );
	  if(h223_rev_lc_num)
		(*h223_add_lc_handle)( %(ACTX)s->pinfo, h223_rev_lc_num, pend->rev_channel_params, %(ACTX)s->pinfo->ctype, %(ACTX)s->pinfo->circuit_id );
	}
  } else {
	/* we missed the OpenLogicalChannel packet */
  }
  %(ACTX)s->pinfo->p2p_dir = p2p_dir;

  if (upcoming_olc) {
    olc_key = gen_olc_key(upcoming_olc->fwd_lc_num, &%(ACTX)s->pinfo->src, &%(ACTX)s->pinfo->dst);
    olc_req = (olc_info_t *)g_hash_table_lookup(h245_pending_olc_reqs, olc_key);
    if (olc_req) {
      update_unicast_addr(&olc_req->fwd_lc.media_addr, &upcoming_olc->fwd_lc.media_addr);
      update_unicast_addr(&olc_req->fwd_lc.media_control_addr, &upcoming_olc->fwd_lc.media_control_addr);
      update_unicast_addr(&olc_req->rev_lc.media_addr, &upcoming_olc->rev_lc.media_addr);
      update_unicast_addr(&olc_req->rev_lc.media_control_addr, &upcoming_olc->rev_lc.media_control_addr);
      h245_setup_channels(actx->pinfo, &olc_req->fwd_lc);
      h245_setup_channels(actx->pinfo, &olc_req->rev_lc);
      g_hash_table_remove(h245_pending_olc_reqs, olc_key);
    } else {
      h245_setup_channels(actx->pinfo, &upcoming_olc->fwd_lc);
    }
  }
  upcoming_olc = NULL;

  if (h245_pi != NULL)
	h245_pi->msg_type = H245_OpenLogChnAck;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR OpenLogicalChannelAck/forwardLogicalChannelNumber
  if (upcoming_olc) upcoming_olc->fwd_lc_num = h245_lc_temp;
  h223_fw_lc_num = h245_lc_temp;
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY OpenLogicalChannelAck/forwardMultiplexAckParameters

  upcoming_channel = (upcoming_olc) ? &upcoming_olc->fwd_lc : NULL;

%(DEFAULT_BODY)s

  upcoming_channel = NULL;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR OpenLogicalChannelAck/reverseLogicalChannelParameters/reverseLogicalChannelNumber
  h223_rev_lc_num = h245_lc_temp;
#.END
#========================================================================================

#----------------------------------------------------------------------------------------
#.FN_HDR H223LogicalChannelParameters/adaptationLayerType/al1Framed
  if(h223_lc_params_temp)
	h223_lc_params_temp->al_type = al1Framed;
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR H223LogicalChannelParameters/adaptationLayerType/al1NotFramed
  if(h223_lc_params_temp)
	h223_lc_params_temp->al_type = al1NotFramed;
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR H223LogicalChannelParameters/adaptationLayerType/al2WithoutSequenceNumbers
  if(h223_lc_params_temp)
	h223_lc_params_temp->al_type = al2WithoutSequenceNumbers;
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR H223LogicalChannelParameters/adaptationLayerType/al2WithSequenceNumbers
  if(h223_lc_params_temp)
	h223_lc_params_temp->al_type = al2WithSequenceNumbers;
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR H223LogicalChannelParameters/adaptationLayerType/al3
 if(h223_lc_params_temp) {
	h223_lc_params_temp->al_type = al3;
	h223_lc_params_temp->al_params = wmem_new(wmem_file_scope(), h223_al3_params);
  }
#.END
#----------------------------------------------------------------------------------------
#.FN_PARS Al3/controlFieldOctets
  VAL_PTR = &value
#.FN_BODY Al3/controlFieldOctets
  guint32 value;
%(DEFAULT_BODY)s
  if(h223_lc_params_temp && h223_lc_params_temp->al_params)
	((h223_al3_params*)h223_lc_params_temp->al_params)->control_field_octets = value & 3 ;
#.END
#----------------------------------------------------------------------------------------
#.FN_PARS Al3/sendBufferSize
  VAL_PTR = &value
#.FN_BODY Al3/sendBufferSize
  guint32 value;
%(DEFAULT_BODY)s
  if(h223_lc_params_temp && h223_lc_params_temp->al_params)
	((h223_al3_params*)h223_lc_params_temp->al_params)->send_buffer_size = value & 0xfffff;
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR H223LogicalChannelParameters/adaptationLayerType/al1M
  if(h223_lc_params_temp)
	h223_lc_params_temp->al_type = al1M;
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR H223LogicalChannelParameters/adaptationLayerType/al2M
  if(h223_lc_params_temp)
	h223_lc_params_temp->al_type = al2M;
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR H223LogicalChannelParameters/adaptationLayerType/al3M
  if(h223_lc_params_temp)
	h223_lc_params_temp->al_type = al3M;
#.END
#----------------------------------------------------------------------------------------
#.FN_PARS H223LogicalChannelParameters/segmentableFlag
  VAL_PTR = &value
#.FN_BODY H223LogicalChannelParameters/segmentableFlag
  gboolean value;
%(DEFAULT_BODY)s
  if(h223_lc_params_temp)
	h223_lc_params_temp->segmentable = value;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR H263VideoCapability
  h245_lc_dissector = h263_handle;
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY RequestMessage  VAL_PTR = &value
  gint32 value;

%(DEFAULT_BODY)s
  print_info_column(%(ACTX)s->pinfo->cinfo, &value, h245_RequestMessage_vals, h245_RequestMessage_short_vals);

	if (( codec_type != NULL ) && ( value == RequestMessage_openLogicalChannel) ){
		col_append_fstr(%(ACTX)s->pinfo->cinfo, COL_INFO, "(%%s) ", codec_type );
	}

        col_set_fence(%(ACTX)s->pinfo->cinfo,COL_INFO);

    /* Add to packet info */
	if (h245_pi == NULL)
		return offset;

    if (strlen(h245_pi->frame_label) == 0)
    {
      g_snprintf(h245_pi->frame_label, 50, "%%s", val_to_str(value, h245_RequestMessage_short_vals, "UKN"));

      /* if it is OLC or RM*/
      if ((codec_type != NULL) && (( value == RequestMessage_openLogicalChannel) || ( value == RequestMessage_requestMode)))
      {
        g_strlcat(h245_pi->frame_label, " (", 50);
        g_strlcat(h245_pi->frame_label, codec_type, 50);
        g_strlcat(h245_pi->frame_label, ")", 50);
      }
    }
    g_strlcat(h245_pi->comment, val_to_str(value, h245_RequestMessage_vals, "<unknown>"), 50);
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY ResponseMessage  VAL_PTR = &value
  gint32 value;

%(DEFAULT_BODY)s
  print_info_column(%(ACTX)s->pinfo->cinfo, &value, h245_ResponseMessage_vals, h245_ResponseMessage_short_vals);
	col_set_fence(%(ACTX)s->pinfo->cinfo,COL_INFO);

	if (h245_pi != NULL){
		/* Add to packet info */
		if ( strlen(h245_pi->frame_label) == 0 ){
		   g_snprintf(h245_pi->frame_label, 50, "%%s", val_to_str(value, h245_ResponseMessage_short_vals, "UKN"));
		}
		g_strlcat(h245_pi->comment, val_to_str(value, h245_ResponseMessage_vals, "<unknown>"), 50);
	}

#.END
#----------------------------------------------------------------------------------------
#.FN_BODY IndicationMessage  VAL_PTR = &value
  gint32 value;

%(DEFAULT_BODY)s
  print_info_column(%(ACTX)s->pinfo->cinfo, &value, h245_IndicationMessage_vals, h245_IndicationMessage_short_vals);
	col_set_fence(%(ACTX)s->pinfo->cinfo,COL_INFO);

    /* Add to packet info */
    if (h245_pi  !=NULL){
      if ( strlen(h245_pi->frame_label) == 0 ){
	    g_snprintf(h245_pi->frame_label, 50, "%%s", val_to_str(value, h245_IndicationMessage_short_vals, "UKN"));
	  }
      g_strlcat(h245_pi->comment, val_to_str(value, h245_IndicationMessage_vals, "<unknown>"), 50);

    }

#.END
#----------------------------------------------------------------------------------------
#.FN_BODY CommandMessage  VAL_PTR = &value
  gint32 value;

%(DEFAULT_BODY)s
  print_info_column(%(ACTX)s->pinfo->cinfo, &value, h245_CommandMessage_vals, h245_CommandMessage_short_vals);
	col_set_fence(%(ACTX)s->pinfo->cinfo,COL_INFO);

    /* Add to packet info */
    if (h245_pi != NULL){
      if ( strlen(h245_pi->frame_label) == 0 ){
        g_snprintf(h245_pi->frame_label, 50, "%%s", val_to_str(value, h245_CommandMessage_short_vals, "UKN"));
      }
	  g_strlcat(h245_pi->comment, val_to_str(value, h245_CommandMessage_vals, "<unknown>"), 50);
    }

#.END
#----------------------------------------------------------------------------------------
#.FN_BODY AudioCapability  VAL_PTR = &value
  gint32 value;

%(DEFAULT_BODY)s
        codec_type = val_to_str(value, h245_AudioCapability_short_vals, "<unknown>");
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY VideoCapability  VAL_PTR = &value
  gint32 value;

%(DEFAULT_BODY)s
        codec_type = val_to_str(value, h245_VideoCapability_vals, "<unknown>");

#.END
#----------------------------------------------------------------------------------------
#.FN_BODY Application  VAL_PTR = &value
  gint32 value;

%(DEFAULT_BODY)s
        codec_type = val_to_str(value, h245_Application_vals, "<unknown>");
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY AudioMode  VAL_PTR = &value
  gint32 value;

%(DEFAULT_BODY)s
  codec_type = val_to_str(value, h245_AudioMode_vals, "<unknown>");
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY VideoMode  VAL_PTR = &value
  gint32 value;

%(DEFAULT_BODY)s
  codec_type = val_to_str(value, h245_VideoMode_vals, "<unknown>");
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY DataMode/application  VAL_PTR = &value
  gint32 value;

%(DEFAULT_BODY)s
  codec_type = val_to_str(value, h245_DataModeApplication_vals, "<unknown>");
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR MasterSlaveDeterminationAck

if (h245_pi != NULL)
  h245_pi->msg_type = H245_MastSlvDetAck;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR MasterSlaveDeterminationReject

if (h245_pi != NULL)
  h245_pi->msg_type = H245_MastSlvDetRjc;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR OpenLogicalChannelReject

if (h245_pi != NULL)
  h245_pi->msg_type = H245_OpenLogChnRjc;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR CloseLogicalChannel

if (h245_pi != NULL)
  h245_pi->msg_type = H245_CloseLogChn;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR CloseLogicalChannelAck

if (h245_pi != NULL)
  h245_pi->msg_type = H245_CloseLogChnAck;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR OpenLogicalChannelConfirm

if (h245_pi != NULL)
  h245_pi->msg_type = H245_OpenLogChnCnf;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR TerminalCapabilitySetAck

if (h245_pi != NULL)
  h245_pi->msg_type = H245_TermCapSetAck;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR MasterSlaveDetermination

if (h245_pi != NULL)
  h245_pi->msg_type = H245_MastSlvDet;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR TerminalCapabilitySetReject

if (h245_pi != NULL)
  h245_pi->msg_type = H245_TermCapSetRjc;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR MasterSlaveDeterminationRelease

if (h245_pi != NULL)
  h245_pi->msg_type = H245_MastSlvDetRls;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR TerminalCapabilitySet

if (h245_pi != NULL)
  h245_pi->msg_type = H245_TermCapSet;
#.END
#----------------------------------------------------------------------------------------
#.FN_FTR TerminalCapabilitySetRelease

if (h245_pi != NULL)
  h245_pi->msg_type = H245_TermCapSetRls;
#.END
#----------------------------------------------------------------------------------------

#=== Generic Extensible Framework =======================================================

#.FN_HDR GenericMessage
  void *priv_data = actx->private_data;
  gef_ctx_t *gefx;

  /* check if not inherited from GenericInformation */
  gefx = gef_ctx_get(actx->private_data);
  if (!gefx) {
    gefx = gef_ctx_alloc(NULL, "GenericMessage");
    actx->private_data = gefx;
  }
#.FN_FTR
  actx->private_data = priv_data;
#.END

#.FN_BODY GenericMessage/subMessageIdentifier  VAL_PTR = &subMessageIdentifer
  guint32 subMessageIdentifer;
  gef_ctx_t *gefx;

  gefx = gef_ctx_get(actx->private_data);
  if (gefx) {
	/* If this is a standard generic message use hf_h245_subMessageIdentifier_standard to get
	 * the value translated and make it fileterable.
	 */
    if (strcmp("GenericMessage/0.0.8.239.2", gefx->key) == 0) {
      hf_index = hf_h245_subMessageIdentifier_standard;
    }
  }

%(DEFAULT_BODY)s
  if (gefx) {
    gefx->subid = wmem_strdup_printf(wmem_packet_scope(), "%%u", subMessageIdentifer);
    gef_ctx_update_key(gef_ctx_get(actx->private_data));
  }
  if (hf_index == hf_h245_subMessageIdentifier_standard)
  {
    col_append_fstr(actx->pinfo->cinfo, COL_INFO, "%%s", val_to_str(subMessageIdentifer, h245_h239subMessageIdentifier_vals, "<unknown>") );
    g_snprintf(h245_pi->frame_label, 50, "%%s", val_to_str(subMessageIdentifer, h245_h239subMessageIdentifier_vals, "<unknown>"));
  }
#.END

#.FN_HDR GenericMessage/messageContent/_item
  gef_ctx_t *parent_gefx;

  parent_gefx = gef_ctx_get(actx->private_data);
  actx->private_data = gef_ctx_alloc(parent_gefx, NULL);
#.FN_FTR
  actx->private_data = parent_gefx;
#.END

#----------------------------------------------------------------------------------------
#.FN_HDR GenericInformation
  void *priv_data = actx->private_data;
  actx->private_data = gef_ctx_alloc(NULL, "GenericInformation");
#.FN_FTR
  actx->private_data = priv_data;
#.END

#--- GenericCapability ------------------------------------------------------------------
#.FN_HDR GenericCapability
  void *priv_data = actx->private_data;
  actx->private_data = gef_ctx_alloc(NULL, "GenericCapability");
#.FN_FTR
  actx->private_data = priv_data;
#.END

#.FN_HDR GenericCapability/collapsing/_item
  gef_ctx_t *parent_gefx;

  parent_gefx = gef_ctx_get(actx->private_data);
  actx->private_data = gef_ctx_alloc(parent_gefx, "collapsing");
#.FN_FTR
  actx->private_data = parent_gefx;
#.END

#.FN_HDR GenericCapability/nonCollapsing/_item
  gef_ctx_t *parent_gefx;

  parent_gefx = gef_ctx_get(actx->private_data);
  actx->private_data = gef_ctx_alloc(parent_gefx, "nonCollapsing");
#.FN_FTR
  actx->private_data = parent_gefx;
#.END

#.FN_BODY GenericCapability/nonCollapsingRaw    VAL_PTR = &value_tvb
  tvbuff_t *value_tvb;
  gef_ctx_t *parent_gefx;
  gef_ctx_t *gefx;
  proto_item* ti;

  parent_gefx = gef_ctx_get(actx->private_data);
  actx->private_data = gef_ctx_alloc(parent_gefx, "nonCollapsingRaw");
%(DEFAULT_BODY)s
  gefx = gef_ctx_get(actx->private_data);
  if (gefx) {
    ti = proto_tree_add_string(tree, hf_h245_debug_dissector_try_string, tvb, offset>>3, 0, gefx->key);
	PROTO_ITEM_SET_HIDDEN(ti);
    dissector_try_string(gef_content_dissector_table, gefx->key, value_tvb, %(ACTX)s->pinfo, %(TREE)s, %(ACTX)s);
  }
  actx->private_data = parent_gefx;
#.END

#--- EncryptionSync ---------------------------------------------------------------------
#.FN_HDR EncryptionSync
  void *priv_data = actx->private_data;
  actx->private_data = gef_ctx_alloc(NULL, "EncryptionSync");
#.FN_FTR
  actx->private_data = priv_data;
#.END
#----------------------------------------------------------------------------------------

#.FN_HDR CapabilityIdentifier
  gef_ctx_t *gefx;
  proto_item* ti;

#.FN_FTR
  gef_ctx_update_key(gef_ctx_get(actx->private_data));
  gefx = gef_ctx_get(actx->private_data);
  if (gefx) {
    ti = proto_tree_add_string(tree, hf_h245_debug_dissector_try_string, tvb, offset>>3, 0, gefx->key);
	PROTO_ITEM_SET_HIDDEN(ti);
    dissector_try_string(gef_name_dissector_table, gefx->key, tvb_new_subset(tvb, offset>>3, 0, 0), actx->pinfo, tree, actx);
  }
  actx->private_data = gefx;  /* subdissector could overwrite it */
#.END

#.FN_BODY CapabilityIdentifier/standard  FN_VARIANT = _str  VAL_PTR = &standard_oid_str
  const gchar *standard_oid_str = NULL;
  gef_ctx_t *gefx;

%(DEFAULT_BODY)s
  gefx = gef_ctx_get(actx->private_data);
  if (gefx) gefx->id = standard_oid_str;

  if(strcmp(standard_oid_str,"0.0.8.235.0.3.76") == 0) {  /* MIKEY */
    if (upcoming_channel)
	  upcoming_channel->srtp_flag = TRUE;
  }

  if(!h245_lc_dissector && strcmp(standard_oid_str,"0.0.8.245.1.1.1") == 0)
	h245_lc_dissector = amr_handle;
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR ParameterIdentifier
  gef_ctx_t *gefx;
  proto_item* ti;
#.FN_FTR
  gef_ctx_update_key(gef_ctx_get(actx->private_data));
  gefx = gef_ctx_get(actx->private_data);
  if (gefx) {
    ti = proto_tree_add_string(tree, hf_h245_debug_dissector_try_string, tvb, offset>>3, 0, gefx->key);
	PROTO_ITEM_SET_HIDDEN(ti);
    dissector_try_string(gef_name_dissector_table, gefx->key, tvb_new_subset(tvb, offset>>3, 0, 0), actx->pinfo, tree, actx);
  }
  actx->private_data = gefx;  /* subdissector could overwrite it */
#.END

#.FN_BODY ParameterIdentifier/standard  VAL_PTR = &value_int
  guint32 value_int = (guint32)-1;
  gef_ctx_t *gefx;

%(DEFAULT_BODY)s
  gefx = gef_ctx_get(actx->private_data);
  if (gefx) gefx->id = wmem_strdup_printf(wmem_packet_scope(), "%%d", value_int);
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY ParameterValue/booleanArray  VAL_PTR = &value
  guint32 value;
  guint8 *buf;
  tvbuff_t *value_tvb;
  gef_ctx_t *gefx;
  proto_item* ti;

%(DEFAULT_BODY)s
  gefx = gef_ctx_get(actx->private_data);
  if (gefx) {
    buf = wmem_new(actx->pinfo->pool, guint8);
    buf[0] = value;
    value_tvb = tvb_new_child_real_data(tvb, buf, sizeof(guint8), sizeof(guint8));
    ti = proto_tree_add_string(tree, hf_h245_debug_dissector_try_string, tvb, offset>>3, 0, gefx->key);
	PROTO_ITEM_SET_HIDDEN(ti);
    add_new_data_source(%(ACTX)s->pinfo, value_tvb, "booleanArray");
    dissector_try_string(gef_content_dissector_table, gefx->key, value_tvb, %(ACTX)s->pinfo, %(TREE)s, %(ACTX)s);
  }
#.END
#.FN_BODY ParameterValue/unsignedMin  VAL_PTR = &value
  guint32 value;
  guint8 *buf;
  tvbuff_t *value_tvb;
  gef_ctx_t *gefx;
  proto_item* ti;

%(DEFAULT_BODY)s
  gefx = gef_ctx_get(actx->private_data);
  if (gefx) {
    buf = (guint8 *)wmem_new(actx->pinfo->pool, guint16);
    phton16(buf, value);
    value_tvb = tvb_new_child_real_data(tvb, buf, sizeof(guint16), sizeof(guint16));
    ti = proto_tree_add_string(tree, hf_h245_debug_dissector_try_string, tvb, offset>>3, 0, gefx->key);
	PROTO_ITEM_SET_HIDDEN(ti);
    add_new_data_source(%(ACTX)s->pinfo, value_tvb, "unsignedMin");
    dissector_try_string(gef_content_dissector_table, gefx->key, value_tvb, %(ACTX)s->pinfo, %(TREE)s, %(ACTX)s);
  }
#.END
#.FN_BODY ParameterValue/unsignedMax  VAL_PTR = &value
  guint32 value;
  guint8 *buf;
  tvbuff_t *value_tvb;
  gef_ctx_t *gefx;
  proto_item* ti;

%(DEFAULT_BODY)s
  gefx = gef_ctx_get(actx->private_data);
  if (gefx) {
    buf = (guint8 *)wmem_new(actx->pinfo->pool, guint16);
    phton16(buf, value);
    value_tvb = tvb_new_child_real_data(tvb, buf, sizeof(guint16), sizeof(guint16));
    ti = proto_tree_add_string(tree, hf_h245_debug_dissector_try_string, tvb, offset>>3, 0, gefx->key);
	PROTO_ITEM_SET_HIDDEN(ti);
    add_new_data_source(%(ACTX)s->pinfo, value_tvb, "unsignedMax");
    dissector_try_string(gef_content_dissector_table, gefx->key, value_tvb, %(ACTX)s->pinfo, %(TREE)s, %(ACTX)s);
  }
#.END
#.FN_BODY ParameterValue/unsigned32Min  VAL_PTR = &value
  guint32 value;
  guint8 *buf;
  tvbuff_t *value_tvb;
  gef_ctx_t *gefx;
  proto_item* ti;

%(DEFAULT_BODY)s
  gefx = gef_ctx_get(actx->private_data);
  if (gefx) {
    buf = (guint8 *)wmem_new(actx->pinfo->pool, guint32);
    phton32(buf, value);
    value_tvb = tvb_new_child_real_data(tvb, buf, sizeof(guint32), sizeof(guint32));
    ti = proto_tree_add_string(tree, hf_h245_debug_dissector_try_string, tvb, offset>>3, 0, gefx->key);
	PROTO_ITEM_SET_HIDDEN(ti);
    add_new_data_source(%(ACTX)s->pinfo, value_tvb, "unsigned32Min");
    dissector_try_string(gef_content_dissector_table, gefx->key, value_tvb, %(ACTX)s->pinfo, %(TREE)s, %(ACTX)s);
  }
#.END
#.FN_BODY ParameterValue/unsigned32Max  VAL_PTR = &value
  guint32 value;
  guint8 *buf;
  tvbuff_t *value_tvb;
  gef_ctx_t *gefx;
  proto_item* ti;

%(DEFAULT_BODY)s
  gefx = gef_ctx_get(actx->private_data);
  if (gefx) {
    buf = (guint8 *)wmem_new(actx->pinfo->pool, guint32);
    phton32(buf, value);
    value_tvb = tvb_new_child_real_data(tvb, buf, sizeof(guint32), sizeof(guint32));
    ti = proto_tree_add_string(tree, hf_h245_debug_dissector_try_string, tvb, offset>>3, 0, gefx->key);
	PROTO_ITEM_SET_HIDDEN(ti);
    add_new_data_source(%(ACTX)s->pinfo, value_tvb, "unsigned32Max");
    dissector_try_string(gef_content_dissector_table, gefx->key, value_tvb, %(ACTX)s->pinfo, %(TREE)s, %(ACTX)s);
  }
#.END
#.FN_BODY ParameterValue/octetString  VAL_PTR = &value_tvb
  tvbuff_t *value_tvb;
  gef_ctx_t *gefx;
  proto_item* ti;

%(DEFAULT_BODY)s
  gefx = gef_ctx_get(actx->private_data);
  if (gefx) {
    ti = proto_tree_add_string(tree, hf_h245_debug_dissector_try_string, tvb, offset>>3, 0, gefx->key);
	PROTO_ITEM_SET_HIDDEN(ti);
    dissector_try_string(gef_content_dissector_table, gefx->key, value_tvb, %(ACTX)s->pinfo, %(TREE)s, %(ACTX)s);
  }
#.END

#=== end of GEF =========================================================================

#----------------------------------------------------------------------------------------
#.FN_BODY UnicastAddress/iPAddress/network  VAL_PTR = &value_tvb
  tvbuff_t *value_tvb;

%(DEFAULT_BODY)s

  if (upcoming_channel && upcoming_channel->upcoming_addr) {
    tvb_memcpy(value_tvb, upcoming_channel->upcoming_addr->addr_buf, 0, 4);
    set_address(&upcoming_channel->upcoming_addr->addr, AT_IPv4, 4, upcoming_channel->upcoming_addr->addr_buf);
  }
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY UnicastAddress/iPAddress/tsapIdentifier  VAL_PTR = &tsapIdentifier
  guint32 tsapIdentifier;

%(DEFAULT_BODY)s

  if (upcoming_channel && upcoming_channel->upcoming_addr) {
    upcoming_channel->upcoming_addr->port = tsapIdentifier;
  }
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY UnicastAddress/iP6Address/network  VAL_PTR = &value_tvb
  tvbuff_t *value_tvb;

%(DEFAULT_BODY)s

  if (upcoming_channel && upcoming_channel->upcoming_addr) {
    tvb_memcpy(value_tvb, upcoming_channel->upcoming_addr->addr_buf, 0, 16);
    set_address(&upcoming_channel->upcoming_addr->addr, AT_IPv6, 16, upcoming_channel->upcoming_addr->addr_buf);
  }
#.END
#----------------------------------------------------------------------------------------
#.FN_BODY UnicastAddress/iP6Address/tsapIdentifier  VAL_PTR = &tsapIdentifier
  guint32 tsapIdentifier;

%(DEFAULT_BODY)s

  if (upcoming_channel && upcoming_channel->upcoming_addr) {
    upcoming_channel->upcoming_addr->port = tsapIdentifier;
  }
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR H2250LogicalChannelAckParameters/mediaChannel
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = &upcoming_channel->media_addr;
#.END
#.FN_FTR H2250LogicalChannelAckParameters/mediaChannel
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = NULL;
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR H2250LogicalChannelParameters/mediaChannel
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = &upcoming_channel->media_addr;
#.END
#.FN_FTR H2250LogicalChannelParameters/mediaChannel
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = NULL;
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR H2250LogicalChannelAckParameters/mediaControlChannel
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = &upcoming_channel->media_control_addr;
#.END
#.FN_FTR H2250LogicalChannelAckParameters/mediaControlChannel
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = NULL;
#.END
#----------------------------------------------------------------------------------------
#.FN_HDR H2250LogicalChannelParameters/mediaControlChannel
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = &upcoming_channel->media_control_addr;
#.END
#.FN_FTR H2250LogicalChannelParameters/mediaControlChannel
  if (upcoming_channel)
    upcoming_channel->upcoming_addr = NULL;
#.END

#--- RTPPayloadType ---------------------------------------------------------------------
#.FN_HDR RTPPayloadType
  rfc_number = 0;
#.END

#.FN_PARS RTPPayloadType/payloadDescriptor/rfc-number
  VAL_PTR = &rfc_number
#.END

#.FN_BODY RTPPayloadType/payloadType  VAL_PTR = &pt
  unsigned int pt;

%(DEFAULT_BODY)s

  if ((rfc_number == 2198) && upcoming_channel) {
    upcoming_channel->rfc2198 = pt;
  }
#.END

#--- NonStandardParameter ---------------------------------------------------------------

#.FN_PARS
NonStandardIdentifier/object  FN_VARIANT = _str  VAL_PTR = &nsiOID
#.END
#.FN_BODY NonStandardIdentifier  VAL_PTR = &value
	gint32 value;

	nsiOID = "";
	h221NonStandard = 0;

%(DEFAULT_BODY)s
	switch (value) {
		case 0 :  /* object */
			nsp_handle = dissector_get_string_handle(nsp_object_dissector_table, nsiOID);
			break;
		case 1 :  /* h221NonStandard */
			nsp_handle = dissector_get_uint_handle(nsp_h221_dissector_table, h221NonStandard);
			break;
		default :
			nsp_handle = NULL;
    }
#.END

#.FN_HDR NonStandardIdentifier/h221NonStandard
  t35CountryCode = 0;
  t35Extension = 0;
  manufacturerCode = 0;
#.FN_FTR NonStandardIdentifier/h221NonStandard
  h221NonStandard = ((t35CountryCode * 256) + t35Extension) * 65536 + manufacturerCode;
  proto_tree_add_uint(tree, hf_h245Manufacturer, tvb, (offset>>3)-4, 4, h221NonStandard);
#.FN_PARS
NonStandardIdentifier/h221NonStandard/t35CountryCode    VAL_PTR = &t35CountryCode
NonStandardIdentifier/h221NonStandard/t35Extension      VAL_PTR = &t35Extension
NonStandardIdentifier/h221NonStandard/manufacturerCode  VAL_PTR = &manufacturerCode
#.END

#.FN_HDR NonStandardParameter
  nsp_handle = NULL;
#.FN_BODY NonStandardParameter/data  VAL_PTR = &next_tvb
  tvbuff_t *next_tvb = NULL;

%(DEFAULT_BODY)s
  if (next_tvb && tvb_reported_length(next_tvb)) {
    call_dissector((nsp_handle)?nsp_handle:data_handle, next_tvb, %(ACTX)s->pinfo, tree);
  }
#.END

#.FN_BODY FunctionNotSupported/returnedFunction  VAL_PTR = &next_tvb
  tvbuff_t *next_tvb = NULL;
  proto_item *item;
  proto_tree *subtree;
  h245_packet_info *saved_h245_pi;

%(DEFAULT_BODY)s

 if (next_tvb && tvb_reported_length(next_tvb)) {
	saved_h245_pi = h245_pi;
	h245_pi = NULL;
	subtree = proto_tree_add_subtree(tree, next_tvb, 0, -1, ett_h245_returnedFunction, &item, "The returned function");
	PROTO_ITEM_SET_GENERATED(item);
	dissect_h245_MultimediaSystemControlMessage(next_tvb, 0, actx, subtree, hf_h245_pdu_type);
	h245_pi = saved_h245_pi;
 }

#.FN_BODY DataType VAL_PTR = &choice_index
gint choice_index;

%(DEFAULT_BODY)s

if (upcoming_channel){
	if (choice_index==2){
		upcoming_channel->is_video=TRUE;
	}else{
		upcoming_channel->is_video=FALSE;
	}
}

#----------------------------------------------------------------------------------------
#.TYPE_RENAME

NewATMVCCommand/aal Cmd_aal
NewATMVCCommand/aal/aal1 Cmd_aal1
NewATMVCCommand/aal/aal5 Cmd_aal5
NewATMVCCommand/aal/aal1/clockRecovery Cmd_clockRecovery
NewATMVCCommand/aal/aal1/errorCorrection Cmd_errorCorrection
NewATMVCCommand/multiplex Cmd_multiplex
NewATMVCCommand/reverseParameters Cmd_reverseParameters
NewATMVCCommand/reverseParameters/multiplex CmdR_multiplex

NewATMVCIndication/aal Ind_aal
NewATMVCIndication/aal/aal1 Ind_aal1
NewATMVCIndication/aal/aal5 Ind_aal5
NewATMVCIndication/aal/aal1/clockRecovery Ind_clockRecovery
NewATMVCIndication/aal/aal1/errorCorrection Ind_errorCorrection
NewATMVCIndication/multiplex Ind_multiplex
NewATMVCIndication/reverseParameters Ind_reverseParameters
NewATMVCIndication/reverseParameters/multiplex IndR_multiplex

MultilinkRequest/callInformation  CallInformationReq
MultilinkRequest/addConnection AddConnectionReq
MultilinkRequest/removeConnection RemoveConnectionReq
MultilinkRequest/maximumHeaderInterval MaximumHeaderIntervalReq

MultilinkResponse/callInformation CallInformationResp
MultilinkResponse/addConnection AddConnectionResp
MultilinkResponse/removeConnection RemoveConnectionResp
MultilinkResponse/maximumHeaderInterval MaximumHeaderIntervalResp

MasterSlaveDeterminationReject/cause             MasterSlaveDeterminationRejectCause
TerminalCapabilitySetReject/cause                TerminalCapabilitySetRejectCause
OpenLogicalChannelReject/cause                   OpenLogicalChannelRejectCause
RequestChannelCloseReject/cause                  RequestChannelCloseRejectCause
MultiplexEntryRejectionDescriptions/cause        MultiplexEntryRejectionDescriptionsCause
RequestMultiplexEntryRejectionDescriptions/cause RequestMultiplexEntryRejectionDescriptionsCause
RequestModeReject/cause                          RequestModeRejectCause
MaintenanceLoopReject/cause                      MaintenanceLoopRejectCause
FunctionNotSupported/cause                       FunctionNotSupportedCause

AudioMode/g7231 Mode_g7231

DataMode/application DataModeApplication
DataMode/application/t38fax T38faxApp

DepFECData/rfc2733 RFC2733Data

IS13818AudioMode/audioLayer IS13818AudioLayer
IS13818AudioMode/audioSampling IS13818AudioSampling
IS13818AudioMode/multichannelType IS13818MultichannelType

H223ModeParameters/adaptationLayerType AdaptationLayerType

H223AL1MParameters/headerFEC AL1HeaderFEC
H223AL1MParameters/crcLength AL1CrcLength
H223AL2MParameters/headerFEC AL2HeaderFEC
H223AL3MParameters/crcLength AL3CrcLength

H261VideoMode/resolution H261Resolution
H263VideoMode/resolution H263Resolution

UnicastAddress/iPAddress/network Ipv4_network
MulticastAddress/iPAddress MIPAddress
MulticastAddress/iP6Address MIP6Address

NonStandardIdentifier/h221NonStandard H221NonStandardID
OpenLogicalChannel/forwardLogicalChannelNumber OLC_fw_lcn
OpenLogicalChannelAck/forwardLogicalChannelNumber OLC_ack_fw_lcn
OpenLogicalChannel/forwardLogicalChannelParameters/multiplexParameters OLC_forw_multiplexParameters
OpenLogicalChannel/reverseLogicalChannelParameters/multiplexParameters OLC_rev_multiplexParameters
OpenLogicalChannel/reverseLogicalChannelParameters OLC_reverseLogicalChannelParameters
OpenLogicalChannel/forwardLogicalChannelParameters/multiplexParameters/h223LogicalChannelParameters OLC_fw_h223_params
OpenLogicalChannel/reverseLogicalChannelParameters/multiplexParameters/h223LogicalChannelParameters OLC_rev_h223_params
OpenLogicalChannelAck/reverseLogicalChannelParameters OLC_ack_reverseLogicalChannelParameters
CloseLogicalChannel/reason Clc_reason
VCCapability/availableBitRates/type Avb_type
MultiplexElement/type Me_type
RedundancyEncodingDTModeElement/type Re_type
MaintenanceLoopRequest/type Mlr_type
MaintenanceLoopAck/type Mla_type
MaintenanceLoopReject/type Mlrej_type
MiscellaneousCommand/type Mc_type
MiscellaneousIndication/type Mi_type
V76LogicalChannelParameters/mode V76LCP_mode
DepFECData/rfc2733/mode FECdata_mode
DepFECMode/rfc2733Mode/mode FEC_mode
IS11172AudioMode/multichannelType IS11172_multichannelType
MultiplexElement/repeatCount/finite ME_finiteRepeatCount
MultiplexElement/repeatCount ME_repeatCount
DepFECCapability/rfc2733 FECC_rfc2733
RequestModeAck/response Req_mode_ack_response
UserInputIndication/signalUpdate/rtp Si_rtp
UnicastAddress/iPAddress/tsapIdentifier TsapIdentifier
H2250LogicalChannelAckParameters/mediaChannel Ack_mediaChannel
H2250LogicalChannelAckParameters/mediaControlChannel Ack_mediaControlChannel
CommunicationModeTableEntry/mediaChannel Cm_mediaChannel
#----------------------------------------------------------------------------------------
#.FIELD_RENAME
#----------------------------------------------------------------------------------------

NewATMVCCommand/aal cmd_aal
NewATMVCCommand/aal/aal1 cmd_aal1
NewATMVCCommand/aal/aal5 cmd_aal5
NewATMVCCommand/aal/aal1/clockRecovery  cmd_clockRecovery
NewATMVCCommand/aal/aal1/errorCorrection cmd_errorCorrection
NewATMVCCommand/multiplex cmd_multiplex
NewATMVCCommand/reverseParameters cmd_reverseParameters
NewATMVCCommand/reverseParameters/multiplex cmdr_multiplex

NewATMVCIndication/aal     ind_aal
NewATMVCIndication/aal/aal1 ind_aal1
NewATMVCIndication/aal/aal5 ind_aal5
NewATMVCIndication/aal/aal1/clockRecovery ind_clockRecovery
NewATMVCIndication/aal/aal1/errorCorrection ind_errorCorrection
NewATMVCIndication/multiplex ind_multiplex
NewATMVCIndication/reverseParameters ind_reverseParameters
NewATMVCIndication/reverseParameters/multiplex indr_multiplex

MultilinkRequest/callInformation  callInformationReq
MultilinkRequest/addConnection addConnectionReq
MultilinkRequest/removeConnection removeConnectionReq
MultilinkRequest/maximumHeaderInterval maximumHeaderIntervalReq

MultilinkResponse/callInformation callInformationResp
MultilinkResponse/addConnection addConnectionResp
MultilinkResponse/removeConnection removeConnectionResp
MultilinkResponse/maximumHeaderInterval maximumHeaderIntervalResp

MultiplexElement/type/logicalChannelNumber logicalChannelNum
ConnectionIdentifier/sequenceNumber sequenceNum

RequestMessage/nonStandard nonStandardMsg
ResponseMessage/nonStandard nonStandardMsg
CommandMessage/nonStandard nonStandardMsg
IndicationMessage/nonStandard nonStandardMsg
MultilinkRequest/nonStandard nonStandardMsg
MultilinkResponse/nonStandard nonStandardMsg
MultilinkIndication/nonStandard nonStandardMsg
DialingInformation/nonStandard nonStandardMsg
DialingInformationNetworkType/nonStandard nonStandardMsg

UserInputCapability/nonStandard ui_nonStandard
H2250LogicalChannelParameters/nonStandard nonStandardParams
H2250LogicalChannelAckParameters/nonStandard nonStandardParams
CommunicationModeTableEntry/nonStandard nonStandardParams
ConferenceCapability/nonStandardData nonStandardParams

UnicastAddress/iPXAddress/tsapIdentifier ipx_tsapIdentifier

NonStandardParameter/data nsd_data
NonStandardIdentifier/h221NonStandard h221NonStandardID

AudioMode/g711Alaw64k g711Alaw64k_mode
AudioMode/g711Alaw56k g711Alaw56k_mode
AudioMode/g711Ulaw64k g711Ulaw64k_mode
AudioMode/g711Ulaw56k g711Ulaw56k_mode
AudioMode/g722-64k    g722_64k_mode
AudioMode/g722-56k    g722_56k_mode
AudioMode/g722-48k    g722_48k_mode
AudioMode/g728        g728_mode
AudioMode/g729        g729_mode
AudioMode/g729AnnexA  g729AnnexA_mode
AudioMode/g7231       g7231_mode
AudioMode/vbd         vbd_mode

IS11172AudioMode/audioLayer/audioLayer1 audioLayer1Mode
IS11172AudioMode/audioLayer/audioLayer2 audioLayer2Mode
IS11172AudioMode/audioLayer/audioLayer3 audioLayer3Mode
IS11172AudioMode/audioSampling/audioSampling32k  audioSampling32kMode
IS11172AudioMode/audioSampling/audioSampling44k1 audioSampling44k1Mode
IS11172AudioMode/audioSampling/audioSampling48k  audioSampling48kMode
IS11172AudioMode/multichannelType/singleChannel  singleChannelMode

IS13818AudioMode/audioLayer             audioLayerMode
IS13818AudioMode/audioLayer/audioLayer1 audioLayer1Mode
IS13818AudioMode/audioLayer/audioLayer2 audioLayer2Mode
IS13818AudioMode/audioLayer/audioLayer3 audioLayer3Mode
IS13818AudioMode/audioSampling          audioSamplingMode
IS13818AudioMode/audioSampling/audioSampling16k       audioSampling16kMode
IS13818AudioMode/audioSampling/audioSampling22k05     audioSampling22k05Mode
IS13818AudioMode/audioSampling/audioSampling24k       audioSampling24kMode
IS13818AudioMode/audioSampling/audioSampling32k       audioSampling32kMode
IS13818AudioMode/audioSampling/audioSampling44k1      audioSampling44k1Mode
IS13818AudioMode/audioSampling/audioSampling48k       audioSampling48kMode
IS13818AudioMode/multichannelType/singleChannel       singleChannelMode
IS13818AudioMode/multichannelType/threeChannels2-1    threeChannels2_1Mode
IS13818AudioMode/multichannelType/threeChannels3-0    threeChannels3_0Mode
IS13818AudioMode/multichannelType/fourChannels2-0-2-0 fourChannels2_0_2_0Mode
IS13818AudioMode/multichannelType/fourChannels2-2     fourChannels2_2Mode
IS13818AudioMode/multichannelType/fourChannels3-1     fourChannels3_1Mode
IS13818AudioMode/multichannelType/fiveChannels3-0-2-0 fiveChannels3_0_2_0Mode
IS13818AudioMode/multichannelType/fiveChannels3-2     fiveChannels3_2Mode

H262VideoMode/profileAndLevel/profileAndLevel-SPatML        profileAndLevel_SPatMLMode
H262VideoMode/profileAndLevel/profileAndLevel-MPatLL        profileAndLevel_MPatLLMode
H262VideoMode/profileAndLevel/profileAndLevel-MPatML        profileAndLevel_MPatMLMode
H262VideoMode/profileAndLevel/profileAndLevel-MPatH-14      profileAndLevel_MPatH-14Mode
H262VideoMode/profileAndLevel/profileAndLevel-MPatHL        profileAndLevel_MPatHLMode
H262VideoMode/profileAndLevel/profileAndLevel-SNRatLL       profileAndLevel_SNRatLLMode
H262VideoMode/profileAndLevel/profileAndLevel-SNRatML       profileAndLevel_SNRatMLMode
H262VideoMode/profileAndLevel/profileAndLevel-SpatialatH-14 profileAndLevel_SpatialatH-14Mode
H262VideoMode/profileAndLevel/profileAndLevel-HPatML        profileAndLevel_HPatMLMode
H262VideoMode/profileAndLevel/profileAndLevel-HPatH-14      profileAndLevel_HPatH-14Mode
H262VideoMode/profileAndLevel/profileAndLevel-HPatHL        profileAndLevel_HPatHLMode

RedundancyEncodingMode/secondaryEncoding/audioData audioMode
RedundancyEncodingMode/secondaryEncoding  secondaryEncodingMode
RedundancyEncodingCapability/secondaryEncoding  secondaryEncodingCapability

UnicastAddress/iPAddress/network ip4_network
UnicastAddress/iP6Address/network ip6_network
MulticastAddress/iP6Address/network mip6_network
MulticastAddress/iPAddress mIPAddress
MulticastAddress/iP6Address mIP6Address
MulticastAddress/iPAddress/network mip4_network

RTPPayloadType/payloadType  rtpPayloadType
RTPPayloadType/payloadDescriptor/nonStandardIdentifier nonStandard
MediaPacketizationCapability/rtpPayloadType  rtpPayloadTypes
T84Profile/t84Restricted/cif cif_bool
T84Profile/t84Restricted/qcif qcif_bool
H223ModeParameters/adaptationLayerType adaptationLayer
H261VideoMode/resolution h261_resolution
H263VideoMode/resolution h263_resolution
H263VideoMode/resolution/custom custom_res
CommunicationModeTableEntry/dataType entryDataType
VCCapability/transportStream transportStream_bool
MultiplePayloadStreamMode/elements  mpsmElements
RedundancyEncodingDTMode/secondary  secondaryDTM
MultiplexEntrySendReject/rejectionDescriptions sendRejectionDescriptions

MultiplexEntrySendAck/multiplexTableEntryNumber multiplexTableEntryNumbers
MultiplexEntrySendRelease/multiplexTableEntryNumber multiplexTableEntryNumbers
CapabilityIdentifier/standard standardOid
MiscellaneousIndication/type/videoNotDecodedMBs/temporalReference temporalReference_0_255
CloseLogicalChannel/source cLC_source
DepFECCapability/rfc2733/separateStream separateStreamBool
DepFECCapability/rfc2733/separateStream/samePort samePortBool
VCCapability/aal1/srtsClockRecovery srtsClockRecovery_bool
VCCapability/aal1ViaGateway/srtsClockRecovery srtsClockRecoveryflag
DataMode/application/t84 t84DataProtocolCapability
DataMode/application/t38fax t38faxDataProtocolCapability
H2250LogicalChannelParameters/sessionID sessionID_0_255
H223Capability/mobileOperationTransmitCapability/h223AnnexADoubleFlag h223AnnexADoubleFlagFlag
SendTerminalCapabilitySet/genericRequest genericRequestFlag
H2250LogicalChannelParameters/mediaPacketization/h261aVideoPacketization h261aVideoPacketizationFlag
RemoteMCResponse/reject/functionNotSupported functionNotSupportedFlag
NewATMVCCommand/aal/aal1/errorCorrection/longInterleaver longInterleaverFlag
NewATMVCIndication/aal/aal1/errorCorrection/longInterleaver longInterleaverFlag
MiscellaneousCommand/type/videoFastUpdateMB/firstGOB firstGOB_0_255
H263VideoCapability/sqcifMPI sqcifMPI_1_32
EnhancementOptions/sqcifMPI sqcifMPI_1_32
NewATMVCCommand/aal/aal1/errorCorrection/shortInterleaver shortInterleaverFlag
NewATMVCIndication/aal/aal1/errorCorrection/shortInterleaver shortInterleaverFlag
NewATMVCCommand/multiplex/programStream programStreamFlag
NewATMVCCommand/reverseParameters/multiplex/programStream programStreamFlag
NewATMVCIndication/multiplex/programStream programStreamFlag
NewATMVCIndication/reverseParameters/multiplex/programStream programStreamFlag
H263ModeComboFlags/enhancedReferencePicSelect enhancedReferencePicSelectBool
NewATMVCCommand/aal/aal1/errorCorrection/errorCorrectionOnly errorCorrectionOnlyFlag
NewATMVCIndication/aal/aal1/errorCorrection/errorCorrectionOnly errorCorrectionOnlyFlag
UserInputCapability/extendedAlphanumeric extendedAlphanumericFlag
MultiplexElement/repeatCount/finite  me_repeatCount_finite
MiscellaneousCommand/type/videoFastUpdateMB/firstMB firstMB_1_8192
MiscellaneousIndication/type/videoNotDecodedMBs/firstMB firstMB_1_8192
H261VideoCapability/cifMPI cifMPI_1_4
CustomPictureClockFrequency/cifMPI cifMPI2_1_2048
H263VideoCapability/cif16MPI  cif16MPI_1_32
EnhancementOptions/cif16MPI  cif16MPI_1_32
H263VideoCapability/cif4MPI cif4MPI_1_32
EnhancementOptions/cif4MPI  cif4MPI_1_32
H263Version3Options/pictureNumber pictureNumberBoolean
MiscellaneousCommand/type/videoBadMBs/numberOfMBs numberOfMBs1_1_9216
MiscellaneousCommand/type/lostPartialPicture/numberOfMBs numberOfMBs1_1_9216
DataApplicationCapability/maxBitRate maxBitRate2_0_4294967295
GenericCapability/maxBitRate maxBitRate2_0_4294967295
H261VideoCapability/maxBitRate maxBitRate_1_19200
IS13818AudioCapability/bitRate bitRate2_1_1130
IS13818AudioMode/bitRate bitRate2_1_1130
IS11172AudioCapability/bitRate bitRate_1_448
IS11172AudioMode/bitRate  bitRate_1_448
DataMode/bitRate bitRate_0_4294967295
H223Capability/bitRate bitRate_1_19200
H261VideoMode/bitRate bitRate_1_19200
H263VideoMode/bitRate bitRate_1_19200
DialingInformationNumber/networkAddress networkAddressNum
NewATMVCCommand/aal/aal1/clockRecovery/adaptiveClockRecovery adaptiveClockRecoveryFlag
NewATMVCIndication/aal/aal1/clockRecovery/adaptiveClockRecovery adaptiveClockRecoveryFlag
NewATMVCCommand/aal/aal1/clockRecovery/nullClockRecovery nullClockRecoveryflag
NewATMVCIndication/aal/aal1/clockRecovery/nullClockRecovery nullClockRecoveryflag
NewATMVCCommand/aal/aal1/errorCorrection/nullErrorCorrection nullErrorCorrectionFlag
NewATMVCIndication/aal/aal1/errorCorrection/nullErrorCorrection nullErrorCorrectionFlag
H223AL2MParameters/headerFEC aL2HeaderFEC
H223AL1MParameters/headerFEC aL1HeaderFEC
H223AL1MParameters/crcLength crcLength2
H223AL3MParameters/crcLength crlength2
SendTerminalCapabilitySet/specificRequest/multiplexCapability multiplexCapabilityBool
DepFECCapability/rfc2733/redundancyEncoding redundancyEncodingBool
DepFECData/rfc2733/mode/redundancyEncoding redundancyEncodingFlag
DepFECMode/rfc2733Mode/mode/redundancyEncoding redundancyEncodingFlag
ParameterValue/genericParameter genericParameters

H261VideoCapability/qcifMPI qcifMPI_1_4
CustomPictureClockFrequency/qcifMPI qcifMPI_1_2048
DataMode/application datamodeapplication
MasterSlaveDeterminationReject/cause msd_rej_cause

OpenLogicalChannelReject/cause olc_rej_cause
RequestMultiplexEntryRejectionDescriptions/cause req_mux_rej_cause
RequestModeReject/cause req_rej_cause
MultiplexEntryRejectionDescriptions/cause mux_rej_cause
RequestChannelCloseReject/cause req_chan_clos_rej_cause
TerminalCapabilitySetReject/cause tcs_rej_cause
MaintenanceLoopReject/cause maintloop_rej_cause
FunctionNotSupported/cause fns_cause
Restriction/maximumBitRate res_maximumBitRate
RedundancyEncodingDTMode/primary prmary_dtmode
RedundancyEncoding/rtpRedundancyEncoding/primary primary
DepFECData/rfc2733  dep_rfc2733
DepFECMode/rfc2733Mode/mode fec_mode
DepFECData/rfc2733/mode fec_data_mode
FECData/rfc2733/pktMode/rfc2733sameport mode_rfc2733sameport
FECData/rfc2733/pktMode/rfc2733diffport mode_rfc2733diffport
V76LogicalChannelParameters/mode v76_mode
OpenLogicalChannelAck/reverseLogicalChannelParameters/multiplexParameters olc_ack_multiplexParameters
OpenLogicalChannel/forwardLogicalChannelNumber olc_fw_lcn
OpenLogicalChannelAck/forwardLogicalChannelNumber olc_ack_fw_lcn
OpenLogicalChannel/forwardLogicalChannelParameters/multiplexParameters olc_forw_multiplexParameters
OpenLogicalChannel/reverseLogicalChannelParameters/multiplexParameters olc_rev_multiplexParameter
IS11172AudioMode/multichannelType is11172multichannelType
IS13818AudioMode/multichannelType is13818MultichannelType
CloseLogicalChannel/reason clc_reason
MultiplexElement/repeatCount me_repeatCount
DepFECCapability/rfc2733 fecc_rfc2733
RequestModeAck/response req_mode_ack_response
UserInputIndication/signalUpdate/rtp si_rtp
VCCapability/availableBitRates/type avb_type
MultiplexElement/type me_type
RedundancyEncodingDTModeElement/type re_type
MaintenanceLoopRequest/type mlr_type
MaintenanceLoopAck/type mla_type
MaintenanceLoopReject/type mlrej_type
MiscellaneousCommand/type mc_type
MiscellaneousIndication/type mi_type
VBDMode/type vbd_type
VBDCapability/type vbd_cap_type
OpenLogicalChannelAck/reverseLogicalChannelParameters olc_ack_reverseLogicalChannelParameters
H2250LogicalChannelAckParameters/mediaChannel ack_mediaChannel
H2250LogicalChannelAckParameters/mediaControlChannel ack_mediaControlChannel
UnicastAddress/iP6Address/tsapIdentifier ipv6_tsapIdentifier
UnicastAddress/iPSourceRouteAddress/tsapIdentifier iPSrcRoute_tsapIdentifier
MulticastAddress/iPAddress/tsapIdentifier multicast_tsapIdentifier
MulticastAddress/iP6Address/tsapIdentifier multicast_IPv6_tsapIdentifier
CommunicationModeTableEntry/mediaChannel cm_mediaChannel
CommunicationModeTableEntry/mediaControlChannel cm_mediaControlChannel
Criteria/value criteriaValue

OpenLogicalChannel/reverseLogicalChannelParameters/multiplexParameters/h223LogicalChannelParameters olc_rev_h223_params
OpenLogicalChannel/forwardLogicalChannelParameters/multiplexParameters/h223LogicalChannelParameters olc_fw_h223_params

H223LogicalChannelParameters/adaptationLayerType/al1Framed                 h223_al_type_al1Framed
H223LogicalChannelParameters/adaptationLayerType/al1NotFramed              h223_al_type_al1NotFramed
H223LogicalChannelParameters/adaptationLayerType/al2WithoutSequenceNumbers h223_al_type_al2WithoutSequenceNumbers
H223LogicalChannelParameters/adaptationLayerType/al2WithSequenceNumbers    h223_al_type_al2WithSequenceNumbers
H223LogicalChannelParameters/adaptationLayerType/al3                       h223_al_type_al3
Al3/sendBufferSize                                                         al3_sendBufferSize
H223LogicalChannelParameters/adaptationLayerType/al1M                      h223_al_type_al1M
H223LogicalChannelParameters/adaptationLayerType/al2M                      h223_al_type_al2M
H223LogicalChannelParameters/adaptationLayerType/al3M                      h223_al_type_al3M
H223LogicalChannelParameters/segmentableFlag                               h223_lc_segmentableFlag

#----------------------------------------------------------------------------------------
#.TYPE_ATTR
UnicastAddress/iPAddress/network  TYPE = FT_IPv4  DISPLAY = BASE_NONE  STRINGS = NULL
UnicastAddress/iP6Address/network  TYPE = FT_IPv6  DISPLAY = BASE_NONE  STRINGS = NULL
MulticastAddress/iPAddress/network  TYPE = FT_IPv4  DISPLAY = BASE_NONE  STRINGS = NULL
MulticastAddress/iP6Address/network  TYPE = FT_IPv6  DISPLAY = BASE_NONE  STRINGS = NULL
RTPPayloadType/payloadDescriptor/rfc-number TYPE = FT_UINT32  DISPLAY = BASE_DEC  STRINGS = VALS(h245_RFC_number_vals)
NonStandardIdentifier/h221NonStandard/t35CountryCode TYPE = FT_UINT32  DISPLAY = BASE_DEC  STRINGS = VALS(T35CountryCode_vals)
VendorIdentification/productNumber TYPE = FT_STRING DISPLAY = BASE_NONE STRINGS = NULL
VendorIdentification/versionNumber TYPE = FT_STRING DISPLAY = BASE_NONE STRINGS = NULL
ParameterValue/octetString  TYPE = FT_UINT32 DISPLAY = BASE_DEC

#----------------------------------------------------------------------------------------
#.FIELD_ATTR
AlternativeCapabilitySet/_item NAME = "alternativeCapability"

#----------------------------------------------------------------------------------------
# vim:set ts=4 sts=2 sw=2:
